<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redis-进阶</title>
      <link href="/2021/12/19/redis-02/"/>
      <url>/2021/12/19/redis-02/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-day02"><a href="#Redis-day02" class="headerlink" title="Redis-day02"></a>Redis-day02</h1><h2 id="第一章-Redis持久化机制"><a href="#第一章-Redis持久化机制" class="headerlink" title="第一章 Redis持久化机制"></a>第一章 Redis持久化机制</h2><p>Redis的高性能是由于其将所有数据都存储在了内存中，为了使Redis在重启之后仍能保证数据不丢失，需要将数据<strong>从内存中同步到硬盘(文件)中，这一过程就是持久化</strong>。Redis 提供了一系列不同的持久化选项，包含: RDB、AOF、不持久以及RDB+AOF这四种选项</p><p>官网地址: <a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a> </p><h3 id="第一节-RDB持久化机制"><a href="#第一节-RDB持久化机制" class="headerlink" title="第一节 RDB持久化机制"></a>第一节 RDB持久化机制</h3><h4 id="1-RDB的概念"><a href="#1-RDB的概念" class="headerlink" title="1. RDB的概念"></a>1. RDB的概念</h4><p>RDB 持久化以指定的时间间隔执行数据集的快照。RDB持久化方式是Redis默认开启的，我们不配置也可以默认使用RDB持久化机制</p><h4 id="2-快照的触发时机"><a href="#2-快照的触发时机" class="headerlink" title="2. 快照的触发时机"></a>2. 快照的触发时机</h4><h5 id="2-1-基于默认配置"><a href="#2-1-基于默认配置" class="headerlink" title="2.1 基于默认配置"></a>2.1 基于默认配置</h5><table><thead><tr><th>配置</th><th>含义</th></tr></thead><tbody><tr><td>save 900 1</td><td>900秒内至少有一次修改则触发保存操作</td></tr><tr><td>save 300 10</td><td>300秒内至少有10次修改则触发保存操作</td></tr><tr><td>save 60 10000</td><td>60秒内至少有1万次修改则触发保存操作</td></tr></tbody></table><h5 id="2-2-使用保存命令"><a href="#2-2-使用保存命令" class="headerlink" title="2.2 使用保存命令"></a>2.2 使用保存命令</h5><p> save或bgsave </p><h5 id="2-3-使用flushall命令"><a href="#2-3-使用flushall命令" class="headerlink" title="2.3 使用flushall命令"></a>2.3 使用flushall命令</h5><p>这个命令也会产生dump.rdb文件，但里面是空的，没有意义 </p><h5 id="2-4-正常关闭服务器"><a href="#2-4-正常关闭服务器" class="headerlink" title="2.4 正常关闭服务器"></a>2.4 正常关闭服务器</h5><p>如果执行SHUTDOWN命令让Redis正常退出，那么此前Redis就会执行一次持久化保存。</p><h4 id="3-RDB的相关配置"><a href="#3-RDB的相关配置" class="headerlink" title="3. RDB的相关配置"></a>3. RDB的相关配置</h4><table><thead><tr><th>配置项</th><th>取值</th><th>作用</th></tr></thead><tbody><tr><td>save</td><td>900 1</td><td>设置RDB的快照时间点，如果为空则禁用RDB</td></tr><tr><td>dbfilename</td><td>文件名，例如：dump.rdb</td><td>设置RDB机制下，数据存储文件的文件名</td></tr><tr><td>dir</td><td>Redis工作目录路径</td><td>指定存放持久化文件的目录的路径。注意：这里指定的必须是目录不能是文件名</td></tr></tbody></table><h4 id="4-RDB持久化的优势"><a href="#4-RDB持久化的优势" class="headerlink" title="4. RDB持久化的优势"></a>4. RDB持久化的优势</h4><ol><li>RDB是一个简洁的按时间点生成的文件，RDB 文件非常适合备份。例如，你可能希望在最近 24 小时内每小时存档一次 RDB 文件，并在 30 天内每天保存一个 RDB 快照。这使您可以在发生灾难时轻松恢复不同版本的数据集。 </li><li>RDB 非常适合灾难恢复，它是一个可以传输到远程数据中心或者云服务器的简洁文件(文件体积不大)，并且进行数据恢复时速度很快(便于数据恢复)</li><li>RDB 最大限度地提高了 Redis 的性能，因为 Redis 父进程为了持久化需要做的唯一工作是创建一个能完成所有持久化工作子进程。父进程永远不会执行磁盘 I/O 或类似操作。</li><li>在副本上，RDB 支持重启和故障转移后的部分重新同步。</li></ol><h4 id="5-RDB的缺点"><a href="#5-RDB的缺点" class="headerlink" title="5. RDB的缺点"></a>5. RDB的缺点</h4><ol><li>容易造成数据丢失，因为RDB是在一定的时间点才会去进行持久化，例如( 300秒内至少有10次修改则触发保存操作)，那么此时如果发生不可预期的关机或断电，则会导致这几分钟之内的数据丢失</li><li> RDB 经常需要 fork() 以便使用子进程在磁盘上持久化。如果数据集很大，Fork() 可能会很耗时，如果数据集很大且 CPU 性能不是很好，则可能导致 Redis 停止为客户端服务几毫秒甚至一秒钟。 AOF 也需要 fork() 但你可以调整你想要重写日志的频率，而不会对持久性进行任何权衡。 </li></ol><h3 id="第二节-AOF持久化机制"><a href="#第二节-AOF持久化机制" class="headerlink" title="第二节 AOF持久化机制"></a>第二节 AOF持久化机制</h3><h4 id="1-AOF的概念"><a href="#1-AOF的概念" class="headerlink" title="1. AOF的概念"></a>1. AOF的概念</h4><p>AOF 持久化记录服务器收到的每个写操作，这些操作将在服务器启动时再次播放，重建原始数据集。命令使用与 Redis 协议本身相同的格式以仅附加的方式记录。当日志变得太大时，Redis 能够在后台重写日志。 </p><h4 id="2-AOF的基本配置"><a href="#2-AOF的基本配置" class="headerlink" title="2. AOF的基本配置"></a>2. AOF的基本配置</h4><table><thead><tr><th>配置项</th><th>取值</th><th>作用</th></tr></thead><tbody><tr><td>appendonly</td><td>yes</td><td>启用AOF持久化机制</td></tr><tr><td></td><td>no</td><td>禁用AOF持久化机制[默认值]</td></tr><tr><td>appendfilename</td><td>“文件名”</td><td>AOF持久化文件名</td></tr><tr><td>dir</td><td>Redis工作目录路径</td><td>指定存放持久化文件的目录的路径。注意：这里指定的必须是目录不能是文件名</td></tr><tr><td>appendfsync</td><td>always</td><td>每一次数据修改后都将执行文件写入操作，是最安全的方式但是速度缓慢。</td></tr><tr><td></td><td>everysec</td><td>每秒执行一次写入操作。折中。</td></tr><tr><td></td><td>no</td><td>由操作系统在适当的时候执行写入操作，Redis性能最好，数据保存次数最少。</td></tr></tbody></table><p>注意: 当 AOF 和 RDB 机制并存时，Redis 会优先采纳 AOF 机制。使用 AOF 持久化文件恢复内存中的数据。而 AOF 刚刚开启时 appendonly.aof 持久化文件中没有任何数据。拿空的 appendonly.aof 持久化文件恢复内存，就会导致以前所有数据都丢失。 </p><h4 id="3-AOF的优势"><a href="#3-AOF的优势" class="headerlink" title="3. AOF的优势"></a>3. AOF的优势</h4><ol><li>使用AOF可以让Redis更持久：你可以有不同的 fsync 策略：不进行fsync，每秒进行fsync，每次执行Redis命令都进行fsync。使用 fsync每秒写入性能的默认策略仍然很棒（fsync是使用后台线程执行的，当没有 fsync 正在进行时，主线程将努力执行写入。）但您只能丢失一秒钟的写入。 </li><li>AOF 日志是仅附加日志，因此在断电时不会出现寻道或损坏问题。即使日志由于某种原因（磁盘已满或其他原因）以半写命令结束，redis-check-aof 工具也能够轻松修复它。 </li><li>当 AOF文件变大时，Redis 能够在后台自动重写 AOF。重写是完全安全的，因为当 Redis 继续追加到旧文件时，会使用创建当前数据集所需的最少操作集生成一个全新的文件，一旦第二个文件准备就绪，Redis 就会切换这两个文件并开始追加到新的。 </li><li>AOF以易于理解和解析的格式包含所有操作的日志。您甚至可以轻松导出 AOF 文件。例如，即使您不小心使用 FLUSHALL删除了所有内容，只要在此期间没有重写日志，您仍然可以通过停止服务器、删除最新命令并重新启动Redis 来保存您的数据集再次。 </li></ol><h4 id="4-AOF的缺点"><a href="#4-AOF的缺点" class="headerlink" title="4. AOF的缺点"></a>4. AOF的缺点</h4><ol><li>AOF文件通常比相同数据集的等效 RDB 文件大。 </li><li>AOF持久化数据的恢复速度比RDB要慢很多</li><li>AOF可能在特定命令中遇到罕见的错误（例如，有一个涉及像 BRPOPLPUSH 这样的阻塞命令）导致生成的 AOF在重新加载时无法重现完全相同的数据集。但这种错误是极其罕见的</li></ol><h4 id="5-AOF文件重写"><a href="#5-AOF文件重写" class="headerlink" title="5. AOF文件重写"></a>5. AOF文件重写</h4><h5 id="5-1-AOF文件为什么会重写"><a href="#5-1-AOF文件为什么会重写" class="headerlink" title="5.1 AOF文件为什么会重写"></a>5.1 AOF文件为什么会重写</h5><p>随着写入操作的执行，AOF 变得越来越大。例如，如果您将计数器递增 100 次，您最终将在数据集中只有一个键包含最终值，但在 AOF 中有 100 个条目。重建当前状态不需要这些条目中的 99 个。 所以Redis支持了一个有趣的特性它能够在不中断对客户端的服务的情况下在后台重建AOF。每当您发出BGREWRITEAOF时，Redis 都会写入在内存中重建当前数据集所需的最短命令序列。在Redis 2.2及以上的版本中使用 AOF，则需要不时运行 BGREWRITEAOF，它会自动触发日志重写</p><h5 id="5-2-AOF文件重写的效果"><a href="#5-2-AOF文件重写的效果" class="headerlink" title="5.2 AOF文件重写的效果"></a>5.2 AOF文件重写的效果</h5><p>对比下面两组命令：</p><p><img src="http://www.slx.blue/2021/12/19/redis-02/tu_001.png"></p><p>两组命令执行后对于count来说最终的值是一致的，但是进行AOF重写后省略了中间过程，可以让AOF文件体积更小，缩短数据恢复时间。而Redis会根据AOF文件的体积来决定是否进行AOF重写。参考的配置项如下：</p><table><thead><tr><th>配置项</th><th>含义</th></tr></thead><tbody><tr><td>auto-aof-rewrite-percentage 100</td><td>文件体积增大100%时执行AOF重写</td></tr><tr><td>auto-aof-rewrite-min-size 64mb</td><td>文件体积增长到64mb时执行AOF重写</td></tr></tbody></table><p>实际工作中不要进行频繁的AOF重写，因为CPU、内存资源和硬盘资源三者之间肯定是CPU、内存资源更加宝贵，所以不应该过多耗费CPU性能去节省硬盘空间。另外数据恢复也不是高频操作，所以节约数据恢复时间价值也不是非常大。</p><h3 id="第三节-如何修复损坏的AOF文件"><a href="#第三节-如何修复损坏的AOF文件" class="headerlink" title="第三节 如何修复损坏的AOF文件"></a>第三节 如何修复损坏的AOF文件</h3><p>Redis服务器启动时如果读取了损坏的AOF持久化文件会导致启动失败，此时为了让Redis服务器能够正常启动，需要对损坏的持久化文件进行修复。 </p><ul><li><p>第一步：备份要修复的appendonly.aof文件</p></li><li><p>第二步：执行修复程序</p><p>/usr/local/redis/bin/redis-check-aof –fix /usr/local/redis/appendonly.aof</p></li><li><p>第三步：重启Redis</p></li></ul><p>注意：所谓修复持久化文件仅仅是把损坏的部分去掉，而没法把受损的数据找回。</p><h3 id="第四节-如何选择Redis的持久化选项"><a href="#第四节-如何选择Redis的持久化选项" class="headerlink" title="第四节 如何选择Redis的持久化选项"></a>第四节 如何选择Redis的持久化选项</h3><p>官方建议:</p><p>一般的迹象是，如果您想要与 PostgreSQL 可以提供的数据安全程度相当的数据安全性，则应该同时使用这两种持久性方法。 如果您非常关心您的数据，但在发生灾难时仍然可以忍受几分钟的数据丢失，您可以简单地单独使用 RDB。 有许多用户单独使用 AOF，但我们不鼓励它，因为不时拥有 RDB 快照对于进行数据库备份、更快地重新启动以及在 AOF 引擎中出现错误时是一个好主意。 注意：由于所有这些原因，我们很可能在未来将 AOF 和 RDB 统一为一个持久化模型（长期计划）。 </p><p>我的理解是:</p><p>如果Redis仅仅作为缓存可以不使用任何持久化方式。</p><p>其他应用方式综合考虑性能和完整性、一致性要求。</p><p>RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘允许，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。如果不开启AOF，仅靠Master-Slave Replication 实现高可用性能也不错。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时挂掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构。</p><h2 id="第二章-Jedis"><a href="#第二章-Jedis" class="headerlink" title="第二章 Jedis"></a>第二章 Jedis</h2><h3 id="第一节-Jedis的入门"><a href="#第一节-Jedis的入门" class="headerlink" title="第一节 Jedis的入门"></a>第一节 Jedis的入门</h3><h4 id="1-Jedis的简介"><a href="#1-Jedis的简介" class="headerlink" title="1. Jedis的简介"></a>1. Jedis的简介</h4><p>Redis不仅是使用命令来操作，现在基本上主流的语言都有客户端支持，比如java、C、C#、C++、php、Node.js、Go等。 在官方网站里列一些Java的客户端，有Jedis、Redisson、Jredis、JDBC-Redis、等其中官方推荐使用Jedis和Redisson。 在企业中用的最多的就是Jedis，Jedis同样也是托管在github上</p><h4 id="2-修改Redis配置文件中的bind配置项"><a href="#2-修改Redis配置文件中的bind配置项" class="headerlink" title="2. 修改Redis配置文件中的bind配置项"></a>2. 修改Redis配置文件中的bind配置项</h4><h5 id="2-1-bind配置项的作用"><a href="#2-1-bind配置项的作用" class="headerlink" title="2.1 bind配置项的作用"></a>2.1 bind配置项的作用</h5><p>bind后面跟的ip地址是客户端访问Redis时使用的IP地址。规则是：Redis要求客户端访问的地址，必须是 bind 配置项绑定的地址。看下面例子：</p><table><thead><tr><th>bind值</th><th>访问方式</th></tr></thead><tbody><tr><td>127.0.0.1</td><td>./redis-cli -h 127.0.0.1</td></tr><tr><td>192.168.200.100</td><td>./redis-cli -h 192.168.200.100</td></tr></tbody></table><p>所以，结论是：bind 配置项要绑定可以对外暴露的本机地址。那么 Redis 为什么会有这样的要求？就是因为在实际项目中，Redis 不是给用户直接访问的，而是给 Java 程序访问的。所以 Redis 只要绑定一个内部访问地址，就能够屏蔽外部的访问，所以这个地址绑定机制，能够对 Redis 进行保护。 </p><h5 id="2-2-修改bind配置项"><a href="#2-2-修改bind配置项" class="headerlink" title="2.2 修改bind配置项"></a>2.2 修改bind配置项</h5><p>因为我们是在宿主机Windows系统中编写Java代码，而Redis服务器是在虚拟机Linux系统中运行，所以为了让Redis能够被远程客户端访问，我们需要修改bind的配置，在redis.conf配置文件中将bind的值配置成虚拟机的IP地址</p><pre><code>例如:原本的是bind 127.0.0.1现在改成bind 127.0.0.1 192.168.141.135改完需要重启redis服务器</code></pre><p>千万不要把<code>127.0.0.1删掉</code>，如果删掉了的话，则Linux本机无法访问Redis。</p><p>将bind的值修改成<code>0.0.0.0</code>也可以实现本机和远程都能连接redis服务器。</p><p>当然还有另一种方式可以让Redis被远程客户端访问，那就是关闭Redis的安全模式: 在redis.conf配置文件中将<code>protected-mode</code>的值设置为<code>no</code></p><h4 id="3-使用Jedis"><a href="#3-使用Jedis" class="headerlink" title="3. 使用Jedis"></a>3. 使用Jedis</h4><h5 id="3-1-引入Jedis的依赖"><a href="#3-1-引入Jedis的依赖" class="headerlink" title="3.1 引入Jedis的依赖"></a>3.1 引入Jedis的依赖</h5><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;redis.clients&lt;/groupId&gt;    &lt;artifactId&gt;jedis&lt;/artifactId&gt;    &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h5 id="3-2-Jedis的使用代码"><a href="#3-2-Jedis的使用代码" class="headerlink" title="3.2 Jedis的使用代码"></a>3.2 Jedis的使用代码</h5><pre><code class="java">//指定Redis服务器的IP地址和端口号Jedis jedis = new Jedis(&quot;Jedis服务器的IP地址&quot;, 6379);//jedis的方法是与jedis的命令一一对应的//存储一个键值对jedis.set(&quot;tom:code&quot;,&quot;123456&quot;);//根据key获取值System.out.println(jedis.get(&quot;tom:code&quot;));    //关闭连接jedis.close();</code></pre><h4 id="4-JedisPool的使用"><a href="#4-JedisPool的使用" class="headerlink" title="4. JedisPool的使用"></a>4. JedisPool的使用</h4><p>JedisPool是Jedis的连接池</p><pre><code class="java">@Testpublic void testJedisPool()&#123;    //测试使用Jedis连接池    //1. 创建连接池    JedisPool jedisPool = new JedisPool(&quot;192.168.141.136&quot;,6379);    //2. 我们可以对连接池进行配置    GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();    //最大连接数    poolConfig.setMaxTotal(20);    //最大闲置连接数    poolConfig.setMaxIdle(20);    //最小闲置连接数    poolConfig.setMinIdle(0);    poolConfig.setMaxWaitMillis(3000);    //3. 使用连接池获取连接    Jedis jedis = jedisPool.getResource();    System.out.println(jedis.get(&quot;username&quot;));    //归还连接    jedis.close();&#125;</code></pre><h2 id="第三章-Redis事务控制"><a href="#第三章-Redis事务控制" class="headerlink" title="第三章 Redis事务控制"></a>第三章 Redis事务控制</h2><h3 id="第一节-Redis事务的概述"><a href="#第一节-Redis事务的概述" class="headerlink" title="第一节 Redis事务的概述"></a>第一节 Redis事务的概述</h3><h4 id="1-事务的作用"><a href="#1-事务的作用" class="headerlink" title="1. 事务的作用"></a>1. 事务的作用</h4><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>Redis事务的主要作用就是串联多个命令防止别的命令插队。</p><h4 id="2-事务控制的相关命令"><a href="#2-事务控制的相关命令" class="headerlink" title="2. 事务控制的相关命令"></a>2. 事务控制的相关命令</h4><table><thead><tr><th>命令名</th><th>作用</th></tr></thead><tbody><tr><td>MULTI</td><td>表示开始收集命令，后面所有命令都不是马上执行，而是加入到一个队列中。</td></tr><tr><td>EXEC</td><td>执行MULTI后面命令队列中的所有命令。</td></tr><tr><td>DISCARD</td><td>放弃执行队列中的命令。</td></tr><tr><td>WATCH</td><td>“观察“、”监控“一个KEY，在当前队列外的其他命令操作这个KEY时，放弃执行自己队列的命令</td></tr><tr><td>UNWATCH</td><td>放弃监控一个KEY</td></tr></tbody></table><h3 id="第二节-命令队列执行失败的两种情况"><a href="#第二节-命令队列执行失败的两种情况" class="headerlink" title="第二节 命令队列执行失败的两种情况"></a>第二节 命令队列执行失败的两种情况</h3><h4 id="1-加入队列时失败"><a href="#1-加入队列时失败" class="headerlink" title="1. 加入队列时失败"></a>1. 加入队列时失败</h4><p><img src="http://www.slx.blue/2021/12/19/redis-02/tu_003.png"></p><p>入队过程中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p><h4 id="2-执行队列时失败"><a href="#2-执行队列时失败" class="headerlink" title="2. 执行队列时失败"></a>2. 执行队列时失败</h4><p><img src="http://www.slx.blue/2021/12/19/redis-02/tu_004.png"></p><p>错误在入队时检测不出来，整个队列执行时有错的命令执行失败，但是其他命令并没有回滚。 </p><h4 id="3-Redis为什么不支持回滚"><a href="#3-Redis为什么不支持回滚" class="headerlink" title="3. Redis为什么不支持回滚"></a>3. Redis为什么不支持回滚</h4><p>官方解释如下：</p><blockquote><p>如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。以下是这种做法的优点： 1.Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。 2.因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。 有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。</p></blockquote><h3 id="第三节-悲观锁和乐观锁"><a href="#第三节-悲观锁和乐观锁" class="headerlink" title="第三节 悲观锁和乐观锁"></a>第三节 悲观锁和乐观锁</h3><h4 id="1-悲观锁"><a href="#1-悲观锁" class="headerlink" title="1. 悲观锁"></a>1. 悲观锁</h4><p>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p><h4 id="2-乐观锁"><a href="#2-乐观锁" class="headerlink" title="2. 乐观锁"></a>2. 乐观锁</h4><p>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</p><ul><li>如果是基于最新的版本所做的修改：服务器接受，修改成功</li><li>如果是基于旧的版本号所做的修改：服务器不接受，修改失败，整个MULTI队列中的操作都被丢弃</li></ul><p>乐观锁适用于多读的应用类型，这样可以提高吞吐量。在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。这就是乐观锁的具体体现</p><h2 id="第四章-Redis的主从复制机制"><a href="#第四章-Redis的主从复制机制" class="headerlink" title="第四章 Redis的主从复制机制"></a>第四章 Redis的主从复制机制</h2><h3 id="第一节-主从复制的概述"><a href="#第一节-主从复制的概述" class="headerlink" title="第一节 主从复制的概述"></a>第一节 主从复制的概述</h3><h4 id="1-什么是主从复制"><a href="#1-什么是主从复制" class="headerlink" title="1. 什么是主从复制"></a>1. 什么是主从复制</h4><p>主从复制是主机数据更新后根据配置和策略， 自动同步到备机的master/slave机制，Master以写为主，Slave以读为主</p><p><img src="http://www.slx.blue/2021/12/19/redis-02/tu_005.png"></p><h4 id="2-主从复制的目的"><a href="#2-主从复制的目的" class="headerlink" title="2. 主从复制的目的"></a>2. 主从复制的目的</h4><ul><li>性能优化：主服务器专注于写操作，可以用更适合写入数据的模式工作；同样，从服务器专注于读操作，可以用更适合读取数据的模式工作。</li><li>强化数据安全，避免单点故障：由于数据同步机制的存在，各个服务器之间数据保持一致，所以其中某个服务器宕机不会导致数据丢失或无法访问。从这个角度说参与主从复制的Redis服务器构成了一个<strong>集群</strong>。</li></ul><h3 id="第二节-搭建主从复制集群"><a href="#第二节-搭建主从复制集群" class="headerlink" title="第二节 搭建主从复制集群"></a>第二节 搭建主从复制集群</h3><h4 id="1-搭建思路"><a href="#1-搭建思路" class="headerlink" title="1. 搭建思路"></a>1. 搭建思路</h4><p>Redis集群在运行时使用的是同一个可执行文件(redis-server)，只是对应的配置文件(redis.conf)不同。 </p><p><img src="http://www.slx.blue/2021/12/19/redis-02/tu_006.png"></p><p>每个配置文件相同的参数是:</p><pre><code>daemonize yesdir /usr/local/cluster-redis</code></pre><p>不同的参数是:</p><table><thead><tr><th>配置项名称</th><th align="left">作用</th><th>取值</th></tr></thead><tbody><tr><td>port</td><td align="left">Redis服务器启动后监听的端口号</td><td>6000 7000 8000</td></tr><tr><td>dbfilename</td><td align="left">RDB文件存储文件名</td><td>dump6000.rdb                                                                                   dump7000.rdb                                                                        dump8000.rdb</td></tr><tr><td>logfile</td><td align="left">日志文件位置</td><td>/var/logs/redis6000.log                                                /var/logs/redis7000.log                                               /var/logs/redis8000.log</td></tr><tr><td>pidfile</td><td align="left">pid文件位置</td><td>/var/run/redis6000.pid                                                          /var/run/redis7000.pid                                                         /var/run/redis8000.pid</td></tr></tbody></table><h4 id="2-搭建步骤"><a href="#2-搭建步骤" class="headerlink" title="2. 搭建步骤"></a>2. 搭建步骤</h4><ul><li>第一步：创建/usr/local/cluster-redis目录<code>mkdir /usr/local/cluster-redis</code></li><li>第二步：把原始未经修改的redis.conf复制到/usr/local/cluster-redis目录,并且改名为redis6000.conf</li></ul><pre><code>cp /usr/local/redis/redis.conf /usr/local/cluster-redis/redis6000.conf</code></pre><ul><li>第三步：按照既定计划修改redis6000.conf中的相关配置项<ul><li>daemonize yes</li><li>dir</li><li>port</li><li>dbfilename</li><li>logfile</li><li>pidfile</li></ul></li><li>第五步：复制redis6000.conf为redis7000.conf</li><li>第六步：修改redis7000.conf中的相关配置项<ul><li>port</li><li>dbfilename</li><li>logfile</li><li>pidfile</li></ul></li><li>第七步：复制redis6000.conf为redis8000.conf</li><li>第八步：修改redis8000.conf中的相关配置项<ul><li>port</li><li>dbfilename</li><li>logfile</li><li>pidfile</li></ul></li></ul><h4 id="3-启动Redis主从复制集群"><a href="#3-启动Redis主从复制集群" class="headerlink" title="3. 启动Redis主从复制集群"></a>3. 启动Redis主从复制集群</h4><p>进入<code>/usr/local/redis/bin</code>目录下:</p><pre><code>./redis-server /usr/local/cluster-redis/redis6000.conf./redis-server /usr/local/cluster-redis/redis7000.conf./redis-server /usr/local/cluster-redis/redis8000.conf</code></pre><p>使用redis-cli连接指定服务器的命令格式如下:</p><pre><code>/usr/local/redis/bin/redis-cli -h IP地址 -p 端口号</code></pre><p>使用redis-cli停止指定服务器的命令格式如下：<br><code>/usr/local/redis/bin/redis-cli -h IP地址 -p 端口号 shutdown </code></p><h3 id="第三节-主从关系"><a href="#第三节-主从关系" class="headerlink" title="第三节 主从关系"></a>第三节 主从关系</h3><h4 id="1-查看主从关系"><a href="#1-查看主从关系" class="headerlink" title="1. 查看主从关系"></a>1. 查看主从关系</h4><p>刚刚启动的集群服务器中每一个节点服务器都认为自己是主服务器。需要建立主从关系。 </p><p><img src="http://www.slx.blue/2021/12/19/redis-02/tu_007.png"></p><h4 id="2-配置主从关系"><a href="#2-配置主从关系" class="headerlink" title="2. 配置主从关系"></a>2. 配置主从关系</h4><p>只需要在从机上指定主机的地址和端口号即可</p><pre><code>SLAVEOF 127.0.0.1 6000</code></pre><p>此时表示本机的<code>6000</code>端口是主机</p><h4 id="3-取消主从关系"><a href="#3-取消主从关系" class="headerlink" title="3. 取消主从关系"></a>3. 取消主从关系</h4><p>只需要在从机上执行命令<code>SLAVEOF NO ONE</code>即可，那么此时从机就自己变成了主机</p><h4 id="4-执行测试"><a href="#4-执行测试" class="headerlink" title="4. 执行测试"></a>4. 执行测试</h4><ul><li>测试1：在主机写入数据，在从机查看</li><li>测试2：在从机写入数据会报错。配置文件中的依据是：slave-read-only yes</li><li>测试3：主机执行SHUTDOWN看从机状态</li><li>测试4：主机恢复启动，看从机状态</li><li>测试5：从机SHUTDOWN，此时主机写入数据，从机恢复启动查看状态。重新设定主从关系后看新写入的数据是否同步。</li></ul><h3 id="第四节-哨兵模式"><a href="#第四节-哨兵模式" class="headerlink" title="第四节 哨兵模式"></a>第四节 哨兵模式</h3><h4 id="1-哨兵模式的概念"><a href="#1-哨兵模式的概念" class="headerlink" title="1. 哨兵模式的概念"></a>1. 哨兵模式的概念</h4><p>能够后台监控主机是否故障，如果故障了根据投票数自动将从机转换为主机，通过哨兵服务器监控master/slave可以实现主从复制集群的自动管理</p><h4 id="2-相关概念"><a href="#2-相关概念" class="headerlink" title="2. 相关概念"></a>2. 相关概念</h4><h5 id="2-1-主观下线"><a href="#2-1-主观下线" class="headerlink" title="2.1 主观下线"></a>2.1 主观下线</h5><p>一台哨兵服务器检测到某个节点服务器下线了</p><h5 id="2-2-客观下线"><a href="#2-2-客观下线" class="headerlink" title="2.2 客观下线"></a>2.2 客观下线</h5><p>检测到某个节点服务器下线的哨兵服务器达到了一定数量，这个数量后续会在哨兵的启动配置文件中指定。注意：只有master机需要做客观下线判断，slave机只需要做主观下线判断</p><h5 id="2-3-心跳检查"><a href="#2-3-心跳检查" class="headerlink" title="2.3 心跳检查"></a>2.3 心跳检查</h5><p>心跳(heart beat)检查是指客户端为了确认服务器端是否正常运行，会不断地给服务器端发送数据包，通过服务器端返回的数据包判断服务器端是否正在运行的一种工作机制</p><h4 id="3-配置哨兵"><a href="#3-配置哨兵" class="headerlink" title="3. 配置哨兵"></a>3. 配置哨兵</h4><p>简单起见我们只配置一台哨兵。我们所需要做的就是创建一个哨兵服务器运行所需要的配置文件。</p><p><code>touch /usr/local/cluster-redis/sentinel.conf</code></p><p>编辑sentinel.conf文件:</p><table><thead><tr><th>格式</th><th>例子</th></tr></thead><tbody><tr><td>sentinel monitor 为主机命名 主机IP 主机端口号 将主机判定为下线时需要Sentinel同意的数量</td><td>sentinel monitor mymaster 127.0.0.1 6000 1</td></tr></tbody></table><h4 id="4-启动哨兵"><a href="#4-启动哨兵" class="headerlink" title="4. 启动哨兵"></a>4. 启动哨兵</h4><p>进入<code>/usr/local/redis/bin</code>目录中:</p><p>然后执行<code>./redis-server /usr/local/cluster-redis/sentinel.conf --sentinel  </code></p><p>假设两个 slave 服务器参与选举：</p><ul><li>情况1：<ul><li>slave A：投票给 slave B</li><li>slave B：投票给 slave A</li><li>两个服务器各得一票，平手，不能确定，需要继续投票</li></ul></li><li>情况2：<ul><li>slave A：投票给自己</li><li>slave B：投票给自己</li><li>两个服务器各得一票，平手，不能确定，需要继续投票</li></ul></li><li>情况3：<ul><li>slave A：投票给自己</li><li>slave B：投票给 slave A</li><li>slave A 得 2 票，slave B 没有得票，所以 slave A 当选</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-入门</title>
      <link href="/2021/12/19/redis-01/"/>
      <url>/2021/12/19/redis-01/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-day01"><a href="#Redis-day01" class="headerlink" title="Redis-day01"></a>Redis-day01</h1><h2 id="第一章-非关系型数据库的简介"><a href="#第一章-非关系型数据库的简介" class="headerlink" title="第一章 非关系型数据库的简介"></a>第一章 非关系型数据库的简介</h2><h3 id="第一节-技术发展线路"><a href="#第一节-技术发展线路" class="headerlink" title="第一节 技术发展线路"></a>第一节 技术发展线路</h3><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_001.png"></p><h3 id="第二节-互联网发展所面临的问题"><a href="#第二节-互联网发展所面临的问题" class="headerlink" title="第二节 互联网发展所面临的问题"></a>第二节 互联网发展所面临的问题</h3><h4 id="1-Web1-0-时代"><a href="#1-Web1-0-时代" class="headerlink" title="1. Web1.0 时代"></a>1. Web1.0 时代</h4><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_002.png"></p><h4 id="2-Web2-0时代"><a href="#2-Web2-0时代" class="headerlink" title="2. Web2.0时代"></a>2. Web2.0时代</h4><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_003.png"></p><h4 id="3-互联网三高问题"><a href="#3-互联网三高问题" class="headerlink" title="3. 互联网三高问题"></a>3. 互联网三高问题</h4><h5 id="3-1-高并发、大流量"><a href="#3-1-高并发、大流量" class="headerlink" title="3.1 高并发、大流量"></a>3.1 高并发、大流量</h5><p>大型网站系统需要面对高并发(QPS)用户，大流量访问。Google日均PV数35亿，日均IP访问数3亿；腾讯QQ的最大在线用户数1.4亿（2011年数据）；微信用户量已超11亿；2019年天猫双十一交易额突破2500亿。 </p><h5 id="3-2-高可用"><a href="#3-2-高可用" class="headerlink" title="3.2 高可用"></a>3.2 高可用</h5><p>系统7×24小时不间断服务。大型互联网站的宕机事件通常会成为新闻焦点，微博宕机、B站挂了、腾讯视频挂了，成为重大新闻热点。 </p><h5 id="3-3-海量数据"><a href="#3-3-海量数据" class="headerlink" title="3.3 海量数据"></a>3.3 海量数据</h5><p>需要存储、管理海量数据，需要使用大量服务器。Facebook每周上传的照片数目接近10亿，百度收录的网页数目有数百亿，Google有近百万台服务器为全球用户提供服务。 </p><h3 id="第三节-解决上述问题的思路"><a href="#第三节-解决上述问题的思路" class="headerlink" title="第三节 解决上述问题的思路"></a>第三节 解决上述问题的思路</h3><h4 id="1-解决CPU和内存压力问题"><a href="#1-解决CPU和内存压力问题" class="headerlink" title="1. 解决CPU和内存压力问题"></a>1. 解决CPU和内存压力问题</h4><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_004.png"></p><h4 id="2-解决IO压力问题"><a href="#2-解决IO压力问题" class="headerlink" title="2. 解决IO压力问题"></a>2. 解决IO压力问题</h4><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_005.png"></p><h3 id="第四节-非关系型数据库的概念"><a href="#第四节-非关系型数据库的概念" class="headerlink" title="第四节 非关系型数据库的概念"></a>第四节 非关系型数据库的概念</h3><p>NoSQL是Not only SQL的缩写，大意为“不只是SQL”，说明这项技术是<strong>传统关系型数据库的补充</strong>而非替代。在整个NoSQL技术栈中<strong>MemCache</strong>、<strong>Redis</strong>、<strong>MongoDB</strong>被称为NoSQL三剑客。那么时代为什么需要NoSQL数据库呢？</p><p>我们来做个对比：</p><h4 id="1-关系型数据库和非关系型数据库的对比"><a href="#1-关系型数据库和非关系型数据库的对比" class="headerlink" title="1. 关系型数据库和非关系型数据库的对比"></a>1. 关系型数据库和非关系型数据库的对比</h4><table><thead><tr><th>对比项</th><th>关系型数据库</th><th>非关系型数据库</th></tr></thead><tbody><tr><td>数据存储位置</td><td>硬盘</td><td>内存</td></tr><tr><td>数据结构</td><td>高度组织化结构化数据</td><td>没有预定义的模式</td></tr><tr><td>数据操作方式</td><td>SQL</td><td>所有数据都是键值对，没有声明性查询语言</td></tr><tr><td>事务控制</td><td>严格的基于事务ACID原则</td><td>基于乐观锁的松散事务控制</td></tr><tr><td>访问控制</td><td>细粒度的用户访问权限控制</td><td>简单的基于IP绑定或密码的访问控制</td></tr><tr><td>外键</td><td>支持</td><td>不支持</td></tr><tr><td>索引</td><td>支持</td><td>不支持</td></tr></tbody></table><p>所以NoSQL数据库的最大优势体现为：高性能、高可用性和可伸缩性。</p><h4 id="2-非关系型数据库的适用场景"><a href="#2-非关系型数据库的适用场景" class="headerlink" title="2. 非关系型数据库的适用场景"></a>2. 非关系型数据库的适用场景</h4><ul><li><p>对数据高并发的读写</p></li><li><p>海量数据的读写</p></li><li><p>对数据高可扩展性的</p></li></ul><h4 id="3-非关系型数据库不适用的常见"><a href="#3-非关系型数据库不适用的常见" class="headerlink" title="3. 非关系型数据库不适用的常见"></a>3. 非关系型数据库不适用的常见</h4><ul><li><p>需要事务支持</p></li><li><p>基于sql的结构化查询存储，处理复杂的关系,需要即席查询。</p></li></ul><h2 id="第二章-Redis的简介"><a href="#第二章-Redis的简介" class="headerlink" title="第二章 Redis的简介"></a>第二章 Redis的简介</h2><h3 id="第一节-Redis的官方介绍"><a href="#第一节-Redis的官方介绍" class="headerlink" title="第一节 Redis的官方介绍"></a>第一节 Redis的官方介绍</h3><p>中文官网介绍: Redis是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如字符串（strings），散列（hashes），列表（lists），集合（sets），有序集合（sorted sets） 与范围查询，bitmaps，hyperloglogs和地理空间（geospatial） 索引半径查询。 Redis 内置了复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions）和不同级别的磁盘持久化（persistence）， 并通过Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）。</p><p>下面是几点补充：</p><ul><li>Redis的名字是Remote Dictionary Server的缩写。</li><li>开发语言是ANSI C。</li><li>支持多种不同语言的客户端。</li><li>官方给出的性能参考（在并发量50的情况下）：<ul><li>GET: 110000/s:读的速度每秒11万次</li><li>SET: 81000/s: 写的速度每秒8万次</li></ul></li></ul><p>中文官网<a href="http://www.redis.cn/">http://www.redis.cn</a><br>英文官网<a href="http://redis.io/">http://redis.io</a></p><p>Redis命令参考文档网址：<a href="http://redisdoc.com/">http://redisdoc.com</a></p><h3 id="第二节-Redis的应用场景"><a href="#第二节-Redis的应用场景" class="headerlink" title="第二节 Redis的应用场景"></a>第二节 Redis的应用场景</h3><h4 id="1-配合关系型数据库做高速缓存"><a href="#1-配合关系型数据库做高速缓存" class="headerlink" title="1. 配合关系型数据库做高速缓存"></a>1. 配合关系型数据库做高速缓存</h4><p>使用Redis可以建立性能非常出色的缓存服务器，查询请求先在Redis中查找所需要的数据，如果能够查询到（命中）则直接返回，大大减轻关系型数据库的压力。 例如: 高频次，热门访问，并且不会经常变化的数据，降低数据库IO</p><h4 id="2-数据临时存储位置"><a href="#2-数据临时存储位置" class="headerlink" title="2. 数据临时存储位置"></a>2. 数据临时存储位置</h4><p>使用token（令牌）作为用户登录系统时的身份标识，这个token就可以在Redis中临时存储。</p><h4 id="3-作为分布式环境下解决Session不一致问题时的Session库"><a href="#3-作为分布式环境下解决Session不一致问题时的Session库" class="headerlink" title="3. 作为分布式环境下解决Session不一致问题时的Session库"></a>3. 作为分布式环境下解决Session不一致问题时的Session库</h4><p>Spring提供了一种技术解决分布式环境下Session不一致问题，叫SpringSession。而Redis就可以为SpringSession提供一个数据存储空间。 </p><h4 id="4-多样的数据结构存储持久化数据"><a href="#4-多样的数据结构存储持久化数据" class="headerlink" title="4. 多样的数据结构存储持久化数据"></a>4. 多样的数据结构存储持久化数据</h4><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_006.png"></p><h2 id="第三章-安装Redis"><a href="#第三章-安装Redis" class="headerlink" title="第三章 安装Redis"></a>第三章 安装Redis</h2><h3 id="第一节-安装Linux版本的Redis"><a href="#第一节-安装Linux版本的Redis" class="headerlink" title="第一节 安装Linux版本的Redis"></a>第一节 安装Linux版本的Redis</h3><h4 id="1-具体安装步骤"><a href="#1-具体安装步骤" class="headerlink" title="1. 具体安装步骤"></a>1. 具体安装步骤</h4><h5 id="1-1-上传redis压缩包"><a href="#1-1-上传redis压缩包" class="headerlink" title="1.1 上传redis压缩包"></a>1.1 上传redis压缩包</h5><p>使用xftp将redis压缩包上传到虚拟机的<code>/usr/local</code>目录中</p><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_007.png"></p><p>上传完之后建议拍个快照，以防安装出错</p><h5 id="1-2-安装c语言编译环境"><a href="#1-2-安装c语言编译环境" class="headerlink" title="1.2 安装c语言编译环境"></a>1.2 安装c语言编译环境</h5><p>因为是Redis是c语言开发的，所以要运行redis必须有c语言编译环境</p><pre><code class="shell">yum install gcc-c++ -y# 安装GCC环境，中间有确认的话，一律选y (yes)# 注意：使用yum命令安装软件，需要联网</code></pre><h5 id="1-3-解压redis"><a href="#1-3-解压redis" class="headerlink" title="1.3 解压redis"></a>1.3 解压redis</h5><ol><li>进入<code>/usr/local</code>目录: <code>cd /usr/local</code></li><li>解压: <code>tar -xvf redis-5.0.13.tar.gz</code></li></ol><h5 id="1-4-重命名文件夹"><a href="#1-4-重命名文件夹" class="headerlink" title="1.4 重命名文件夹"></a>1.4 重命名文件夹</h5><p>将 <code>redis-5.0.13</code>重命名成<code>redis</code></p><pre><code class="shell">mv redis-5.0.13 redis</code></pre><h5 id="1-5-编译安装"><a href="#1-5-编译安装" class="headerlink" title="1.5 编译安装"></a>1.5 编译安装</h5><ol><li>进入redis目录:<code>cd redis/</code></li><li>编译redis:<code>make</code></li><li>指定安装路径并且安装: <code>make PREFIX=/usr/local/redis install</code>，安装好之后<code>/usr/local/redis</code>目录中会多出来一个<code>bin</code>目录</li></ol><h4 id="2-redis的配置和启动"><a href="#2-redis的配置和启动" class="headerlink" title="2. redis的配置和启动"></a>2. redis的配置和启动</h4><h5 id="2-1-修改配置文件"><a href="#2-1-修改配置文件" class="headerlink" title="2.1 修改配置文件"></a>2.1 修改配置文件</h5><ol><li><p>将<code>/usr/local/redis/redis.conf</code>配置文件拷贝到<code>/usr/local/redis/bin</code>目录中</p></li><li><p>使用<code>vim</code>编辑器修改<code>bin</code>目录中的<code>redis.conf</code>文件,修改如下三项</p><p><strong>注意：/var/logs目录需要我们提前创建好</strong></p><table><thead><tr><th>配置项名称</th><th>作用</th><th>取值</th></tr></thead><tbody><tr><td>daemonize</td><td>控制是否以守护进程形式运行Redis服务器</td><td>yes</td></tr><tr><td>logfile</td><td>指定日志文件位置</td><td>“/var/logs/redis.log”</td></tr><tr><td>dir</td><td>Redis工作目录</td><td>/usr/local/redis</td></tr></tbody></table></li></ol><h5 id="2-2-后台启动redis服务器"><a href="#2-2-后台启动redis服务器" class="headerlink" title="2.2 后台启动redis服务器"></a>2.2 后台启动redis服务器</h5><ol><li>进入redis的bin目录: <code>cd /usr/local/redis/bin</code></li><li>让redis根据配置文件启动: <code>./redis-server ./redis.conf</code></li></ol><h5 id="2-3-启动redis客户端连接服务器"><a href="#2-3-启动redis客户端连接服务器" class="headerlink" title="2.3 启动redis客户端连接服务器"></a>2.3 启动redis客户端连接服务器</h5><p><code>./redis-cli</code>,然后执行<code>ping</code>命令，如果能连接上，代表redis安装成功，并且redis服务器启动成功</p><h3 id="第二节-Windows版本Redis的安装-不建议使用"><a href="#第二节-Windows版本Redis的安装-不建议使用" class="headerlink" title="第二节 Windows版本Redis的安装(不建议使用)"></a>第二节 Windows版本Redis的安装(不建议使用)</h3><p>Redis官方没有开发支持Windows的版本， 但是，Microsoft开发技术小组开发和维护了Redis的Windows版本(只能使用在64位的电脑上)</p><h4 id="1-具体安装步骤-1"><a href="#1-具体安装步骤-1" class="headerlink" title="1. 具体安装步骤"></a>1. 具体安装步骤</h4><h5 id="1-1-软件所在位置"><a href="#1-1-软件所在位置" class="headerlink" title="1.1 软件所在位置"></a>1.1 软件所在位置</h5><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_008.png"></p><p>任选一个版本均可，建议选最高的</p><h5 id="1-2-开始安装"><a href="#1-2-开始安装" class="headerlink" title="1.2 开始安装"></a>1.2 开始安装</h5><ol><li><p>双击msi文件</p><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_009.png"></p></li><li><p>直接点击下一步</p><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_009.png"></p></li><li><p>同意协议</p><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_010.png"></p></li><li><p>设置安装路径</p><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_011.png"></p></li><li><p>端口号为<code>6379</code>不变</p></li></ol><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_012.png"></p><ol start="6"><li>设置最大内存空间限制</li></ol><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_013.png"></p><ol start="7"><li>开始安装</li></ol><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_014.png"></p><ol start="8"><li><p>安装之后的目录结构</p><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_015.png"></p></li></ol><h4 id="2-启动Redis服务"><a href="#2-启动Redis服务" class="headerlink" title="2. 启动Redis服务"></a>2. 启动Redis服务</h4><p>redis安装之后是Windows中的服务,采用启动和关闭服务的方式对其进行启动和关闭即可</p><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_016.png"></p><h4 id="3-客户端连接Redis"><a href="#3-客户端连接Redis" class="headerlink" title="3. 客户端连接Redis"></a>3. 客户端连接Redis</h4><p>双击redis安装路径中的<code>redis-cli.exe</code>即可打开redis的客户端，然后连接到redis服务</p><h4 id="4-安装Redis可视化客户端"><a href="#4-安装Redis可视化客户端" class="headerlink" title="4. 安装Redis可视化客户端"></a>4. 安装Redis可视化客户端</h4><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_021.png"></p><p>但是Windows中的Redis可视化客户端默认无法与Linux中的Redis服务器连接，需要修改Linux中的Redis服务器的配置: 在redis.conf配置文件中在bind的值的后面加上虚拟机的IP地址(在后面将Jedis的时候会讲到)，并且要确保Linux的防火墙放行了”6379”端口，或者防火墙关闭了</p><pre><code>例如:原本的是bind 127.0.0.1现在改成bind 127.0.0.1 192.168.141.135</code></pre><p>改完之后要重启redis:</p><pre><code>先找到redis服务的进程idps -ef | grep redis然后根据进程id杀死进程kill -9 进程id</code></pre><h2 id="第三章-Redis常用数据结构"><a href="#第三章-Redis常用数据结构" class="headerlink" title="第三章 Redis常用数据结构"></a>第三章 Redis常用数据结构</h2><h3 id="第一节-Redis总体结构"><a href="#第一节-Redis总体结构" class="headerlink" title="第一节 Redis总体结构"></a>第一节 Redis总体结构</h3><p>Redis中的数据，总体上是键值对，不同数据类型指的是键值对中值的类型。其中value支持8种数据类型</p><table><thead><tr><th>数据类型</th><th>应用场景</th></tr></thead><tbody><tr><td>string</td><td>分布式Session存储 分布式数据库ID 计数器：统计网站访问量</td></tr><tr><td>hash</td><td>存储对象信息（购物车中的商品信息） 存储表的信息</td></tr><tr><td>list</td><td>实现队列、栈操作 汇总日志 粉丝列表 关注的人列表</td></tr><tr><td>set</td><td>签到 打卡 点赞</td></tr><tr><td>zset</td><td>排行榜 百度热点搜索</td></tr><tr><td>geospatial</td><td>获取地理位置信息 两地之间的距离</td></tr><tr><td>hyperloglogs</td><td>基数统计</td></tr><tr><td>bitmaps</td><td>统计用户访问次数</td></tr></tbody></table><h3 id="第二节-八种数据类型的简介"><a href="#第二节-八种数据类型的简介" class="headerlink" title="第二节 八种数据类型的简介"></a>第二节 八种数据类型的简介</h3><h4 id="1-string-类型"><a href="#1-string-类型" class="headerlink" title="1. string 类型"></a>1. string 类型</h4><p>Redis中最基本的类型，它是key对应的一个单一值。二进制安全，不必担心由于编码等问题导致二进制数据变化。所以redis的string可以包含任何数据，比如jpg图片或者序列化的对象。Redis中一个字符串值的最大容量是512M。</p><h4 id="2-list类型"><a href="#2-list类型" class="headerlink" title="2. list类型"></a>2. list类型</h4><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。它的底层是双向链表，所以它操作时头尾效率高，中间效率低（额外花费查找插入位置的时间）。</p><p>在Redis中list类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是2^32-1个。</p><p>list是一个有序可以重复的数据类型。</p><h4 id="3-set类型"><a href="#3-set类型" class="headerlink" title="3. set类型"></a>3. set类型</h4><p>Redis的set是string类型的无序集合。它是基于哈希表实现的。set类型插入数据时会自动去重。最大可以包含2^32-1个元素。</p><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_017.png"></p><h4 id="4-hash类型"><a href="#4-hash类型" class="headerlink" title="4. hash类型"></a>4. hash类型</h4><p>本身就是一个键值对集合。可以当做Java中的Map&lt;String,String&gt;对待。每一个hash可以存储2^32-1个键值对。 </p><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_018.png"></p><h4 id="5-zset类型"><a href="#5-zset类型" class="headerlink" title="5. zset类型"></a>5. zset类型</h4><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。 </p><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_019.png"></p><h4 id="6-Geospatial"><a href="#6-Geospatial" class="headerlink" title="6. Geospatial"></a>6. Geospatial</h4><p>Redis 在 3.2 推出 Geo 类型，该功能可以推算出地理位置信息，两地之间的距离。 </p><p><img src="http://www.slx.blue/2021/12/19/redis-01/tu_020.png"></p><h4 id="7-HyperLogLogs"><a href="#7-HyperLogLogs" class="headerlink" title="7. HyperLogLogs"></a>7. HyperLogLogs</h4><p>用于大数据量基数统计，速度非常快，占用内存非常小。每个HyperLogLog键只需要花费12KB内存，就可以计算接近 2^64个不同元素的基数。比如计算网站UV（User view，用户访问数量，一个用户一天访问同一个URL地址多次合并为一次）。 </p><h4 id="8-bitmap"><a href="#8-bitmap" class="headerlink" title="8. bitmap"></a>8. bitmap</h4><p>直接对string的二进制位进行操作的一组命令 </p><h2 id="第三章-Redis命令行操作"><a href="#第三章-Redis命令行操作" class="headerlink" title="第三章 Redis命令行操作"></a>第三章 Redis命令行操作</h2><h3 id="第一节-基本操作命令"><a href="#第一节-基本操作命令" class="headerlink" title="第一节 基本操作命令"></a>第一节 基本操作命令</h3><h4 id="1-切换数据库"><a href="#1-切换数据库" class="headerlink" title="1. 切换数据库"></a>1. 切换数据库</h4><p>Redis默认有16个数据库,默认情况下使用的是第一个数据库，我们使用select进行切换，数据库索引从0开始</p><h4 id="2-查看数据库长度"><a href="#2-查看数据库长度" class="headerlink" title="2. 查看数据库长度"></a>2. 查看数据库长度</h4><p>数据库长度就是这个数据库中存储了多少条数据，使用<code>dbsize</code>可以查看数据库长度</p><h4 id="3-清空数据库"><a href="#3-清空数据库" class="headerlink" title="3. 清空数据库"></a>3. 清空数据库</h4><h5 id="3-1-清空当前数据库"><a href="#3-1-清空当前数据库" class="headerlink" title="3.1 清空当前数据库"></a>3.1 清空当前数据库</h5><p><code>flushdb</code></p><h5 id="3-2-清空所有数据库"><a href="#3-2-清空所有数据库" class="headerlink" title="3.2 清空所有数据库"></a>3.2 清空所有数据库</h5><p><code>flushall</code></p><h3 id="第二节-KEY操作"><a href="#第二节-KEY操作" class="headerlink" title="第二节 KEY操作"></a>第二节 KEY操作</h3><h4 id="1-KEY的命名规范"><a href="#1-KEY的命名规范" class="headerlink" title="1. KEY的命名规范"></a>1. KEY的命名规范</h4><p>在实际操作中对于Key的定义大家注意下面几点：</p><ul><li>Key不要太长，超过1024字节将消耗过多内存，降低查询效率。尽管Redis支持的Key最大长度为512MB。</li><li>Key仍然要做到见名知意。</li><li>在同一个项目中遵循同一个命名规范，习惯上多个单词用“:”分开。例如：“user:token:session:id”</li><li>Redis命令不区分大小写，Key区分大小写</li></ul><h4 id="2-KEY操作相关命令-等后续再来演示"><a href="#2-KEY操作相关命令-等后续再来演示" class="headerlink" title="2. KEY操作相关命令(等后续再来演示)"></a>2. KEY操作相关命令(等后续再来演示)</h4><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>KEYS PATTERN</td><td>把匹配PATTERN的key返回。PATTERN中可以使用“*”匹配多个字符，使用“?”匹配单个字符</td></tr><tr><td>TYPE KEY</td><td>返回KEY对应的值的类型</td></tr><tr><td>MOVE KEY DB</td><td>把一组键值对数据移动到另一个数据库中</td></tr><tr><td>DEL KEY [KEY …] 重点</td><td>根据KEY进行删除，至少要指定一个KEY</td></tr><tr><td>EXISTS KEY [KEY …]</td><td>检查指定的KEY是否存在。指定一个KEY时，存在返回1，不存在返回0。可以指定多个，返回存在的KEY的数量。</td></tr><tr><td>RENAME KEY NEWKEY</td><td>重命名一个KEY，NEWKEY不管是否是已经存在的都会执行，如果NEWKEY已经存在则会被覆盖。</td></tr><tr><td>RENAMENX KEY NEWKEY</td><td>只有在NEWKEY不存在时能够执行成功，否则失败</td></tr><tr><td>TTL KEY</td><td>以秒为单位查看KEY还能存在多长时间<br>    正数：剩余的存活时间（单位：秒）<br>    -1：永不过期<br>    -2：不存在的Key</td></tr><tr><td>EXPIRE KEY SECONDS 重点</td><td>给一个KEY设置在SECONDS秒后过期，过期会被Redis移除。</td></tr><tr><td>PERSIST KEY</td><td>移除过期时间，变成永久key</td></tr></tbody></table><h3 id="第三节-string操作"><a href="#第三节-string操作" class="headerlink" title="第三节 string操作"></a>第三节 string操作</h3><table><thead><tr><th>命令</th><th align="left">描述</th></tr></thead><tbody><tr><td>SET key value(重点)</td><td align="left">设置指定 key 的值</td></tr><tr><td>GET key(重点)</td><td align="left">获取指定 key 的值</td></tr><tr><td>APPEND KEY VALUE</td><td align="left">把指定的value追加到KEY对应的原来的值后面，返回值是追加后字符串长度</td></tr><tr><td>GETSET key value</td><td align="left">将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td></tr><tr><td>GETRANGE KEY START END</td><td align="left">从字符串中取指定的一段，索引从0开始     START是开始取值的索引     END是结束取值的索引</td></tr><tr><td>SETRANGE KEY OFFSET VALUE</td><td align="left">跳过offset个字符，然后使用Value替换等长度的内容</td></tr><tr><td>STRLEN KEY</td><td align="left">直接返回字符串长度</td></tr><tr><td>SETEX key seconds value(重点)</td><td align="left">将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td></tr><tr><td>SETNX key value</td><td align="left">只有在 key 不存在时设置 key 的值。</td></tr><tr><td>INCR key(重点)</td><td align="left">将 key 中储存的数字值增一。</td></tr><tr><td>INCRBY key increment</td><td align="left">将 key 所储存的值加上给定的增量值（increment） 。</td></tr><tr><td>DECR key</td><td align="left">将 key 中储存的数字值减一。</td></tr><tr><td>DECRBY key decrement</td><td align="left">key 所储存的值减去给定的减量值（decrement） 。</td></tr><tr><td>MSET KEY VALUE [KEY VALUE …]</td><td align="left">一次性设置一组多个键值对</td></tr><tr><td>MGET KEY [KEY …]</td><td align="left">一次性指定多个KEY，返回它们对应的值，没有值的KEY返回值是(nil</td></tr><tr><td>MSETNX KEY VALUE [KEY VALUE …</td><td align="left">一次性新建多个值</td></tr></tbody></table><h3 id="第四节-list操作"><a href="#第四节-list操作" class="headerlink" title="第四节 list操作"></a>第四节 list操作</h3><table><thead><tr><th>命令</th><th>命令描述</th></tr></thead><tbody><tr><td>LPUSH key value [value …] 重点</td><td>将一个或多个值插入到列表头部(左边)</td></tr><tr><td>LPUSHX key value</td><td>只能针对存在的list执行LPUSH</td></tr><tr><td>RPUSH key value [value …] 重点</td><td>在列表中添加一个或多个值(右边)</td></tr><tr><td>LRANGE key start stop</td><td>根据list集合的索引打印元素数据     正着数：0,1,2,3,…     倒着数：-1,-2,-3,…</td></tr><tr><td>LPOP key 重点</td><td>左边弹出一个 相当于移除第一个</td></tr><tr><td>RPOP key 重点</td><td>右边弹出一个  相当于移除最后一个</td></tr><tr><td>LLEN key</td><td>返回指定key所对应的list中元素个数</td></tr><tr><td>LINDEX key index</td><td>通过索引获取列表中的元素</td></tr><tr><td>LINSERT key BEFORE| AFTER pivot value</td><td>在pivot指定的值前面或后面插入value     如果pivot值有重复的，那么就从左往右数，以第一个遇到的pivot为基准     BEFORE表示放在pivot前面     AFTER表示放在pivot后面</td></tr><tr><td>RPOPLPUSH source destination</td><td>从source中RPOP一个元素，LPUSH到destination中</td></tr><tr><td>LREM key count value</td><td>根据count指定的数量从key对应的list中删除value     具体执行时从左往右删除，遇到一个删一个，删完为止</td></tr><tr><td>LSET key index value</td><td>把指定索引位置的元素替换为另一个值</td></tr><tr><td>LTRIM key start stop</td><td>仅保留指定区间的数据，两边的数据被删除</td></tr></tbody></table><h3 id="第五节-Set操作"><a href="#第五节-Set操作" class="headerlink" title="第五节 Set操作"></a>第五节 Set操作</h3><table><thead><tr><th>命令</th><th>命令描述</th></tr></thead><tbody><tr><td>SADD key member [member …]</td><td>给key指定的set集合中存入数据，set会自动去重</td></tr><tr><td>SREM key member [member …]</td><td>从集合中删除元素</td></tr><tr><td>SMEMBERS key</td><td>返回可以指定的set集合中所有的元素</td></tr><tr><td>SCARD key</td><td>返回集合中元素的数量</td></tr><tr><td>SISMEMBER key member</td><td>检查当前指定member是否是集合中的元素     返回1：表示是集合中的元素     返回0：表示不是集合中的元素</td></tr><tr><td>SPOP key</td><td>移除并返回集合中的一个随机元素</td></tr><tr><td>SDIFF key [key …]</td><td>将指定的集合执行“差集”操作     集合A：a,b,c     集合B：b,c,d     A对B执行diff：a     相当于：A-交集部分</td></tr><tr><td>SDIFFSTORE destination key [key …]</td><td>取差集后存入destination这个集合</td></tr><tr><td>SUNION key [key …]</td><td>将指定的集合执行“并集”操作     集合A：a,b,c     集合B：b,c,d     并集：a,b,c,d</td></tr><tr><td>SUNIONSTORE destination key [key …]</td><td>取并集后存入destination这个集合</td></tr><tr><td>SINTER key [key …]</td><td>将指定的集合进行“交集”操作     集合A：a,b,c     集合B：b,c,d     交集：b,c</td></tr><tr><td>SINTERSTORE destination key [key …]</td><td>取交集后存入destination这个集合</td></tr><tr><td>SMOVE source destination member</td><td>把member从source移动到destination</td></tr></tbody></table><h3 id="第六节-Hash操作"><a href="#第六节-Hash操作" class="headerlink" title="第六节 Hash操作"></a>第六节 Hash操作</h3><table><thead><tr><th align="left">命令</th><th>命令描述</th></tr></thead><tbody><tr><td align="left">HSET key field value</td><td>将哈希表 key 中的字段 field 的值设为 value</td></tr><tr><td align="left">HMSET key field value [field value …]</td><td>同时将多个 field-value (字段-值)对设置到哈希表 key 中</td></tr><tr><td align="left">HGET key field</td><td>获取存储在哈希表中指定字段的值</td></tr><tr><td align="left">HMGET key field [field …]</td><td>获取多个给定字段的值</td></tr><tr><td align="left">HDEL key field [field …]</td><td>删除一个或多个哈希表字段</td></tr><tr><td align="left">HLEN key</td><td>获取哈希表中字段的数量</td></tr><tr><td align="left">HGETALL key</td><td>获取在哈希表中指定 key 的所有字段和值</td></tr><tr><td align="left">HKEYS key</td><td>获取所有哈希表中的字段</td></tr><tr><td align="left">HVALS key</td><td>获取哈希表中所有值</td></tr><tr><td align="left">HEXISTS key field</td><td>判断是否存在某个字段</td></tr></tbody></table><h3 id="第七节-zset操作"><a href="#第七节-zset操作" class="headerlink" title="第七节 zset操作"></a>第七节 zset操作</h3><table><thead><tr><th>命令</th><th>命令描述</th></tr></thead><tbody><tr><td>ZADD key score member [score member …]</td><td>增加元素</td></tr><tr><td>ZSCORE key member</td><td>获取元素的分数</td></tr><tr><td>ZREM key member [member …]</td><td>删除元素</td></tr><tr><td>ZCARD key</td><td>获得集合中元素的数量</td></tr><tr><td>ZRANGE key start stop[WITHSCORES]</td><td>获得排名在某个范围的元素列表</td></tr><tr><td>ZREVRANGE key start stop</td><td>按照分数从高到低排序</td></tr><tr><td>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</td><td>在分数的指定区间内返回数据     min参数可以通过 -inf 表示负无穷     max参数可以通过 +inf 表示正无穷</td></tr><tr><td>ZRANK key member</td><td>先对分数进行升序排序，返回member的排名。排名从0开始</td></tr></tbody></table><h3 id="第八节-Geospatial-了解"><a href="#第八节-Geospatial-了解" class="headerlink" title="第八节 Geospatial(了解)"></a>第八节 Geospatial(了解)</h3><p>查询经纬度数据的网址：<a href="http://www.jsons.cn/lngcode">http://www.jsons.cn/lngcode</a> </p><h4 id="1-添加地理位置"><a href="#1-添加地理位置" class="headerlink" title="1. 添加地理位置"></a>1. 添加地理位置</h4><pre><code>GEOADD key longitude latitude member [longitude latitude member ...]</code></pre><p>规则：</p><p>1.取值范围</p><p> 有效的经度从 -180 度到 180 度。</p><p> 有效的纬度从 -85.05112878 度到 85.05112878 度。</p><p> 当坐标位置超出指定范围时，该命令将会返回一个错误。</p><p>2.已经添加的数据，是无法再次往里面添加的。</p><p>例子:</p><pre><code>GEOADD china:city 114.085947 22.547 shenzhen GEOADD china:city 113.280637 23.125178 guangzhou</code></pre><h4 id="2-查询已添加的地理位置"><a href="#2-查询已添加的地理位置" class="headerlink" title="2. 查询已添加的地理位置"></a>2. 查询已添加的地理位置</h4><p>Geo类型在Redis内部其实是使用zset类型存储的，所以可以使用zset的命令进行常规操作 </p><pre><code>ZRANGE china:city 0 -1 ZRANGE china:city 0 -1 WITHSCORES</code></pre><h4 id="3-删除已添加的地理位置"><a href="#3-删除已添加的地理位置" class="headerlink" title="3. 删除已添加的地理位置"></a>3. 删除已添加的地理位置</h4><pre><code>ZREM china:city guangzhou</code></pre><h4 id="4-获取指定地区的坐标值"><a href="#4-获取指定地区的坐标值" class="headerlink" title="4. 获取指定地区的坐标值"></a>4. 获取指定地区的坐标值</h4><pre><code>GEOPOS china:city shenzhen</code></pre><h5 id="5-计算两地之间的直线距离"><a href="#5-计算两地之间的直线距离" class="headerlink" title="5. 计算两地之间的直线距离"></a>5. 计算两地之间的直线距离</h5><pre><code>GEODIST china:city guangzhou shenzhen km</code></pre><p>单位：</p><p>m 表示单位为米[默认值]。</p><p>km 表示单位为千米。</p><p>mi 表示单位为英里。</p><p>ft 表示单位为英尺。</p><p>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位。</p><h4 id="6-以给定坐标为中心，在指定半径内查找元素"><a href="#6-以给定坐标为中心，在指定半径内查找元素" class="headerlink" title="6. 以给定坐标为中心，在指定半径内查找元素"></a>6. 以给定坐标为中心，在指定半径内查找元素</h4><pre><code>GEORADIUS china:city 110 20 1000 km WITHCOORD WITHDIST</code></pre><p>WITHCOORD表示显示经纬度</p><p>WITHDIST表示显示到中心的距离</p><h4 id="7-在指定元素周围查找其他元素"><a href="#7-在指定元素周围查找其他元素" class="headerlink" title="7. 在指定元素周围查找其他元素"></a>7. 在指定元素周围查找其他元素</h4><pre><code>GEORADIUSBYMEMBER china:city shenzhen 300 km WITHCOORD WITHDIST</code></pre><h3 id="第九节-HyperLogLogs-了解"><a href="#第九节-HyperLogLogs-了解" class="headerlink" title="第九节 HyperLogLogs(了解)"></a>第九节 HyperLogLogs(了解)</h3><h4 id="1-基数概念"><a href="#1-基数概念" class="headerlink" title="1. 基数概念"></a>1. 基数概念</h4><p>一个集合中不重复元素的个数。例如：集合{1,2,5,1,7,2,5}中元素个数是7，但是基数是4。而hyperloglogs的主要功能就是进行基数统计。 </p><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h4><h5 id="2-1-添加"><a href="#2-1-添加" class="headerlink" title="2.1 添加"></a>2.1 添加</h5><pre><code>PFADD user:access:1 tom jerry andy jim andy jerry tomPFADD user:access:2 andy jerry tom bob katePFADD user:access:3 mary harry tom jerry</code></pre><h5 id="2-2-统计"><a href="#2-2-统计" class="headerlink" title="2.2 统计"></a>2.2 统计</h5><pre><code>PFCOUNT user:access:1 user:access:2 user:access:3</code></pre><h5 id="2-3-合并"><a href="#2-3-合并" class="headerlink" title="2.3 合并"></a>2.3 合并</h5><pre><code>PFMERGE user:access:merge user:access:1 user:access:2 user:access:3</code></pre><h3 id="第十节-bitmap位图-了解"><a href="#第十节-bitmap位图-了解" class="headerlink" title="第十节 bitmap位图(了解)"></a>第十节 bitmap位图(了解)</h3><p>直接对数据的二进制位进行操作 ：</p><p>setbit设置指定比特位<br>getbit获取指定比特位<br>bitcount统计所有比特位中1的数量</p><pre><code class="text">set a helloGETBIT a 0GETBIT a 1GETBIT a 2GETBIT a 3GETBIT a 4GETBIT a 5SETBIT a 5 1get aBITCOUNT a</code></pre><h2 id="第四章-总结"><a href="#第四章-总结" class="headerlink" title="第四章 总结"></a>第四章 总结</h2><ol><li>为什么需要NoSQL<ol><li>主要目的：解决互联网项目的性能问题</li><li>具体解决哪些性能问题: 高并发、海量数据、高可用</li></ol></li><li>Redis有几种数据类型<ol><li>string</li><li>list</li><li>set</li><li>hash</li><li>zset</li><li>地理位置</li><li>基数</li><li>bitmap</li></ol></li><li>redis存储数据的整体结构: 键值对</li><li>安装redis:<ol><li>安装完之后:修改配置文件</li><li>远程访问: 修改配置文件的bind</li><li>启动redis的时候: 一定要附加配置文件参数   <code>./redis-server 配置文件路径</code></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-进阶</title>
      <link href="/2021/12/16/Linux-02/"/>
      <url>/2021/12/16/Linux-02/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-day02"><a href="#Linux-day02" class="headerlink" title="Linux-day02"></a>Linux-day02</h1><h2 id="第一章-Linux常用命令"><a href="#第一章-Linux常用命令" class="headerlink" title="第一章 Linux常用命令"></a>第一章 Linux常用命令</h2><h3 id="第一节-进程相关命令"><a href="#第一节-进程相关命令" class="headerlink" title="第一节 进程相关命令"></a>第一节 进程相关命令</h3><h4 id="1-查看进程状态"><a href="#1-查看进程状态" class="headerlink" title="1. 查看进程状态"></a>1. 查看进程状态</h4><h5 id="1-1-命令的使用"><a href="#1-1-命令的使用" class="headerlink" title="1.1 命令的使用"></a>1.1 命令的使用</h5><p><code>ps</code>命令是用于查看进程状态的命令，它常和<code>e</code>参数(对应单词entire，表示全部。具体指显示系统中全部的进程信息。)，以及<code>f</code>参数(对应单词full-formate，表示完整格式。) 一起使用</p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_001.png"></p><p>进程信息中各列数据的说明:</p><table><thead><tr><th>列名</th><th>含义</th></tr></thead><tbody><tr><td>UID</td><td>进程的用户信息</td></tr><tr><td><strong>PID</strong></td><td>进程id。由系统分配，不会重复。</td></tr><tr><td><strong>PPID</strong></td><td>父进程的id。父进程和子进程的关系是：父进程启动了子进程。</td></tr><tr><td><strong>CMD</strong></td><td>当前进程所对应的程序。</td></tr><tr><td>C</td><td>用整数表示的CPU使用率</td></tr><tr><td>STIME</td><td>进程启动时间</td></tr><tr><td>TTY</td><td>进程所在终端。所谓终端就是用户输入命令的操作界面。</td></tr><tr><td>TIME</td><td>进程所占用的CPU时间</td></tr></tbody></table><h5 id="1-2-父进程和子进程之间的关系"><a href="#1-2-父进程和子进程之间的关系" class="headerlink" title="1.2 父进程和子进程之间的关系"></a>1.2 父进程和子进程之间的关系</h5><p>简单来说，父进程和子进程的关系是：父进程启动了子进程。我们可以使用pstree命令查看整个进程树。 </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_002.png"></p><h5 id="1-3-和其它命令配合一起查看进程"><a href="#1-3-和其它命令配合一起查看进程" class="headerlink" title="1.3 和其它命令配合一起查看进程"></a>1.3 和其它命令配合一起查看进程</h5><h6 id="1-3-1-分屏查看进程信息"><a href="#1-3-1-分屏查看进程信息" class="headerlink" title="1.3.1 分屏查看进程信息"></a>1.3.1 分屏查看进程信息</h6><p>全部进程的信息太多了，一屏无法全部显示，所以我们希望可以分屏显示并由我们来控制翻页。为了达到这个目标，我们可以使用管道符号将ps -ef命令的输出数据传送给less命令。 <code>ps -ef | less</code></p><h6 id="1-3-2-精确查询一个具体进程信息"><a href="#1-3-2-精确查询一个具体进程信息" class="headerlink" title="1.3.2 精确查询一个具体进程信息"></a>1.3.2 精确查询一个具体进程信息</h6><p>我们通过Xshell远程连接Linux系统，靠的是sshd这个服务。这个服务如果正在运行中，那么一定会有这个服务对应的进程。所以下面我们来查询一下sshd这个命令的进程。 </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_003.png"></p><p>我们看到这里返回了3条结果，其中前两天都是和sshd服务相关的结果，但是最后一条不是。</p><blockquote><p>root 72826 3456 0 20:06 pts/0 00:00:00 grep –color=auto sshd</p></blockquote><p>仔细观察一下就能发现，这其实是grep命令本身。因为grep命令运行过程中本身也是一个进程，“grep sshd”正好也匹配sshd，所以就被选中了。但是这是一个干扰项，并不是我们真正要查询的内容，所以需要把它从查询结果中排除。</p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_004.png"></p><p>再用一层管道，使用grep命令的-v参数把匹配grep的行排除，返回不匹配的结果，这就是我们最终想要的。 </p><h4 id="2-杀死进程"><a href="#2-杀死进程" class="headerlink" title="2. 杀死进程"></a>2. 杀死进程</h4><h5 id="2-1-命令的使用"><a href="#2-1-命令的使用" class="headerlink" title="2.1 命令的使用"></a>2.1 命令的使用</h5><p><code>kill -9 进程id</code>表示杀死指定id的进程</p><h5 id="2-2-举例"><a href="#2-2-举例" class="headerlink" title="2.2 举例"></a>2.2 举例</h5><ol><li><p>打开Linux内置的火狐浏览器</p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_005.png"></p></li><li><p>查看火狐浏览器的进程id</p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_006.png"></p><p> 另外一个是浏览器插件，不用管。 </p></li><li><p>使用kill命令结束火狐浏览器进程: <code>kill -9 3325</code></p></li></ol><h4 id="3-实时查看系统运行情况和健康状态-了解"><a href="#3-实时查看系统运行情况和健康状态-了解" class="headerlink" title="3.  实时查看系统运行情况和健康状态(了解)"></a>3.  实时查看系统运行情况和健康状态(了解)</h4><h5 id="3-1-命令和参数"><a href="#3-1-命令和参数" class="headerlink" title="3.1 命令和参数"></a>3.1 命令和参数</h5><table><thead><tr><th>命令名</th><th>更新时间间隔（秒）</th><th>不显示任何闲置或者僵死进程</th><th>通过进程id监控单一进程</th></tr></thead><tbody><tr><td>top</td><td>-d 间隔秒数</td><td>-i</td><td>-p 进程id</td></tr></tbody></table><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_007.png"></p><h5 id="3-2-按键操作"><a href="#3-2-按键操作" class="headerlink" title="3.2 按键操作"></a>3.2 按键操作</h5><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>P</td><td>默认值，根据CPU使用率排序</td></tr><tr><td>M</td><td>以内存的使用率排序</td></tr><tr><td>N</td><td>以PID排序</td></tr><tr><td>d</td><td>设置数据刷新的时间间隔，单位是秒</td></tr><tr><td>q</td><td>退出</td></tr></tbody></table><h5 id="3-3-查询结果的字段解释"><a href="#3-3-查询结果的字段解释" class="headerlink" title="3.3 查询结果的字段解释"></a>3.3 查询结果的字段解释</h5><h6 id="3-3-1-第一行信息为任务队列信息"><a href="#3-3-1-第一行信息为任务队列信息" class="headerlink" title="3.3.1 第一行信息为任务队列信息"></a>3.3.1 第一行信息为任务队列信息</h6><table><thead><tr><th>内容举例</th><th>说明</th></tr></thead><tbody><tr><td>12:26:49</td><td>系统当前时间</td></tr><tr><td>up 1 day, 13:32</td><td>系统的运行时间，前面例子表示本机已经运行1天13小时32分钟</td></tr><tr><td>2 users</td><td>当前登录了2个用户</td></tr><tr><td>load average:0.00, 0.00, 0.00</td><td>系统在之前1分钟，5分钟，15分钟的平均负载。 一般认为小于1时，负载较小。如果大于1，系统已经超出负荷。</td></tr></tbody></table><h6 id="3-3-2-第二行为进程信息"><a href="#3-3-2-第二行为进程信息" class="headerlink" title="3.3.2 第二行为进程信息"></a>3.3.2 第二行为进程信息</h6><table><thead><tr><th>内容举例</th><th>说明</th></tr></thead><tbody><tr><td>Tasks: 95 total</td><td>系统中的进程总数</td></tr><tr><td>1 running</td><td>正在运行的进程数</td></tr><tr><td>94 sleeping</td><td>睡眠的进程</td></tr><tr><td>0 stopped</td><td>正在停止的进程</td></tr><tr><td>0 zombie</td><td>僵尸进程。如果不是0，需要手工检查僵尸进程</td></tr></tbody></table><h6 id="3-3-3-第三行为CPU信息"><a href="#3-3-3-第三行为CPU信息" class="headerlink" title="3.3.3 第三行为CPU信息"></a>3.3.3 第三行为CPU信息</h6><table><thead><tr><th>内容举例</th><th>说明</th></tr></thead><tbody><tr><td>Cpu(s):0.1%us</td><td>用户空间占用的CPU百分比，us对应user</td></tr><tr><td>0.1%sy</td><td>内核空间占用的CPU百分比，sy对应system</td></tr><tr><td>0.0%ni</td><td>改变过优先级的进程占用的CPU百分比，ni对应niced</td></tr><tr><td>99.7%id</td><td>空闲CPU的CPU百分比</td></tr><tr><td>0.1%wa</td><td>等待输入/输出的进程的占用CPU百分比，wa对应IO wait</td></tr><tr><td>0.0%hi</td><td>硬中断请求服务占用的CPU百分比，hi对应hardware IRQ</td></tr><tr><td>0.1%si</td><td>软中断请求服务占用的CPU百分比，si对应software IRQ</td></tr><tr><td>0.0%st</td><td>st（Steal time）虚拟时间百分比，也叫被hypervisor偷走的时间。 就是当有虚拟机时，虚拟CPU等待实际CPU的时间百分比。</td></tr></tbody></table><h6 id="3-3-4-第四行为物理内存信息"><a href="#3-3-4-第四行为物理内存信息" class="headerlink" title="3.3.4 第四行为物理内存信息"></a>3.3.4 第四行为物理内存信息</h6><table><thead><tr><th>内容举例</th><th>说明</th></tr></thead><tbody><tr><td>2031912 total</td><td>物理内存的总量，单位KB</td></tr><tr><td>70496 free</td><td>空闲的物理内存数量</td></tr><tr><td>1780676 used</td><td>已经使用的物理内存数量</td></tr><tr><td>174864 buff/cache</td><td>作为缓冲的内存数量</td></tr></tbody></table><p>使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是还未纳入内核管控范围的数量。</p><p>纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存还给free，因此Linux系统运行过程中free内存会越来越少，但不影响系统运行。因为这表示更多的空闲内存被内核管理了。</p><h6 id="3-3-5-第五行为交换分区（swap）信息"><a href="#3-3-5-第五行为交换分区（swap）信息" class="headerlink" title="3.3.5 第五行为交换分区（swap）信息"></a>3.3.5 第五行为交换分区（swap）信息</h6><table><thead><tr><th>内容举例</th><th>说明</th></tr></thead><tbody><tr><td>2097148 total</td><td>交换分区（虚拟内存）的总大小</td></tr><tr><td>1137824 free</td><td>空闲交换分区的大小</td></tr><tr><td>959324 used</td><td>已经使用的交互分区的大小</td></tr><tr><td>58640 avail Mem</td><td>在不交换的情况下，对启动新应用程序可用内存的估计</td></tr></tbody></table><p>交换分区是一个非常值得关注的地方，如果swap区的used数值持续发生变化那么说明在内核和交换分区之间正在持续发生数据交换，这表示内存不够用了——必须不断把内存中的数据保存到硬盘上。</p><h4 id="4-查看网络状态命令-了解"><a href="#4-查看网络状态命令-了解" class="headerlink" title="4. 查看网络状态命令(了解)"></a>4. 查看网络状态命令(了解)</h4><h5 id="4-1-命令和参数"><a href="#4-1-命令和参数" class="headerlink" title="4.1 命令和参数"></a>4.1 命令和参数</h5><p><code>netstat</code>命令是查看网络状态,常用参数列表如下:</p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>显示所有正在或不在侦听的套接字。</td></tr><tr><td>-n</td><td>显示数字形式地址而不是去解析主机、端口或用户名。</td></tr><tr><td>-p</td><td>显示套接字所属进程的PID和名称。</td></tr></tbody></table><p>常用: <code>netstat -anp</code></p><h5 id="4-2-查询结果的解释"><a href="#4-2-查询结果的解释" class="headerlink" title="4.2 查询结果的解释"></a>4.2 查询结果的解释</h5><p>netstat命令显示的网络状态信息包含两部分内容：</p><ul><li><p>本机和外部的连接状态信息(重点)</p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_009.png"></p></li></ul><ul><li><p>本机系统内部进程间通信信息(了解)</p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_010.png"></p></li></ul><h5 id="4-3-使用技巧"><a href="#4-3-使用技巧" class="headerlink" title="4.3 使用技巧"></a>4.3 使用技巧</h5><h5 id="4-3-1-分屏查看网络状态"><a href="#4-3-1-分屏查看网络状态" class="headerlink" title="4.3.1 分屏查看网络状态"></a>4.3.1 分屏查看网络状态</h5><p><code>netstat -anp | less</code></p><h5 id="4-3-2-根据进程名称查看网络状态"><a href="#4-3-2-根据进程名称查看网络状态" class="headerlink" title="4.3.2 根据进程名称查看网络状态"></a>4.3.2 根据进程名称查看网络状态</h5><p><code>netstat -anp | grep sshd</code></p><h5 id="4-3-3-根据端口号查看网络状态"><a href="#4-3-3-根据端口号查看网络状态" class="headerlink" title="4.3.3 根据端口号查看网络状态"></a>4.3.3 根据端口号查看网络状态</h5><p><code>netstat -anp | grep :22</code></p><p>这里需要注意一下，端口号本身就是一串数字，进程id也是一串数字。那么根据端口号匹配时，很多无关的进程id也会被匹配到，造成大量不必要的干扰。此时给端口号数字前加上冒号就好多了。 </p><h3 id="第二节-字符串处理的命令-了解"><a href="#第二节-字符串处理的命令-了解" class="headerlink" title="第二节 字符串处理的命令(了解)"></a>第二节 字符串处理的命令(了解)</h3><h4 id="1-basename"><a href="#1-basename" class="headerlink" title="1. basename"></a>1. basename</h4><p>返回路径字符串中的资源（文件或目录本身）部分 </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_011.png"></p><p>如果指定了后缀，basename会帮我们把后缀部分也去掉 </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_012.png"></p><h4 id="2-dirname"><a href="#2-dirname" class="headerlink" title="2. dirname"></a>2. dirname</h4><p>返回路径字符串中的目录部分 </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_013.png"></p><p>注意: 这里dd是文件</p><h4 id="3-cut"><a href="#3-cut" class="headerlink" title="3. cut"></a>3. cut</h4><p>根据指定符号拆分字符串并提取。默认根据 \t 拆分。</p><ul><li>-f 参数：指定要提取的列</li><li>-d 参数：指定拆分依据的字符</li></ul><p>准备测试数据： </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_014.png"></p><p>切割提取第一列： </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_015.png"></p><p>切割提取第二、第三列： </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_016.png"></p><p>选取系统 PATH 变量值，第2个 “:” 开始后的所有路径： </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_017.png"></p><p>切割ifconfig 后打印的IP地址： </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_018.png"></p><p>另一种做法： </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_019.png"></p><h4 id="4-sort"><a href="#4-sort" class="headerlink" title="4. sort"></a>4. sort</h4><p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。</p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>-n</td><td>依照数值大小排序</td></tr><tr><td>-r</td><td>相反顺序排序</td></tr><tr><td>-t</td><td>设置排序时使用的分隔字符</td></tr><tr><td>-k</td><td>指定需要排序的列</td></tr></tbody></table><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_020.png"></p><h2 id="第二章-Linux权限管理"><a href="#第二章-Linux权限管理" class="headerlink" title="第二章 Linux权限管理"></a>第二章 Linux权限管理</h2><h3 id="第一节-权限管理中的专业术语"><a href="#第一节-权限管理中的专业术语" class="headerlink" title="第一节 权限管理中的专业术语"></a>第一节 权限管理中的专业术语</h3><h4 id="1-用户"><a href="#1-用户" class="headerlink" title="1. 用户"></a>1. 用户</h4><p>系统使用者登录系统时使用的账号、密码。系统通过“用户”来识别使用者的身份。使用者以“用户”的名义操作系统资源。 </p><h4 id="2-登录"><a href="#2-登录" class="headerlink" title="2. 登录"></a>2. 登录</h4><p>使用者想要让系统认可自己的身份就必须提供账号、密码等信息。更专业的说法是：“认证（authentication）”。 </p><h4 id="3-资源"><a href="#3-资源" class="headerlink" title="3. 资源"></a>3. 资源</h4><p>权限控制系统要保护的对象。权限控制系统中必须要保存每一个资源所要求的访问权限。哪怕是“不需要任何权限，任何人都可以使用”也是权限信息的一种描述——没有要求也是一种要求。 </p><h4 id="4-授权"><a href="#4-授权" class="headerlink" title="4. 授权"></a>4. 授权</h4><p>authorization，系统给用户分配权限。这些权限代表了用户可以做什么。 </p><h4 id="5-校验"><a href="#5-校验" class="headerlink" title="5. 校验"></a>5. 校验</h4><p>一个用户访问一个资源的时候，权限控制系统必须要检查这个用户持有的权限是否满足目标资源所要求的权限。 </p><h4 id="6-用户组"><a href="#6-用户组" class="headerlink" title="6. 用户组"></a>6. 用户组</h4><p>同一类的用户归到同一个组，也可以叫做角色。 </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_021.png"></p><h3 id="第二节-创建用户和用户组的基本命令"><a href="#第二节-创建用户和用户组的基本命令" class="headerlink" title="第二节 创建用户和用户组的基本命令"></a>第二节 创建用户和用户组的基本命令</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>groupadd 组名</td><td>创建用户组</td></tr><tr><td>id 用户名</td><td>返回用户信息，检查用户是否存在</td></tr><tr><td>useradd -g 组名 用户名</td><td>创建用户，同时指定所属用户组</td></tr><tr><td>passwd 用户名</td><td>给用户账号设置密码</td></tr></tbody></table><h3 id="第三节-文件权限"><a href="#第三节-文件权限" class="headerlink" title="第三节 文件权限"></a>第三节 文件权限</h3><h4 id="1-文件权限信息说明"><a href="#1-文件权限信息说明" class="headerlink" title="1. 文件权限信息说明"></a>1. 文件权限信息说明</h4><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_022.png"></p><p>权限信息共分三组，每组三位： </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_023.png"></p><p>下面介绍rwx-分别是什么意思：</p><ul><li><p>r：读（read）</p><ul><li><p>读文件：查看文件内容</p><p>例如：cat、less、tail等命令</p></li><li><p>读目录：查看目录内容</p><p>例如：使用ll命令查看目录内容</p></li></ul></li><li><p>w：写（write）</p><ul><li><p>写文件：向文件中写入新内容</p></li><li><p>写目录：在目录里面增删内容</p><p>例如：在目录内新建文件、删除文件、新建目录、删除目录给目录重命名</p></li></ul></li><li><p>x：执行（execute）</p><ul><li>执行文件：把文件当作可执行文件来运行</li><li>执行目录：使用cd命令进入目录</li></ul></li><li><p>-：无权限</p></li></ul><p>由于每一位要么有权限要么没有权限，所以天然可以使用二进制来表示权限信息：</p><ul><li>1：有</li><li>0：无</li></ul><table><thead><tr><th>权限的符号表示</th><th>权限的二进制表示</th><th>权限的十进制表示</th></tr></thead><tbody><tr><td>rwx r-x r-x</td><td>111 101 101</td><td>7 5 5</td></tr><tr><td>rw- r– r–</td><td>110 100 100</td><td>6 4 4</td></tr></tbody></table><h4 id="2-修改文件权限"><a href="#2-修改文件权限" class="headerlink" title="2. 修改文件权限"></a>2. 修改文件权限</h4><h5 id="2-1-命令介绍"><a href="#2-1-命令介绍" class="headerlink" title="2.1 命令介绍"></a>2.1 命令介绍</h5><table><thead><tr><th>命令名</th><th>作用</th></tr></thead><tbody><tr><td>chmod</td><td>修改权限信息</td></tr><tr><td>chown</td><td>修改文件或目录的所属用户</td></tr><tr><td>chgrp</td><td>修改文件或目录的所属用户组</td></tr></tbody></table><h5 id="2-2-演示chmod命令"><a href="#2-2-演示chmod命令" class="headerlink" title="2.2 演示chmod命令"></a>2.2 演示chmod命令</h5><h6 id="2-2-1-修改权限信息前"><a href="#2-2-1-修改权限信息前" class="headerlink" title="2.2.1 修改权限信息前"></a>2.2.1 修改权限信息前</h6><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_024.png"></p><h6 id="2-2-2-添加权限"><a href="#2-2-2-添加权限" class="headerlink" title="2.2.2 添加权限"></a>2.2.2 添加权限</h6><p>增加执行权限 </p><pre><code>chmod +x fruit/content</code></pre><p>添加权限信息后</p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_025.png"></p><h6 id="2-2-3-删除权限"><a href="#2-2-3-删除权限" class="headerlink" title="2.2.3 删除权限"></a>2.2.3 删除权限</h6><p>删除执行权限 </p><pre><code>chmod -x fruit/content</code></pre><p>删除权限信息后</p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_026.png"></p><h6 id="2-2-4-修改权限"><a href="#2-2-4-修改权限" class="headerlink" title="2.2.4 修改权限"></a>2.2.4 修改权限</h6><p>方法1: <code>chmod 三位数字</code></p><p>这三位数字分别表示: 拥有者的权限、同组用户的权限、其它用户的权限</p><p><code>r</code>：是4； <code>w</code>：是2；<code>x</code>：是1</p><p>例如<code>chmod 755 fruit/content </code>表示将权限设置为:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_027.png"></p><p>方法2: <code>chmod u=rwx,g=rx,o=rx</code>，其中u表示拥有者，g表示同组用户，o表示其它用户</p><h3 id="第四节-提升普通用户的权限"><a href="#第四节-提升普通用户的权限" class="headerlink" title="第四节 提升普通用户的权限"></a>第四节 提升普通用户的权限</h3><p>在公司参与开发的过程中，通常我们不会拿到服务器系统的 root 权限，而是普通用户权限。但是普通用户很多操作无法执行。比如在 /opt 目录下新建目录: </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_028.png"></p><p>提升普通用户的权限其实就是赋予普通用户那些超级管理员才有的权限，我们需要在 /etc/sudoers文件中 进行配置,但是注意sudoers文件默认是只读的，我们要修改它的权限，修改成root可以编辑<code>chmod 644 /etc/sudoers</code></p><pre><code>## Allow root to run any commands anywhere root    ALL=(ALL)       ALLluozhixiang ALL=(ALL)   ALL</code></pre><p>不需要重启系统，我们再次测试:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_029.png"></p><p>但此时我们发现，每次使用<code>sudo</code>都需要输入密码，很麻烦，所以我们可以在<code>/etc/sudoers</code>中进行配置</p><pre><code>luozhixiang ALL=(ALL)   NOPASSWD:ALL</code></pre><p>这样再使用sudo命令就不需要输入密码了 </p><p>这里有两点需要注意：</p><ul><li>在同一次登录中，即使不加NOPASSWD也只需要输入一次密码，所以NOPASSWD是否生效需要退出登录后再重新登录来测试。</li><li>使用sudo提权后创建的目录仍然是root root权限，如果有需要那就还要使用chown或chgrp来修改。</li></ul><h2 id="第三章-Linux系统的服务管理"><a href="#第三章-Linux系统的服务管理" class="headerlink" title="第三章 Linux系统的服务管理"></a>第三章 Linux系统的服务管理</h2><h3 id="第一节-服务的概念"><a href="#第一节-服务的概念" class="headerlink" title="第一节 服务的概念"></a>第一节 服务的概念</h3><p>操作系统中在后台持续运行的程序，本身并没有操作界面，需要通过端口号访问和操作。CentOS 6和CentOS 7的服务管理有很大区别，我们分别来看。</p><h3 id="第二节-CentOS6的服务-了解"><a href="#第二节-CentOS6的服务-了解" class="headerlink" title="第二节 CentOS6的服务(了解)"></a>第二节 CentOS6的服务(了解)</h3><h4 id="1-service命令"><a href="#1-service命令" class="headerlink" title="1. service命令"></a>1. service命令</h4><p>启动服务：service 服务名 start</p><p>停止服务：service 服务名 stop</p><p>重启服务：service 服务名 restart</p><p>重新加载服务：service 服务名 reload</p><p>查看服务状态：service 服务名 status</p><h4 id="2-chkconfig命令"><a href="#2-chkconfig命令" class="headerlink" title="2. chkconfig命令"></a>2. chkconfig命令</h4><p>查看服务列表：chkconfig [–list]</p><p>设置具体服务开机自动启动状态：chkconfig 服务名 on/off</p><h4 id="3-防火墙"><a href="#3-防火墙" class="headerlink" title="3. 防火墙"></a>3. 防火墙</h4><p>防火墙默认会阻止绝大部分端口号的访问，在实际生产环境下，运维工程师需要为服务器设置详细的访问规则。在练习过程中，我们为了方便建议把防火墙直接关闭。由于防火墙服务默认开机自动启动，所以除了<strong>停止服务</strong>，还要设置为<strong>开机不自动启动</strong>。</p><p>服务名：iptables</p><p>停止防火墙：service iptables stop</p><p>设置开机不自动启动：chkconfig iptables off</p><h3 id="第三节-CentOS7的服务"><a href="#第三节-CentOS7的服务" class="headerlink" title="第三节 CentOS7的服务"></a>第三节 CentOS7的服务</h3><h4 id="1-systemctl命令"><a href="#1-systemctl命令" class="headerlink" title="1. systemctl命令"></a>1. systemctl命令</h4><p>启动服务：systemctl start 服务名(xxxx.service)</p><p>重启服务：systemctl restart 服务名(xxxx.service)</p><p>停止服务：systemctl stop 服务名(xxxx.service)</p><p>重新加载服务：systemctl reload 服务名(xxxx.service)</p><p>查看服务状态：systemctl status 服务名(xxxx.service)</p><h3 id="2-systemctl命令代替chkconfig命令"><a href="#2-systemctl命令代替chkconfig命令" class="headerlink" title="2. systemctl命令代替chkconfig命令"></a>2. systemctl命令代替chkconfig命令</h3><p>查看服务状态：systemctl list-unit-files</p><p>设置或取消服务开机自动启动：</p><ul><li><p>设置开机自动启动：systemctl enable 服务名</p></li><li><p>取消开机自动启动：systemctl disable 服务名</p></li></ul><h4 id="3-防火墙的操作"><a href="#3-防火墙的操作" class="headerlink" title="3. 防火墙的操作"></a>3. 防火墙的操作</h4><ul><li>开启防火墙 <code>systemctl start firewalld</code></li><li>重启防火墙 <code>systemctl restart firewalld</code></li><li>关闭防火墙<code>systemctl stop firewalld</code></li><li>设置开机启动<code>systemctl enable firewalld</code></li><li>停止并关闭开机启动<code>systemctl disable firewalld</code></li><li>查看防火墙状态<code>systemctl status firewalld</code> 或者 <code>firewall-cmd --state</code></li><li>查看防火墙开机时是否启动<code>systemctl list-unit-files | grep firewalld</code></li></ul><h4 id="4-防火墙端口设置"><a href="#4-防火墙端口设置" class="headerlink" title="4. 防火墙端口设置"></a>4. 防火墙端口设置</h4><ul><li><p>开放端口   <code>firewall-cmd --add-port=端口号/tcp --permanent</code></p></li><li><p>更新防火墙规则<code>firewall-cmd --reload</code></p></li><li><p>查看</p><p><code>firewall-cmd --zone=public --query-port=端口号/tcp</code><br><code>firewall-cmd --zone=public --list-ports</code></p></li><li><p>取消端口开放  <code>firewall-cmd --remove-port=端口/tcp --permanent</code></p></li><li><p>常用端口</p><ul><li>8080 tomcat</li><li>80 http协议</li><li>443 https协议</li><li>22 ssh远程连接</li><li>3306 mysql</li><li>6379 redis</li></ul></li></ul><h2 id="第四章-Linux下的Shell脚本开发"><a href="#第四章-Linux下的Shell脚本开发" class="headerlink" title="第四章 Linux下的Shell脚本开发"></a>第四章 Linux下的Shell脚本开发</h2><h3 id="第一节-Shell编程概述"><a href="#第一节-Shell编程概述" class="headerlink" title="第一节 Shell编程概述"></a>第一节 Shell编程概述</h3><p>Shell是一个命令行解释器，它接收应用程序或用户的命令，然后调用操作系统内核。 它是一个功能强大的编程语言，易编写、易调试、灵活性强 </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_030.png"></p><h3 id="第二节-Linux系统提供的Shell解析器"><a href="#第二节-Linux系统提供的Shell解析器" class="headerlink" title="第二节 Linux系统提供的Shell解析器"></a>第二节 Linux系统提供的Shell解析器</h3><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_031.png"></p><p>其中最常用的是 /bin/sh 和 /bin/bash</p><h4 id="1-bash-和-sh-的关系"><a href="#1-bash-和-sh-的关系" class="headerlink" title="1. bash 和 sh 的关系"></a>1. bash 和 sh 的关系</h4><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_032.png"></p><p>sh是bash的软链接 ,Linux默认使用的是bash</p><h3 id="第三节-Shell编程入门"><a href="#第三节-Shell编程入门" class="headerlink" title="第三节 Shell编程入门"></a>第三节 Shell编程入门</h3><h4 id="1-创建脚本文件"><a href="#1-创建脚本文件" class="headerlink" title="1. 创建脚本文件"></a>1. 创建脚本文件</h4><p>使用<code>touch</code>命令创建脚本文件, 通常以.sh作为扩展名 </p><h4 id="2-编写脚本内容"><a href="#2-编写脚本内容" class="headerlink" title="2. 编写脚本内容"></a>2. 编写脚本内容</h4><p>第一行通常指定脚本解析器</p><pre><code class="shell">#!/bin/bashecho &quot;hello world&quot;</code></pre><h4 id="3-脚本文件的运行方式"><a href="#3-脚本文件的运行方式" class="headerlink" title="3. 脚本文件的运行方式"></a>3. 脚本文件的运行方式</h4><table><thead><tr><th>命令名</th><th>在当前进程运行</th><th>新建子进程运行</th></tr></thead><tbody><tr><td>source</td><td>√</td><td></td></tr><tr><td>.</td><td>√</td><td></td></tr><tr><td>sh</td><td></td><td>√</td></tr><tr><td>bash</td><td></td><td>√</td></tr><tr><td>chmod +x后直接运行</td><td></td><td>√</td></tr></tbody></table><p>其中“.”是source的另一种写法。在当前进程中发布的全局变量可以在当前进程的其他脚本中继续沿用，也可以在子进程中使用；但是子进程export发布的变量仅限于子进程内部使用。</p><h3 id="第四节-Shell的语法"><a href="#第四节-Shell的语法" class="headerlink" title="第四节 Shell的语法"></a>第四节 Shell的语法</h3><h4 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h4><h5 id="1-1-系统预定义变量"><a href="#1-1-系统预定义变量" class="headerlink" title="1.1 系统预定义变量"></a>1.1 系统预定义变量</h5><p>常用系统变量包括：<code>$USER</code>、<code>$HOME</code>、<code>$PWD</code>、<code>$SHELL</code>等，可以使用echo命令输出它们的值。使用<code>set</code>命令可以查看所有系统预定义变量</p><h5 id="1-2-自定义变量"><a href="#1-2-自定义变量" class="headerlink" title="1.2 自定义变量"></a>1.2 自定义变量</h5><h6 id="1-2-1-定义变量"><a href="#1-2-1-定义变量" class="headerlink" title="1.2.1 定义变量"></a>1.2.1 定义变量</h6><pre><code class="shell">USER_NAME=tom</code></pre><h6 id="1-2-2-输出变量"><a href="#1-2-2-输出变量" class="headerlink" title="1.2.2 输出变量"></a>1.2.2 输出变量</h6><pre><code class="shell">echo $USER_NAME</code></pre><h6 id="1-2-3-撤销变量"><a href="#1-2-3-撤销变量" class="headerlink" title="1.2.3 撤销变量"></a>1.2.3 撤销变量</h6><pre><code class="shell">unset USER_NAME</code></pre><h6 id="1-2-4-定义静态变量"><a href="#1-2-4-定义静态变量" class="headerlink" title="1.2.4 定义静态变量"></a>1.2.4 定义静态变量</h6><pre><code class="shell">readonly COMPANY_NAME=atguigu</code></pre><p>静态变量不能撤销，也不能修改</p><h6 id="1-2-5-语法规则"><a href="#1-2-5-语法规则" class="headerlink" title="1.2.5 语法规则"></a>1.2.5 语法规则</h6><ul><li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议大写。</li><li>等号两侧不能有空格，衍生规则就是变量声明时必须初始化</li><li>在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。</li><li>变量的值如果有空格，需要使用双引号或单引号括起来。</li><li>变量名区分大小写。</li></ul><h5 id="1-3-特殊变量"><a href="#1-3-特殊变量" class="headerlink" title="1.3 特殊变量"></a>1.3 特殊变量</h5><h6 id="1-3-1-n"><a href="#1-3-1-n" class="headerlink" title="1.3.1 $n"></a>1.3.1 $n</h6><p>n是数字，$0代表当前脚本名称。从$1开始代表对应的脚本参数。从${10}开始数字需要使用{}括起来。 </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_034.png"></p><h6 id="1-3-2"><a href="#1-3-2" class="headerlink" title="1.3.2 $#"></a>1.3.2 $#</h6><p>返回输入参数的个数 </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_035.png"></p><h6 id="1-3-3-和"><a href="#1-3-3-和" class="headerlink" title="1.3.3 $*和$@"></a>1.3.3 $*和$@</h6><p>都能够返回全部参数，但是只有在循环中且放在引号中能够体现出它们的区别。 </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_036.png"></p><h6 id="1-3-4"><a href="#1-3-4" class="headerlink" title="1.3.4 $?"></a>1.3.4 $?</h6><p>返回上一条命令的执行结果。</p><ul><li>条件判断语句<ul><li>返回 0 表示 true</li><li>返回 1 表示 false</li></ul></li><li>普通语句<ul><li>返回 0 表示成功</li><li>返回非 0 数表示失败</li></ul></li></ul><h4 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h4><p>Shell的运算表达式的语法如下:  <code>$((表达式))</code>或<code>$[表达式] </code></p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_037.png"></p><h4 id="3-条件判断"><a href="#3-条件判断" class="headerlink" title="3. 条件判断"></a>3. 条件判断</h4><h5 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3.1 基本语法"></a>3.1 基本语法</h5><ul><li>写法1：test condition</li><li>写法2：[ condition ]<ul><li>注意 condition 前后有空格</li><li>空字符串视为 false，非空字符串视为 true</li></ul></li></ul><h5 id="3-2-常用判断条件"><a href="#3-2-常用判断条件" class="headerlink" title="3.2 常用判断条件"></a>3.2 常用判断条件</h5><table><thead><tr><th>数据类型</th><th>写法</th><th>单词</th><th>含义</th></tr></thead><tbody><tr><td>数值</td><td>-lt</td><td>less than</td><td>小于</td></tr><tr><td>数值</td><td>-le</td><td>less equal</td><td>小于等于</td></tr><tr><td>数值</td><td>-eq</td><td>equal</td><td>等于</td></tr><tr><td>数值</td><td>-gt</td><td>greater than</td><td>大于</td></tr><tr><td>数值</td><td>-ge</td><td>greater equal</td><td>大于等于</td></tr><tr><td>数值</td><td>-ne</td><td>not equal</td><td>不等于</td></tr><tr><td>文件</td><td>-r</td><td>read</td><td>判断当前用户是否可以读取该文件</td></tr><tr><td>文件</td><td>-w</td><td>write</td><td>判断当前用户是否可以修改该文件</td></tr><tr><td>文件</td><td>-x</td><td>execute</td><td>判断当前用户对该文件是否有执行权限</td></tr><tr><td>文件</td><td>-f</td><td>file</td><td>判断当前文件是否存在并且是一个常规的文件</td></tr><tr><td>文件</td><td>-e</td><td>existence</td><td>判断文件是否存在</td></tr><tr><td>文件</td><td>-d</td><td>directory</td><td>判断是否存在并且是一个目录</td></tr></tbody></table><p>可以参考下面例子：</p><pre><code class="shell">#!/bin/bash# 条件判断表达式写法一：testtest 10 -gt 7# 使用$?获取上一条语句的执行结果echo $?# 使用$?获取上一条语句的执行结果test 10 -lt 7echo $?# 条件判断表达式写法二：[ condition ]# 注意：condition两边要有空格[ 10 -gt 7 ]echo $?[ 10 -lt 7 ]echo $?# 专门针对文件进行操作的运算符[ -e aaa.txt ]echo $?[ -r aaa.txt ]echo $?[ -w aaa.txt ]echo $?</code></pre><h4 id="4-流程控制"><a href="#4-流程控制" class="headerlink" title="4. 流程控制"></a>4. 流程控制</h4><h5 id="4-1-三元运算"><a href="#4-1-三元运算" class="headerlink" title="4.1 三元运算"></a>4.1 三元运算</h5><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_038.png"></p><h5 id="4-2-if判断"><a href="#4-2-if判断" class="headerlink" title="4.2 if判断"></a>4.2 if判断</h5><h6 id="4-2-1-单if"><a href="#4-2-1-单if" class="headerlink" title="4.2.1 单if"></a>4.2.1 单if</h6><pre><code class="shell">if [ 10 -gt 5 ]thenecho &quot;10大于5&quot;fi</code></pre><h6 id="4-2-2-if…else…"><a href="#4-2-2-if…else…" class="headerlink" title="4.2.2 if…else…"></a>4.2.2 if…else…</h6><pre><code class="shell">if [ 10 -gt 5 ]thenecho &quot;10大于5&quot;elseecho &quot;10小于5&quot;fi</code></pre><h6 id="4-2-3-if…elif…"><a href="#4-2-3-if…elif…" class="headerlink" title="4.2.3 if…elif…"></a>4.2.3 if…elif…</h6><pre><code class="shell">if [ 10 -gt 5 ]thenecho &quot;10大于5&quot;elif [ 10 -lt 5 ]thenecho &quot;10小于5&quot;elseecho &quot;10等于5&quot;fi</code></pre><h5 id="4-3-case判断"><a href="#4-3-case判断" class="headerlink" title="4.3 case判断"></a>4.3 case判断</h5><pre><code class="shell">AGE=10case $AGE in&quot;10&quot;)echo 10;;&quot;20&quot;)echo 20;;*)echo other;;esac</code></pre><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_039.png"></p><h5 id="4-4-for循环"><a href="#4-4-for循环" class="headerlink" title="4.4 for循环"></a>4.4 for循环</h5><p>简单for循环</p><pre><code class="shell">for (( i=1;i&lt;=10;i++ ))doecho $idone</code></pre><p>从外部传入循环长度</p><pre><code class="shell">#!/bin/bash# 如果需要使用外部数据，则需要把外部数据赋值给一个变量，不能在for语句中直接使用len=$1for (( i=1;i&lt;=len;i++ ))# 从do关键字开始是循环体开始doecho $i;# 到done关键字为止是循环体结束done</code></pre><h5 id="4-5-for-in循环"><a href="#4-5-for-in循环" class="headerlink" title="4.5 for in循环"></a>4.5 for in循环</h5><pre><code class="shell">for i in $*doecho $idone</code></pre><p>没有引号的时候$*和$@一样，加了引号就有区别 </p><pre><code class="shell">for i in &quot;$*&quot;doecho $idone</code></pre><p>上面代码输出的结果是： </p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_040.png"></p><p>“$*”不换行，”$@”有换行。</p><h5 id="4-6-while循环"><a href="#4-6-while循环" class="headerlink" title="4.6 while循环"></a>4.6 while循环</h5><pre><code class="shell">sum=0start=1while [ $start -le 100 ]do# 累加sum=$[$sum+$start]# start的值自增1start=$[$start+1]doneecho $sum</code></pre><h4 id="5-函数"><a href="#5-函数" class="headerlink" title="5. 函数"></a>5. 函数</h4><p>Shell 编程中的函数和我们以前熟悉的函数最大的区别是：Shell 编程中要求函数的返回值只能是整数。并且只能通过 $? 方式获得。可以显示加：return 返回，如果不加，将以最后一条命令运行结果(这个运算结果可以表示true或者false，以及执行成功或者执行失败)，作为返回值。return 后跟数值 n(0-255)。 </p><pre><code class="shell">#!/bin/bash# 声明函数function sum()&#123;    # 使用$1、$2引用函数传入的参数    return $[$1+$2]&#125;# 调用函数，传入参数sum 10 20# 使用$?获取函数执行结果echo &quot;sum 10 20执行的结果是$?&quot;</code></pre><h4 id="6-获取脚本外部数据"><a href="#6-获取脚本外部数据" class="headerlink" title="6. 获取脚本外部数据"></a>6. 获取脚本外部数据</h4><h5 id="6-1-获取参数"><a href="#6-1-获取参数" class="headerlink" title="6.1 获取参数"></a>6.1 获取参数</h5><p>这个前面说过了，通过$1、$2、……方式获取，从${10}开始需要使用大括号。 </p><h5 id="6-2-使用read读取用户输入"><a href="#6-2-使用read读取用户输入" class="headerlink" title="6.2 使用read读取用户输入"></a>6.2 使用read读取用户输入</h5><p>read命令有两个常用参数</p><ul><li>-t用于指定输入等待时间，单位是秒</li><li>-p用于指定提示文字</li></ul><pre><code class="shell">read -t 10 -p &quot;please enter:&quot; NAMEecho $NAME</code></pre><h2 id="第五章-服务器端应用程序的安装"><a href="#第五章-服务器端应用程序的安装" class="headerlink" title="第五章 服务器端应用程序的安装"></a>第五章 服务器端应用程序的安装</h2><h3 id="第一节-备份配置文件"><a href="#第一节-备份配置文件" class="headerlink" title="第一节 备份配置文件"></a>第一节 备份配置文件</h3><p>Linux 系统环境下配置文件通常内容很多。如果不小心修改了不该修改的地方，自己有不记得做了修改，那么将来报错很难找到错误位置。</p><p>为了避免这样的问题，我们可以在修改任何配置文件之前都多复制一份：把原始、纯净、正确的配置文件执行了备份。将来万一发生问题，拿原始配置文件覆盖错误配置文件，瞬间恢复到正确状态可以重新开始。</p><h3 id="第二节-快照备份虚拟机"><a href="#第二节-快照备份虚拟机" class="headerlink" title="第二节 快照备份虚拟机"></a>第二节 快照备份虚拟机</h3><h4 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1. 使用场景"></a>1. 使用场景</h4><h5 id="1-1-场景一"><a href="#1-1-场景一" class="headerlink" title="1.1 场景一"></a>1.1 场景一</h5><p>针对需要通过安装过程来安装的程序，如果安装失败需要卸载后重新安装，那最好是卸载干净再重新执行安装。Linux 环境下不方便执行『清理残留』。</p><p>所以为了避免安装失败以后没有退路可以重新开始，建议在执行相关安装之前拍摄快照。一旦发生问题，可以恢复快照重新开始。</p><h5 id="1-2-场景二"><a href="#1-2-场景二" class="headerlink" title="1.2 场景二"></a>1.2 场景二</h5><p>对于已经安装好的程序（特别是系统当中安装了很多程序都已成功），强烈建议通过拍摄快照的方式保留这个正确的状态。 </p><h4 id="2-具体操作"><a href="#2-具体操作" class="headerlink" title="2. 具体操作"></a>2. 具体操作</h4><h5 id="2-1-保存快照"><a href="#2-1-保存快照" class="headerlink" title="2.1 保存快照"></a>2.1 保存快照</h5><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_041.png"></p><p>给快照文件命名:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_042.png"></p><h5 id="2-2-恢复快照"><a href="#2-2-恢复快照" class="headerlink" title="2.2 恢复快照"></a>2.2 恢复快照</h5><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_043.png"></p><h5 id="2-3-删除快照"><a href="#2-3-删除快照" class="headerlink" title="2.3 删除快照"></a>2.3 删除快照</h5><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_044.png"></p><h3 id="第三节-安装JDK"><a href="#第三节-安装JDK" class="headerlink" title="第三节 安装JDK"></a>第三节 安装JDK</h3><h4 id="1-rpm命令"><a href="#1-rpm命令" class="headerlink" title="1. rpm命令"></a>1. rpm命令</h4><p>rpm 是 Redhat package management 的缩写，实质上来说，通过 rpm 可以管理 Linux 环境下的安装包。 </p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>-qa</td><td>查询系统中已经安装的程序，通常配合管道，使用 grep 精确匹配想要查询的包</td></tr><tr><td>-ivh</td><td>执行 rpm 包安装操作</td></tr><tr><td>-e</td><td>卸载 rpm 包</td></tr><tr><td>–nodeps</td><td>在卸载过程中忽略依赖关系</td></tr></tbody></table><p>注：Linux 系统中命令的参数往往有这样的特点：</p><ul><li>参数如果是一个或多个完整的单词那么前面是两个“-”</li><li>参数如果是单词的缩写，是一个字母，那么前面是一个“-”</li></ul><h4 id="2-具体安装步骤"><a href="#2-具体安装步骤" class="headerlink" title="2. 具体安装步骤"></a>2. 具体安装步骤</h4><h5 id="2-1-卸载系统预装的JDK"><a href="#2-1-卸载系统预装的JDK" class="headerlink" title="2.1 卸载系统预装的JDK"></a>2.1 卸载系统预装的JDK</h5><ol><li> 查询系统中已经安装的 JDK </li></ol><pre><code class="shel">rpm -qa | grep openjdk</code></pre><ol start="2"><li> 执行卸载，卸载过程中使用 –nodeps 忽略依赖关系 </li></ol><pre><code class="shell">rpm -e --nodeps 第一步查询出来的数据，如果是多个则用空格分隔</code></pre><ol start="3"><li> 重启系统生效(一般不需要)</li></ol><pre><code class="shell">reboot</code></pre><h5 id="2-2-安装JDK"><a href="#2-2-安装JDK" class="headerlink" title="2.2 安装JDK"></a>2.2 安装JDK</h5><ol><li><p>使用xftp将资料中的jdk的压缩包传输到虚拟机的<code>/opt</code>目录中</p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_045.png"></p></li><li><p>解压jdk压缩包</p><pre><code class="shell">cd /opttar -zxvf jdk-8u152-linux-x64.tar.gz</code></pre></li><li><p>配置JDK的环境变量</p><p>为了避免配置错误导致运行失败，提前复制一份/etc/profile </p><pre><code class="shell">cp /etc/profile /etc/profile.bak</code></pre><p>编辑 /etc/profile 文件（下面内容添加到文件末尾）： </p><pre><code class="shell"># 声明 JAVA_HOME 环境变量，等号两边不能有空格JAVA_HOME=/opt/jdk1.8.0_152   # 给 PATH 环境变量附加 $JAVA_HOME/bin 部分# $PATH 表示引用 PATH 环境变量以前的旧值# 使用英文冒号连接# $JAVA_HOME 表示对 JAVA_HOME 变量的引用# $JAVA_HOME/bin 表示指向可执行文件PATH=$JAVA_HOME/bin:$PATH   # 发布# 发布是发布变量名，不是引用变量的值，所以前面不写 $ 符号export JAVA_HOME PATH</code></pre><p>保存退出vim后，使用source命令执行/etc/profile脚本，让脚本中发布的环境变量生效。但是仅限于当前进程，如果想让新环境变量全局生效，可以reboot。 </p><pre><code class="shell">source /etc/profile</code></pre><p>验证一下：</p><pre><code class="shell">echo $JAVA_HOMEecho $PATHjava -version</code></pre></li></ol><h3 id="第四节-安装Tomcat"><a href="#第四节-安装Tomcat" class="headerlink" title="第四节 安装Tomcat"></a>第四节 安装Tomcat</h3><h4 id="1-具体安装步骤"><a href="#1-具体安装步骤" class="headerlink" title="1. 具体安装步骤"></a>1. 具体安装步骤</h4><ol><li><p>使用xftp将资料中的Tomcat的压缩包传输到虚拟机的<code>/opt</code>目录中</p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_046.png"></p></li><li><p>解压Tomcat的压缩包</p><pre><code class="shell">cd /opttar -zxvf /opt/apache-tomcat-8.5.32.tar.gz</code></pre></li></ol><h4 id="2-操作Tomcat"><a href="#2-操作Tomcat" class="headerlink" title="2. 操作Tomcat"></a>2. 操作Tomcat</h4><ol><li><p>启动 Tomcat </p><pre><code class="shell">/opt/apache-tomcat-8.5.32/bin/startup.sh</code></pre></li><li><p>停止 Tomcat </p><pre><code class="shell">/opt/apache-tomcat-8.5.32/bin/shutdown.sh</code></pre></li><li><p>查看日志 </p><pre><code class="shell">tail -F /opt/apache-tomcat-8.5.32/logs/catalina.out</code></pre></li><li><p>部署 war 包放在 webapps 目录下 </p><pre><code class="shell">/opt/apache-tomcat-8.5.32/webapps</code></pre></li></ol><p>注意: </p><ul><li>在 Linux 系统本地使用火狐浏览器访问可以使用 localhost</li><li>在 Windows 系统访问 Linux 服务器端的 Tomcat 需要使用 LInux 的 IP 地址,并且要保证防火墙关闭，或者放行了8080端口</li></ul><p>开发阶段可以关闭防火墙，关闭防火墙的命令:</p><pre><code class="shell">systemctl stop firewalld.service</code></pre><p>在开发阶段可以禁止防火墙开机自启动:<code>systemctl disable firewalld.service</code></p><p>让防火墙放行8080端口的命令:</p><pre><code class="shell">firewall-cmd --add-port=8080/tcp --permanent# 放行端口后一定要重新加载防火墙配置firewall-cmd --reload</code></pre><h3 id="第三节-安装MySQL-安装之前一定要快照"><a href="#第三节-安装MySQL-安装之前一定要快照" class="headerlink" title="第三节 安装MySQL(安装之前一定要快照)"></a>第三节 安装MySQL(安装之前一定要快照)</h3><h4 id="1-卸载系统预装-mariadb"><a href="#1-卸载系统预装-mariadb" class="headerlink" title="1. 卸载系统预装 mariadb"></a>1. 卸载系统预装 mariadb</h4><ol><li><p>查询系统中预装的mariadb</p><pre><code class="shell">rpm -qa | grep mariadb --color</code></pre></li><li><p>删除系统中预装的mariadb(如果第一步没查到就不删)</p><pre><code class="shell">rpm -e --nodeps 第一步查询到的结果</code></pre></li></ol><p>注：MySQL 被 Oracle 收购，社区担心将来 MySQL 被 Oracle 关闭开源模式，和 Oracle 数据库一样变成商业化运作。所以社区开发了一个 MySQL 的社区版，内部和 MySQL 一样，只是名字不同，这就是 mariadb。但是我们当前在 Linux 系统中已经预装的 mariadb 只是一个残片，不能直接使用。所以还是要先卸载。 </p><h4 id="2-具体安装步骤-1"><a href="#2-具体安装步骤-1" class="headerlink" title="2. 具体安装步骤"></a>2. 具体安装步骤</h4><h5 id="2-1-将mysql的压缩包拷贝到虚拟机中"><a href="#2-1-将mysql的压缩包拷贝到虚拟机中" class="headerlink" title="2.1 将mysql的压缩包拷贝到虚拟机中"></a>2.1 将mysql的压缩包拷贝到虚拟机中</h5><ol><li><p>在虚拟机中的<code>/usr/local</code>中创建一个<code>mysql</code>目录</p></li><li><p>使用xftp将mysql压缩包拷贝到<code>/usr/local/mysql</code>目录中</p><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_047.png"></p></li></ol><h5 id="2-2-解压MySQL的tar包"><a href="#2-2-解压MySQL的tar包" class="headerlink" title="2.2 解压MySQL的tar包"></a>2.2 解压MySQL的tar包</h5><pre><code class="shell">cd /usr/local/mysqltar -zxvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar.gz</code></pre><h5 id="2-3-安装MySQL-下述步骤依次执行"><a href="#2-3-安装MySQL-下述步骤依次执行" class="headerlink" title="2.3 安装MySQL,下述步骤依次执行"></a>2.3 安装MySQL,下述步骤依次执行</h5><pre><code class="shell">rpm -ivh mysql-community-common-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-devel-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-server-5.7.25-1.el7.x86_64.rpm</code></pre><h5 id="2-4-修改MySQL的字符集配置"><a href="#2-4-修改MySQL的字符集配置" class="headerlink" title="2.4 修改MySQL的字符集配置"></a>2.4 修改MySQL的字符集配置</h5><p>MySql默认使用的字符集是latin1，即：iso-8859-1，是不支持中文的。</p><p>要想让MySql支持中文，需要通过配置文件设置指定MySql使用utf-8字符集才可以。</p><p>修改MySql的字符集：</p><p>使用vim打开mysql的配置文件：  vim /etc/my.cnf</p><p>进入编辑模式,在[mysqld]后边添加内容：<code>character-set-server=utf8</code></p><p>注意：别在 vim 的一般模式下直接粘贴！<strong>一定要进入编辑模式</strong>！ </p><h5 id="2-5-启动MySQL服务"><a href="#2-5-启动MySQL服务" class="headerlink" title="2.5 启动MySQL服务"></a>2.5 启动MySQL服务</h5><pre><code class="shell">systemctl start mysqld</code></pre><h5 id="2-6-设置MySQL服务开机自启动"><a href="#2-6-设置MySQL服务开机自启动" class="headerlink" title="2.6 设置MySQL服务开机自启动"></a>2.6 设置MySQL服务开机自启动</h5><pre><code class="shell">systemctl enable mysqld</code></pre><h5 id="2-7-查看MySQL初始密码"><a href="#2-7-查看MySQL初始密码" class="headerlink" title="2.7 查看MySQL初始密码"></a>2.7 查看MySQL初始密码</h5><p>安装MySQL的过程中会自动生成初始密码，我们可以在<code>/var/log/mysqld.log</code>文件中进行查看</p><pre><code class="shell">cat /var/log/mysqld.log | grep &quot;temporary password&quot; --color</code></pre><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_048.png"></p><h5 id="2-8-使用初始密码登录MySQL"><a href="#2-8-使用初始密码登录MySQL" class="headerlink" title="2.8 使用初始密码登录MySQL"></a>2.8 使用初始密码登录MySQL</h5><pre><code class="shell">mysql -uroot -p&quot;初始密码&quot;</code></pre><p>注意: p和初始密码之间千万不能空格</p><h5 id="2-9-修改root的密码"><a href="#2-9-修改root的密码" class="headerlink" title="2.9 修改root的密码"></a>2.9 修改root的密码</h5><p>在使用初始密码登录mysql之后，依次执行下面三行命令</p><pre><code class="mysql">set global validate_password_length=4;set global validate_password_policy=LOW;set password = password(&#39;root&#39;);</code></pre><p>第一次修改密码一定要按照上述三步来做，修改完之后你如果想将密码改成其它的密码，你可以在退出mysql之后执行（需要在未登录mysql的情况下执行）：</p><pre><code>mysqladmin -uroot -p password 新密码  -- 新密码不需要加上引号</code></pre><h4 id="3-在宿主机上用SqlYog远程连接虚拟机上的MySQL"><a href="#3-在宿主机上用SqlYog远程连接虚拟机上的MySQL" class="headerlink" title="3. 在宿主机上用SqlYog远程连接虚拟机上的MySQL"></a>3. 在宿主机上用SqlYog远程连接虚拟机上的MySQL</h4><h5 id="3-1-会遇到的问题"><a href="#3-1-会遇到的问题" class="headerlink" title="3.1 会遇到的问题"></a>3.1 会遇到的问题</h5><h6 id="3-1-1-被防火墙拦截"><a href="#3-1-1-被防火墙拦截" class="headerlink" title="3.1.1 被防火墙拦截"></a>3.1.1 被防火墙拦截</h6><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_049.png"></p><p>解决方案是关闭防火墙或者是让防火墙放行<code>3306</code>端口</p><p>关闭防火墙命令:</p><pre><code class="shell">systemctl stop firewalld.service</code></pre><p>放行3306端口的操作:</p><pre><code class="shell">firewall-cmd --add-port=3306/tcp --permanent# 放行端口后一定要重新加载防火墙配置firewall-cmd --reload</code></pre><h6 id="3-1-2-MySQL服务器不允许远程访问"><a href="#3-1-2-MySQL服务器不允许远程访问" class="headerlink" title="3.1.2 MySQL服务器不允许远程访问"></a>3.1.2 MySQL服务器不允许远程访问</h6><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_050.png"></p><p>解决方案是让<code>root</code>用户能够远程访问MySQL服务器:</p><pre><code class="mysql"># 允许远程访问:创建一个新的root对象，并且指定这个root对象对所有数据库里面的所有表都有所有权限，并且指定这个root用户的密码是123456grant all on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;123456&#39;;# 刷新设置flush privileges;</code></pre><p>解决上述俩问题之后，就可以使用宿主机中的SQLYog远程连接访问虚拟机中的MySQL了</p><h2 id="第六章-VMWare软件联网原理说明与故障解决"><a href="#第六章-VMWare软件联网原理说明与故障解决" class="headerlink" title="第六章 VMWare软件联网原理说明与故障解决"></a>第六章 VMWare软件联网原理说明与故障解决</h2><h3 id="第一节-NAT的原理"><a href="#第一节-NAT的原理" class="headerlink" title="第一节 NAT的原理"></a>第一节 NAT的原理</h3><p><img src="http://www.slx.blue/2021/12/16/Linux-02/tu_051.png"></p><p>NAT模式，利用虚拟的NAT设备以及虚拟DHCP服务器来使虚拟机连接外网，而VMware Network Adapter VMnet8虚拟网卡是用来与虚拟机通信的。 </p><h3 id="第二节-常见的问题"><a href="#第二节-常见的问题" class="headerlink" title="第二节 常见的问题"></a>第二节 常见的问题</h3><h4 id="1-Windows端虚拟网卡虚拟网络连接丢失"><a href="#1-Windows端虚拟网卡虚拟网络连接丢失" class="headerlink" title="1. Windows端虚拟网卡虚拟网络连接丢失"></a>1. Windows端虚拟网卡虚拟网络连接丢失</h4><p>也就是在你的网络连接中丢失了<code>VMware Network Adapter VMnet8</code>虚拟网卡</p><p>修复办法：</p><ul><li>首先将Linux系统关机。</li><li>打开“虚拟网络编辑器”</li><li>点击“还原默认设置”（不保证和之前是同一个网段，所以大概率IP地址网段会变）</li><li>如果修复了虚拟网卡和虚拟网络连接<ul><li>进入Linux系统修改IP地址，还是要求和虚拟网络编辑器中限定的网段一致</li></ul></li><li>如果没有修复成功尝试下面操作<ul><li>安装CCleaner软件</li><li>清理注册表</li></ul></li><li>重新进入“虚拟网络编辑器”执行“还原默认设置”</li><li>如果还没有解决，可以尝试卸载VMWare并清理残留重新安装VMWare</li><li>如果还不行，重装Windows系统</li></ul><h4 id="2-虚拟网络连接IP地址乱了"><a href="#2-虚拟网络连接IP地址乱了" class="headerlink" title="2. 虚拟网络连接IP地址乱了"></a>2. 虚拟网络连接IP地址乱了</h4><p>虚拟网卡还在，虚拟网络连接也在，但是和 NAT 方式对应的虚拟网络连接的 IP 不是 192.168.xxx.xxx 了，而是169.254.xxx.xxx。此时已经没法和 Linux 的 IP 保持同一个网段了。</p><p>此时唯一的办法：在虚拟网络编辑器中“还原默认设置”。让 VMWare 的虚拟网络编辑器重置网络连接。</p><h4 id="3-各方面正常就是连不上"><a href="#3-各方面正常就是连不上" class="headerlink" title="3. 各方面正常就是连不上"></a>3. 各方面正常就是连不上</h4><p>检查一下是不是 Windows 系统中 VMware 的服务没有启动，如果是就把服务启动起来。或虚拟机网卡使用的是仅主机模式，而 Linux 中 IP 地址使用的是 NAT 模式的网段。 </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-入门</title>
      <link href="/2021/12/16/Linux-01/"/>
      <url>/2021/12/16/Linux-01/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-day01"><a href="#Linux-day01" class="headerlink" title="Linux-day01"></a>Linux-day01</h1><h2 id="第一章-Linux的概述"><a href="#第一章-Linux的概述" class="headerlink" title="第一章 Linux的概述"></a>第一章 Linux的概述</h2><h3 id="第一节-Linux是什么"><a href="#第一节-Linux是什么" class="headerlink" title="第一节 Linux是什么"></a>第一节 Linux是什么</h3><p>Linux 英文解释为 Linux is not Unix</p><p>Linux是Linus Torvolds于1991年开发的一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。</p><p>(注：POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ），POSIX标准定义了操作系统应该为应用程序提供的接口标准)</p><p>Linux能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。</p><p>Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><p>目前市面上较知名的发行版有：****Ubuntu*<em><strong>、RedHat、</strong></em>*CentOS****、Debain、Fedora、SuSE、OpenSUSE</p><h3 id="第二节-Linux的使用场景"><a href="#第二节-Linux的使用场景" class="headerlink" title="第二节 Linux的使用场景"></a>第二节 Linux的使用场景</h3><ol><li>作为服务器操作系统是目前Linux应用最广泛的领域</li><li>类似Windows作为桌面应用系统，新版本的Linux系统特别在桌面应用方面进行了改进，达到相当的水平，完全可以作为一种集办公应用、 多媒体应用、网络应用等多方面功能于一体的图形界面操作系统。 </li><li>作为各种嵌入式设备的操作系统，例如机顶盒、移动电话、智能家居设备等等，在移动电话领域的第一大操作系统的Android就是基于Linux内核的</li><li>应用在超级计算机中作为操作系统， 在TOP500超级电脑列表采用Linux为操作系统的，占了371组（即74.2%），其中的前十位者，有7组是使用Linux的。 </li></ol><h3 id="第三节-怎么下载Linux系统镜像"><a href="#第三节-怎么下载Linux系统镜像" class="headerlink" title="第三节 怎么下载Linux系统镜像"></a>第三节 怎么下载Linux系统镜像</h3><p>centos下载地址：</p><p>网易镜像：</p><p><a href="http://mirrors.163.com/centos/6/isos/">http://mirrors.163.com/centos/6/isos/</a></p><p><a href="http://mirrors.163.com/centos/7/isos/x86_64/">http://mirrors.163.com/centos/7/isos/x86_64/</a></p><p>搜狐镜像：</p><p><a href="http://mirrors.sohu.com/centos/6/isos/">http://mirrors.sohu.com/centos/6/isos/</a> </p><p><a href="http://mirrors.sohu.com/centos/7/isos/x86_64/">http://mirrors.sohu.com/centos/7/isos/x86_64/</a></p><p>当然，在我们发的资料中已经有老师给你们下载好的现成的Linux系统的镜像</p><h3 id="第四节-Linux系统的分类"><a href="#第四节-Linux系统的分类" class="headerlink" title="第四节 Linux系统的分类"></a>第四节 Linux系统的分类</h3><h4 id="1-按照市场需求分"><a href="#1-按照市场需求分" class="headerlink" title="1.  按照市场需求分"></a>1.  按照市场需求分</h4><ul><li>桌面版：类似于Windows的，有图形化界面的操作系统。不成熟</li><li>服务器版：没有图形化界面，使用命令行(CLI, Command Line Interface)进行操作的。企业里通常会使用服务器版的</li></ul><h4 id="2-按照原生程度分"><a href="#2-按照原生程度分" class="headerlink" title="2. 按照原生程度分"></a>2. 按照原生程度分</h4><ul><li>内核版：Linus领导的开发小组，维护的内核版本。</li><li>发行版：一些企业、社区在内核的基础上，增加一些功能、软件，然后重新发行的版本</li></ul><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_001.png"></p><h2 id="第二章-安装虚拟机和CentOS系统"><a href="#第二章-安装虚拟机和CentOS系统" class="headerlink" title="第二章 安装虚拟机和CentOS系统"></a>第二章 安装虚拟机和CentOS系统</h2><h3 id="第一节-安装虚拟机"><a href="#第一节-安装虚拟机" class="headerlink" title="第一节 安装虚拟机"></a>第一节 安装虚拟机</h3><h4 id="1-什么是虚拟机"><a href="#1-什么是虚拟机" class="headerlink" title="1. 什么是虚拟机"></a>1. 什么是虚拟机</h4><p>虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。在实体计算机中能够完成的工作在虚拟机中都能够实现。在计算机中创建虚拟机时，需要将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存容量。每个虚拟机都有独立的CMOS、硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作。 </p><h4 id="2-常见的虚拟机软件"><a href="#2-常见的虚拟机软件" class="headerlink" title="2. 常见的虚拟机软件"></a>2. 常见的虚拟机软件</h4><h5 id="2-1-VirtualBox"><a href="#2-1-VirtualBox" class="headerlink" title="2.1 VirtualBox"></a>2.1 VirtualBox</h5><p>VirtualBox 是一款开源虚拟机软件。VirtualBox 是由德国 Innotek公司开发，由Sun Microsystems公司出品的软件，使用Qt编写，在 Sun 被 Oracle收购后正式更名成 Oracle VM VirtualBox。使用者可以在VirtualBox上安装并且执行Solaris、Windows、DOS、Linux、OS/2Warp、BSD等系统作为客户端操作系统。已由甲骨文公司进行开发，是甲骨文公司xVM虚拟化平台技术的一部分。 </p><h5 id="2-2-VMWare-Workstation"><a href="#2-2-VMWare-Workstation" class="headerlink" title="2.2 VMWare Workstation"></a>2.2 VMWare Workstation</h5><p><strong>VMware</strong>是全球台式电脑及资料中心虚拟化解决方案的领导厂商。VMWare Workstation是该公司出品的“虚拟 机”软件，通过它可在一台电脑上同时运行更多的Microsoft Windows、Linux、Mac OS X、DOS系统。 </p><h4 id="3-安装VMWare软件"><a href="#3-安装VMWare软件" class="headerlink" title="3. 安装VMWare软件"></a>3. 安装VMWare软件</h4><h5 id="3-1-软件所在位置"><a href="#3-1-软件所在位置" class="headerlink" title="3.1 软件所在位置"></a>3.1 软件所在位置</h5><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_002.png"></p><h5 id="3-2-安装步骤"><a href="#3-2-安装步骤" class="headerlink" title="3.2 安装步骤"></a>3.2 安装步骤</h5><p>开始安装:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_003.png"></p><p>欢迎界面:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_004.png"></p><p>许可协议:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_005.png"></p><p>安装位置：</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_006.png"></p><p>是否检查产品更新，不勾选，不帮助其完善，只管用：</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_007.png"></p><p>是否创建桌面快捷方式和开始菜单启动方式，建议都选上:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_008.png"></p><p>开始安装: </p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_009.png"></p><p>安装完成界面:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_010.png"></p><h5 id="3-3-破解VMWare"><a href="#3-3-破解VMWare" class="headerlink" title="3.3 破解VMWare"></a>3.3 破解VMWare</h5><p>破解文件所在位置,打开文件查看破解的注册码:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_011.png"></p><p>在VMWare中输入注册码:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_012.png"></p><p>破解成功页面:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_013.png"></p><h4 id="4-使用VMWare创建虚拟机"><a href="#4-使用VMWare创建虚拟机" class="headerlink" title="4. 使用VMWare创建虚拟机"></a>4. 使用VMWare创建虚拟机</h4><h5 id="4-1-检查电脑是否已经开启虚拟化支持"><a href="#4-1-检查电脑是否已经开启虚拟化支持" class="headerlink" title="4.1 检查电脑是否已经开启虚拟化支持"></a>4.1 检查电脑是否已经开启虚拟化支持</h5><p>不一定非得检查电脑是否已经开启虚拟化支持，一般的电脑都是默认开启的，如果你在创建虚拟机的时候报了类似以下的错误，则需要去检查是否开启了虚拟化支持</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_014.png"></p><p>如果电脑未开启虚拟化支持则需要开启虚拟化支持</p><p>各种型号的电脑进入BIOS界面检查是否开启虚拟化支持，以及设置启动虚拟化支持的步骤都不太一样，所以需要自行百度查找方法</p><h5 id="4-2-创建虚拟机的步骤"><a href="#4-2-创建虚拟机的步骤" class="headerlink" title="4.2 创建虚拟机的步骤"></a>4.2 创建虚拟机的步骤</h5><p>新建虚拟机选择自定义:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_016.png"></p><p>选择硬件兼容性:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_017.png"></p><p>创建虚拟空白硬盘:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_018.png"></p><p>选择操作系统版本:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_019.png"></p><p>指定虚拟机的名字以及安装位置：</p><p>名字可以随便命，安装位置不能有中文和空格</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_020.png"></p><p>配置处理器:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_021.png"></p><p>配置内存大小:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_022.png"></p><p>配置网络类型为NAT:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_023.png"></p><p>配置IO控制器类型:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_024.png"></p><p>选择磁盘类型:</p><p>IDE :并口硬盘，最大80G，传输慢</p><p>SATA:串口硬盘，机械硬盘</p><p>SCSI：串口硬盘，做过优化，传输速度更快</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_025.png"></p><p>新建虚拟磁盘</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_026.png"></p><p>配置磁盘空间:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_027.png"></p><p>选择磁盘文件存储位置:<br>建议和虚拟机存储目录保持一致</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_028.png"></p><p>新建虚拟机完成页面:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_029.png"></p><p>虚拟机设置: 指定操作系统镜像文件路径</p><p>点击设置:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_030.png"></p><p>指定操作系统镜像文件路径:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_031.png"></p><h4 id="5-开启虚拟机安装CentOS操作系统"><a href="#5-开启虚拟机安装CentOS操作系统" class="headerlink" title="5. 开启虚拟机安装CentOS操作系统"></a>5. 开启虚拟机安装CentOS操作系统</h4><h5 id="5-1-开启虚拟机"><a href="#5-1-开启虚拟机" class="headerlink" title="5.1 开启虚拟机"></a>5.1 开启虚拟机</h5><p>点击开启虚拟机:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_032.png"></p><p>开启虚拟机之后的欢迎页面:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_033.png"></p><p>回车选择第一个开始安装配置，此外，在Ctrl+Alt可以实现Windows主机和VM之间窗口的切换</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_333.png"></p><h5 id="5-2-开始安装CentOS操作系统"><a href="#5-2-开始安装CentOS操作系统" class="headerlink" title="5.2 开始安装CentOS操作系统"></a>5.2 开始安装CentOS操作系统</h5><p>选择安装过程中使用的语言:</p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_034.png" style="zoom:75%;"><p>配置时间日期:</p><p>点击“日期和时间”调整后点完成</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_035.png"></p><p>配置时区:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_036.png"></p><p>设置键盘类型:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_037.png"></p><p>增加个英语（美国）:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_037_01.png"></p><p>选择语言:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_038.png"></p><p>选择安装源:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_039_01.png"></p><p>设置安装源为: 自动检测</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_039.png"></p><p>进行软件选择:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_040_01.png"></p><p>选择为GNOME桌面:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_040.png"></p><p>安装目标位置:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_041_01.png"></p><p>选择我要配置分区:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_041.png"></p><p>点击完成。</p><p>添加标准分区:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_042.png"></p><p>Boot引导区要大于200Mb:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_043.png"></p><p>设置Boot分区文件系统: ext4</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_044.png"></p><p>再次点击加号，添加Swap分区</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_045_01.png"></p><p>Swap分区设置: 文件系统为swap</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_045.png"></p><p>继续点击加号添加”/“分区，剩余空间都给它:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_046_01.png"></p><p>设置”/“分区:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_046.png"></p><p>接收更改，格式化:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_047.png"></p><p>进入Kdump设置:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_048_01.png"></p><p>取消勾选，不启用Kdump:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_048.png"></p><p>设置网络和主机名: 修改主机名</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_049.png"></p><p>点击“开始安装”，进入安装页面:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_050_01.png"></p><p>设置“ROOT密码”，不用创建新用户</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_050.png"></p><p>确认密码:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_051.png"></p><p>等待，安装完成之后重启:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_052.png"></p><p>重启后进入欢迎页:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_053.png"></p><p>许可证页面，同意许可:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_054.png"></p><p>点击完成配置</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_055.png"></p><p>输入选择“汉语（pinyin）”：然后选择前进</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_056.png"></p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_056_01.png"></p><p>隐私，默认，点击前进</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_057.png"></p><p>时区，上海，点击前进</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_058.png"></p><p>在线账号，跳过</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_059.png"></p><p>关于您，设置自己账号</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_060.png"></p><p>设置自己账号的密码</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_061.png"></p><p>开始使用CentOS系统:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_062.png"></p><p>系统主界面:注销自己的账户</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_063.png"></p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_064.png"></p><p>用Root账户登录:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_065_01.png"></p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_065.png"></p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_066.png"></p><p>网络连接:设置有线连接为自动连接</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_067_01.png"></p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_067_02.png"></p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_067.png"></p><p>设置命令行窗口:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_068.png"></p><p>​    选择”文件”—-&gt;”新建配置文件”</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_069.png"></p><h2 id="第三章-安装和使用远程访问工具"><a href="#第三章-安装和使用远程访问工具" class="headerlink" title="第三章 安装和使用远程访问工具"></a>第三章 安装和使用远程访问工具</h2><h3 id="第一节-远程访问工具的概述"><a href="#第一节-远程访问工具的概述" class="headerlink" title="第一节 远程访问工具的概述"></a>第一节 远程访问工具的概述</h3><h4 id="1-为什么要使用远程访问工具"><a href="#1-为什么要使用远程访问工具" class="headerlink" title="1. 为什么要使用远程访问工具"></a>1. 为什么要使用远程访问工具</h4><ul><li>通过远程访问工具可以直接从宿主机访问虚拟机，以及在宿主机中向虚拟机传输文件</li><li>实际应用中服务器一般放在远端（机房）或者云服务上，测试人员不可能直接到现场操作Linux服务器,所以需要远程访问工具远程操作服务器</li></ul><h4 id="2-常见的远程访问工具"><a href="#2-常见的远程访问工具" class="headerlink" title="2. 常见的远程访问工具"></a>2. 常见的远程访问工具</h4><h5 id="2-1-远程文件传输工具"><a href="#2-1-远程文件传输工具" class="headerlink" title="2.1 远程文件传输工具"></a>2.1 远程文件传输工具</h5><p>远程文件传输工具是用于不同的计算机之间进行文件传输的工具，我们目前可以使用它从宿主机传输文件给虚拟机</p><ul><li>FileZilla</li><li>FlashFXP</li><li>Xftp</li></ul><h5 id="2-2-远程命令行操作工具"><a href="#2-2-远程命令行操作工具" class="headerlink" title="2.2 远程命令行操作工具"></a>2.2 远程命令行操作工具</h5><p>远程命令行操作工具是用于在客户机上使用Linux命令远程操作服务机，我们目前可以使用它在宿主机上通过Linux命令行操作虚拟机</p><ul><li>XShell</li><li>FinalShell</li><li>SecureCRT</li></ul><h4 id="3-安装使用远程文件传输工具"><a href="#3-安装使用远程文件传输工具" class="headerlink" title="3. 安装使用远程文件传输工具"></a>3. 安装使用远程文件传输工具</h4><h5 id="3-1-安装Xftp"><a href="#3-1-安装Xftp" class="headerlink" title="3.1 安装Xftp"></a>3.1 安装Xftp</h5><p>软件位置:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_070.png"></p><p>双击安装:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_071.png"></p><p>选择免费版:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_072.png"></p><p>选择接受协议:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_073.png"></p><p>修改安装路径:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_074.png"></p><p>选择程序文件夹: 直接点下一步</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_076.png"></p><p>选择语言: </p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_077.png"></p><p>安装完成:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_078.png"></p><h5 id="3-2-使用Xftp远程连接虚拟机"><a href="#3-2-使用Xftp远程连接虚拟机" class="headerlink" title="3.2 使用Xftp远程连接虚拟机"></a>3.2 使用Xftp远程连接虚拟机</h5><p>新建会话:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_079.png"></p><p>设置会话属性:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_080.png"></p><p>解决乱码:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_081.png"></p><h4 id="4-安装使用远程命令行操作工具"><a href="#4-安装使用远程命令行操作工具" class="headerlink" title="4. 安装使用远程命令行操作工具"></a>4. 安装使用远程命令行操作工具</h4><h5 id="4-1-安装Xshell"><a href="#4-1-安装Xshell" class="headerlink" title="4.1 安装Xshell"></a>4.1 安装Xshell</h5><p>软件所在位置:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_082.png"></p><p>开始安装:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_083.png"></p><p>选择免费版:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_084.png"></p><p>同意许可证协议:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_085.png"></p><p>选择安装路径:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_086.png"></p><p>选择文件夹:直接点下一步</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_087.png"></p><p>选择语言: 简体中文</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_088.png"></p><p>安装完成:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_089.png"></p><h5 id="4-2-使用XShell远程连接操作虚拟机"><a href="#4-2-使用XShell远程连接操作虚拟机" class="headerlink" title="4.2 使用XShell远程连接操作虚拟机"></a>4.2 使用XShell远程连接操作虚拟机</h5><p>新建会话:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_095.png"></p><p>设置会话属性:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_090.png"></p><p>连接会话:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_091.png"></p><p>接受并保存:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_092.png"></p><p>输入、记住用户名:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_093.png"></p><p>输入、记住密码:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_094.png"></p><h2 id="第四章-Linux的文件和目录结构"><a href="#第四章-Linux的文件和目录结构" class="headerlink" title="第四章 Linux的文件和目录结构"></a>第四章 Linux的文件和目录结构</h2><h3 id="第一节-目录结构预览"><a href="#第一节-目录结构预览" class="headerlink" title="第一节 目录结构预览"></a>第一节 目录结构预览</h3><h4 id="1-查看目录结构"><a href="#1-查看目录结构" class="headerlink" title="1. 查看目录结构"></a>1. 查看目录结构</h4><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_096.png"></p><h4 id="2-目录结构列表"><a href="#2-目录结构列表" class="headerlink" title="2. 目录结构列表"></a>2. 目录结构列表</h4><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_097.png"></p><h3 id="第二节-目录结构中各个目录的介绍"><a href="#第二节-目录结构中各个目录的介绍" class="headerlink" title="第二节 目录结构中各个目录的介绍"></a>第二节 目录结构中各个目录的介绍</h3><ol><li>“/bin”: bin是Binary的缩写，这个目录存放着最经常使用的命令</li><li>“/sbin”: s表示Super User，这里存放的是系统管理员使用的系统管理程序</li><li>“/home”: 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li><li>“/root”: 该目录为系统管理员，也称作超级权限者的用户主目录。</li><li>“/lib”: 系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</li><li>“/lost+found”: 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li>“/etc”: 所有的系统管理所需要的配置文件和子目录。</li><li><strong>“/usr”</strong>: 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。</li><li>“/proc”: 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li><li>“/srv”: service缩写，该目录存放一些服务启动之后需要提取的数据。</li><li>“/sys”: 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。（内核）</li><li>“/tmp”: 这个目录是用来存放一些临时文件的。</li><li>“/dev”: Device(设备)的缩写,类似windows的设备管理器，把所有的硬件用文件的形式存储。</li><li>“/media”: linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。CentOS6 就在/media下,CentOS7换目录了/run/media/root/media</li><li>“/mnt”: 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</li><li><strong>“/opt”</strong>: 这是给主机额外安装软件所摆放的目录。比如你安装JDK、Tomcat则就可以放到这个目录下。默认是空的。</li><li><strong>“/usr/local”</strong>: 这是另一个给主机额外安装软件所摆放的目录.一般是通过编译源码方式安装的程序。</li><li>“/var”: 这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li><li>“/boot”: 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件，自己的安装别放这里</li></ol><h2 id="第五章-Linux常用命令"><a href="#第五章-Linux常用命令" class="headerlink" title="第五章 Linux常用命令"></a>第五章 Linux常用命令</h2><h3 id="第一节-一些常用基本命令"><a href="#第一节-一些常用基本命令" class="headerlink" title="第一节 一些常用基本命令"></a>第一节 一些常用基本命令</h3><h4 id="1-帮助文档"><a href="#1-帮助文档" class="headerlink" title="1. 帮助文档"></a>1. 帮助文档</h4><h5 id="1-1-man-manual-查看帮助手册"><a href="#1-1-man-manual-查看帮助手册" class="headerlink" title="1.1 man (manual 查看帮助手册)"></a>1.1 man (manual 查看帮助手册)</h5><p>例如<code>man ls</code>是查看ls相关的文档手册</p><h5 id="1-2-–help-提示使用方法"><a href="#1-2-–help-提示使用方法" class="headerlink" title="1.2 –help (提示使用方法)"></a>1.2 –help (提示使用方法)</h5><p>例如<code>ls --help</code>可以提示ls命令的相关使用方法</p><h4 id="2-日期时间类"><a href="#2-日期时间类" class="headerlink" title="2. 日期时间类"></a>2. 日期时间类</h4><h5 id="2-1-date-以不同的格式获取日期时间"><a href="#2-1-date-以不同的格式获取日期时间" class="headerlink" title="2.1 date: 以不同的格式获取日期时间"></a>2.1 date: 以不同的格式获取日期时间</h5><ol><li><p><code>date +%Y-%m-%d</code></p></li><li><p><code>date +%Y-%m-%d&#39;  &#39;%H:%M:%S</code></p></li><li><p><code>date +%F&#39; &#39;%T</code></p></li></ol><h5 id="2-2-cal-查看日历"><a href="#2-2-cal-查看日历" class="headerlink" title="2.2 cal:查看日历"></a>2.2 cal:查看日历</h5><p><code>cal -y</code></p><h4 id="3-清除屏幕"><a href="#3-清除屏幕" class="headerlink" title="3. 清除屏幕"></a>3. 清除屏幕</h4><h5 id="3-1-命令-clear"><a href="#3-1-命令-clear" class="headerlink" title="3.1 命令: clear"></a>3.1 命令: clear</h5><h5 id="3-2-快捷键-ctrl-L"><a href="#3-2-快捷键-ctrl-L" class="headerlink" title="3.2 快捷键: ctrl + L"></a>3.2 快捷键: ctrl + L</h5><h4 id="4-查看ip配置"><a href="#4-查看ip配置" class="headerlink" title="4. 查看ip配置"></a>4. 查看ip配置</h4><p><code>ifconfig</code></p><h4 id="5-查看命令历史"><a href="#5-查看命令历史" class="headerlink" title="5. 查看命令历史"></a>5. 查看命令历史</h4><p><code>history</code>命令可以查看所写过的命令历史</p><h4 id="6-关机重启"><a href="#6-关机重启" class="headerlink" title="6. 关机重启"></a>6. 关机重启</h4><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>sync</td><td>将内存数据保存到硬盘上</td></tr><tr><td>poweroff</td><td>关机</td></tr><tr><td>reboot</td><td>重启</td></tr></tbody></table><h4 id="7-下载文件"><a href="#7-下载文件" class="headerlink" title="7. 下载文件"></a>7. 下载文件</h4><p><code>wget</code>: </p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_114.png"></p><p>使用 -P 参数可以指定目标目录，例如：(不需要去演示) </p><pre><code>wget -P /root https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-10/v10.0.8/bin/apache-tomcat-10.0.8.tar.gz</code></pre><h4 id="8-常用快捷键"><a href="#8-常用快捷键" class="headerlink" title="8. 常用快捷键"></a>8. 常用快捷键</h4><table><thead><tr><th>按键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl+l</td><td>清屏</td></tr><tr><td>Ctrl+c</td><td>强制终止程序</td></tr><tr><td>Ctrl+Insert</td><td>复制</td></tr><tr><td>Shift+Insert</td><td>粘贴</td></tr><tr><td>Ctrl+s</td><td>锁屏</td></tr><tr><td>Ctrl+q</td><td>解除锁屏</td></tr><tr><td>tab</td><td>自动补全</td></tr></tbody></table><h3 id="第二节-文件目录命令"><a href="#第二节-文件目录命令" class="headerlink" title="第二节 文件目录命令"></a>第二节 文件目录命令</h3><h4 id="1-切换目录命令"><a href="#1-切换目录命令" class="headerlink" title="1 切换目录命令"></a>1 切换目录命令</h4><ol><li><code>cd ..</code>: 返回上级目录</li><li><code>cd /</code>: 返回到 / 目录</li><li><code>cd ~</code>：返回家目录，如果是root用户则返回<code>/root</code>，如果是普通用户则返回<code>/home/普通用户目录</code></li><li><code>cd 目录绝对路径</code>: 通过绝对路径切换到指定目录，可以借助tab键提示目录名</li><li><code>cd 目录相对路径</code>: 通过相对路径切换到指定目录</li><li><code>cd -</code>：切换到上一次操作所在的目录</li></ol><h4 id="2-打印当前目录的绝对路径"><a href="#2-打印当前目录的绝对路径" class="headerlink" title="2 打印当前目录的绝对路径"></a>2 打印当前目录的绝对路径</h4><p><code>pwd</code>命令: 此命令打印当前目录的绝对路径，pwd的全称是:<code>print wroking directory</code>打印工作目录，工作目录就是用户当前所在的目录</p><h4 id="3-列出目录中的文件"><a href="#3-列出目录中的文件" class="headerlink" title="3 列出目录中的文件"></a>3 列出目录中的文件</h4><ol><li><p><code>ls</code>: 列出当前目录中的文件名列表</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_098.png"></p></li><li><p><code>ls -l</code>可以简写成<code>ll</code>: 列出当前目录中的文件列表，包含文件的详细信息(其中文件大写用字节表示)</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_099.png"></p></li><li><p>h参数：<code>ll -h</code> 将文件大小使用kb显示</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_100.png"></p></li><li><p>a参数: <code>ll -ah</code>显示目录中的所有文件,包含隐藏文件。注意: a和h都是参数，他俩的顺序可以换</p></li><li><p><code>ll 某个目录的绝对路径或者某个目录的相对路径</code>: 列出指定目录下的文件详情列表</p></li><li><p>R参数: <code>ll -R</code>递归查看某个目录以及其子孙后代目录中的所有文件</p></li><li><p><code>ll -ltr</code>: 逆序列出最近修改过的文件</p></li></ol><h4 id="4-创建和删除目录"><a href="#4-创建和删除目录" class="headerlink" title="4 创建和删除目录"></a>4 创建和删除目录</h4><ol><li><code>mkdir 目录路径</code>：创建新目录，例如<code>mkdir /usr/local/tomcat</code>，表示在<code>/usr/local</code>中创建tomcat目录，但是前提是<code>/root/usr/local</code>目录已存在</li><li><code>mkdir -p 目录路径</code>: 创建新目录，可以创建多级目录，例如<code>mkdir -p /root/aa/bb/cc</code>,表示在<code>/root</code>目录中先创建<code>aa</code>目录，然后在<code>aa</code>目录中创建<code>bb</code>目录，在<code>bb</code>目录中创建<code>cc</code>目录</li><li><code>rmdir 目录路径</code>: 删除一个目录，当然:该命令只能删除一个空目录</li></ol><h4 id="5-创建和删除文件"><a href="#5-创建和删除文件" class="headerlink" title="5 创建和删除文件"></a>5 创建和删除文件</h4><ol><li><code>touch 文件路径</code>: 新创建一个文件</li><li><code>rm 文件路径</code>: 删除指定文件，会询问<code>是否删除</code></li><li>f参数: <code>rm -f 文件路径</code>: 删除文件，不会询问<code>是否删除</code></li><li>r参数:递归删除，<code>rm -rf 非空目录路径</code>:递归删除非空目录</li></ol><h4 id="6-移动文件或目录"><a href="#6-移动文件或目录" class="headerlink" title="6 移动文件或目录"></a>6 移动文件或目录</h4><ol><li><code>mv 要移动的文件或目录路径 目标路径</code>: 将要移动的文件移动到目标路径</li><li><code>mv 旧文件或目录名 新文件或目录名</code>: 对文件进行重命名</li></ol><h4 id="7-复制文件或目录"><a href="#7-复制文件或目录" class="headerlink" title="7 复制文件或目录"></a>7 复制文件或目录</h4><ol><li><code>cp 要复制的文件 目标路径</code>: 将要复制的文件复制到目标路径</li><li>r参数: <code>cp -r 要复制的目录 目标路径</code>: 将目录以及目录中的所有内容都复制到目标路径</li><li>强制覆盖的复制: 如果目标目录中已经有了该文件，那么就采用强制覆盖的复制，例如<code>\cp -rf a /test</code>表示将a复制到/test目录中，并且进行覆盖</li></ol><h4 id="8-查看文件"><a href="#8-查看文件" class="headerlink" title="8 查看文件"></a>8 查看文件</h4><h5 id="8-1-cat命令"><a href="#8-1-cat命令" class="headerlink" title="8.1 cat命令"></a>8.1 cat命令</h5><ol><li><code>cat 文件路径</code>:查看轻量级的文本文件</li><li><code>cat 文件1路径 文件2路径</code>: 连接查看多个文件</li><li><code>cat 文件1 &gt; 文件2</code>:将文件1的内容覆盖文件2的内容</li><li><code>cat 文件1 &gt;&gt; 文件2</code>:将在文件2的内容后面追加文件1的内容</li></ol><h5 id="8-2-more命令"><a href="#8-2-more命令" class="headerlink" title="8.2 more命令"></a>8.2 more命令</h5><p><code>more 文件路径</code>:查看较长的文件，可以使用空格键向下翻页，使用回车键向下翻行，使用q退出查看，使用<code>Ctrl + F</code>向下滚动一屏，使用<code>Ctrl + B</code>返回上一屏</p><h5 id="8-3-less命令"><a href="#8-3-less命令" class="headerlink" title="8.3 less命令"></a>8.3 less命令</h5><p><code>less 文件路径</code>：查看较长的文件，功能比<code>more</code>强大，可以使用<code>PgUp</code>和<code>PgDn</code>向上和向下翻页，可以使用<code>/字符串</code>向下搜索<code>字符串</code>，使用<code>?字符串</code>向上搜索字符串，使用<code>n</code>正向重复前一个搜索(与/和?搜索有关)，使用<code>N</code>反向重复前一个搜索</p><h5 id="8-4-tail命令"><a href="#8-4-tail命令" class="headerlink" title="8.4 tail命令"></a>8.4 tail命令</h5><ol><li><code>tail -数字 文件路径</code>: 查看指定文件的末尾多少行</li><li><code>tail -数字f 文件路径</code>: 查看文件末尾多少行，可进行堵塞，文件有新内容增加到文件中，立刻可以显示，适合查看Tomcat的运行日志</li></ol><h4 id="9-打印信息"><a href="#9-打印信息" class="headerlink" title="9 打印信息"></a>9 打印信息</h4><p>相当于Java中的日志打印，例如<code>echo $path</code>打印<code>path</code>环境变量信息</p><h4 id="10-查找文件或目录"><a href="#10-查找文件或目录" class="headerlink" title="10 查找文件或目录"></a>10 查找文件或目录</h4><p><code>find</code>命令是用于在某个范围内查找文件或者目录，它的用法是<code>find 查找范围 参数 表达式</code>，例如:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_101.png"></p><p>这次查询表示的意思是:</p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_102.png" style="zoom:80%;"><h4 id="11-基于索引查找文件或者目录"><a href="#11-基于索引查找文件或者目录" class="headerlink" title="11 基于索引查找文件或者目录"></a>11 基于索引查找文件或者目录</h4><h5 id="11-1-什么是索引"><a href="#11-1-什么是索引" class="headerlink" title="11.1 什么是索引"></a>11.1 什么是索引</h5><p>建立索引可以极大提升查询的速度。为什么会有这么显著的效果呢？我们拿查字典来举个例子。</p><ul><li>没有索引：从正文第一页开始翻，在每一页中检查有没有自己要找的字。在最差的情况下需要逐页翻到字典的最后一页，这样做速度非常慢。</li><li>基于索引：字典正文前的检字表就是正文内容的索引。先从检字表里快速找到那个字，这里没有这个字的详细信息，只有这个字所在的页码。我们根据这个页码就可以直接到正文中直接翻到那一页，这样速度就非常快了。</li></ul><h5 id="11-2-locate命令的原理"><a href="#11-2-locate命令的原理" class="headerlink" title="11.2 locate命令的原理"></a>11.2 locate命令的原理</h5><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_103.png"></p><p>系统启动时把每一个目录、每一个文件的完整路径保存到索引库中。使用locate命令搜索关键词时，就使用关键词查询索引库，把匹配的路径字符串返回。</p><p>而新建的文件或目录不会被系统把路径存入索引库，那么使用locate命令就搜索不到。此时使用updatedb命令更新一下索引库就行了。</p><h5 id="11-3-locate命令的使用"><a href="#11-3-locate命令的使用" class="headerlink" title="11.3 locate命令的使用"></a>11.3 locate命令的使用</h5><ol><li><code>locate 关键字</code>:全文搜索与关键字相关的文件或者目录</li><li>新建文件之后使用<code>updatedb</code>更新索引库，然后再搜索</li></ol><h4 id="12-grep"><a href="#12-grep" class="headerlink" title="12 grep"></a>12 grep</h4><h5 id="12-1-管道筛选"><a href="#12-1-管道筛选" class="headerlink" title="12.1 管道筛选"></a>12.1 管道筛选</h5><p><code>grep</code>配合进行管道筛选，例如<code>ll /etc | grep .cfg</code>表示筛选<code>/etc</code>目录中包含<code>.cfg</code>的文件，对于管道筛选而言<code>|</code>前面的表示数据源(需要从数据源中筛选)，<code>| grep</code>后面表示筛选条件</p><h5 id="12-2-在文本文件中根据关键字匹配行"><a href="#12-2-在文本文件中根据关键字匹配行" class="headerlink" title="12.2 在文本文件中根据关键字匹配行"></a>12.2 在文本文件中根据关键字匹配行</h5><h6 id="12-2-1-基本用法"><a href="#12-2-1-基本用法" class="headerlink" title="12.2.1 基本用法"></a>12.2.1 基本用法</h6><p><code>grep 参数 关键字 被搜索的文件</code>:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_104.png"></p><p>上述语句表示在当前目录的content.txt文件中搜索包含<strong>Spring</strong>的所有行</p><h6 id="12-2-2-参数"><a href="#12-2-2-参数" class="headerlink" title="12.2.2 参数"></a>12.2.2 参数</h6><ol><li><p><code>n</code>表示在搜索结果中显示行号:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_105.png"></p></li><li><p><code>v</code>表示返回不匹配关键字的那些行</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_106.png"></p></li></ol><h4 id="13-压缩和解压"><a href="#13-压缩和解压" class="headerlink" title="13 压缩和解压"></a>13 压缩和解压</h4><h5 id="13-1-gz格式的压缩文件"><a href="#13-1-gz格式的压缩文件" class="headerlink" title="13.1 gz格式的压缩文件"></a>13.1 gz格式的压缩文件</h5><p>在Linux系统环境中，很多程序安装包都是以tar包的形式提供下载的： </p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_107.png"></p><h6 id="13-1-1-压缩"><a href="#13-1-1-压缩" class="headerlink" title="13.1.1 压缩"></a>13.1.1 压缩</h6><ul><li><p>语法：<code>tar -zcvf 压缩包 文件1 文件2 ...</code></p></li><li><p>参数：</p><ul><li><code>z</code>：指定压缩算法为gzip</li><li><code>c</code>：压缩后要创建压缩文件</li><li><code>v</code>：在压缩过程中列出文件列表(可以不写)</li><li><code>f</code>：指定压缩包文件名称。后边跟参数值：压缩包名称</li></ul></li></ul><p>例如<code>tar  -zcvf  demo.tar.gz  *.txt</code>表示将当前目录中的所有<code>txt</code>文件压缩成<code>demo.tar.gz</code></p><h6 id="13-1-2-解压"><a href="#13-1-2-解压" class="headerlink" title="13.1.2 解压"></a>13.1.2 解压</h6><ul><li>语法：<code>tar -zxvf 压缩包 -C 解压位置</code></li><li>参数：<ul><li><code>z</code>: 表示使用<code>gzip</code>算法解压</li><li><code>x</code>：extract, 调用解压命令，执行解压操作</li><li><code>v</code>：在解压缩过程中列出文件列表(可以不写)</li><li><code>f</code>：指定要解压的文件名称。后边跟参数值：压缩包名称</li><li><code>C</code>：指定解压的位置（可以不写）<ul><li>如果写参数<code>C</code>：就需要指定解压的位置，必须是已经存在的文件夹</li><li>如果不写参数<code>C</code>：要解压到当前文件夹里</li></ul></li></ul></li></ul><p>例如<code>tar -xvf demo.tar.gz</code>表示将<code>demo.tar.gz</code>文件解压到当前目录；<code>tar -xvf demo.tar.gz -C /root/app</code>表示将<code>demo.tar.gz</code>解压到<code>/root/app</code>目录中</p><h5 id="13-2-zip格式的压缩文件-了解"><a href="#13-2-zip格式的压缩文件-了解" class="headerlink" title="13.2 zip格式的压缩文件(了解)"></a>13.2 zip格式的压缩文件(了解)</h5><p>Linux中一般不会使用zip格式的压缩文件，但是如果需要，我们也有命令对zip格式的压缩文件进行解压、以及将文件压缩成zip格式</p><h6 id="13-2-1-压缩"><a href="#13-2-1-压缩" class="headerlink" title="13.2.1 压缩"></a>13.2.1 压缩</h6><p><code>zip demo.zip *.txt</code>表示将当前目录中的所有<code>txt</code>文件压缩到<code>demo.zip</code>中</p><h6 id="13-2-2-解压"><a href="#13-2-2-解压" class="headerlink" title="13.2.2 解压"></a>13.2.2 解压</h6><p><code>unzip demo.zip</code>表示将<code>demo.zip</code>解压到当前目录</p><h3 id="第三节-文件编辑"><a href="#第三节-文件编辑" class="headerlink" title="第三节 文件编辑"></a>第三节 文件编辑</h3><h4 id="1-Linux的文件编辑器"><a href="#1-Linux的文件编辑器" class="headerlink" title="1. Linux的文件编辑器"></a>1. Linux的文件编辑器</h4><p><code>vim</code>是Linux中重要的文本编辑器，我们使用<code>vim</code>可以在Linux中编辑文件，<code>vim</code>可以看做是之前<code>vi</code>编辑器的升级版本</p><h4 id="2-文件编辑过程中的三种模式"><a href="#2-文件编辑过程中的三种模式" class="headerlink" title="2. 文件编辑过程中的三种模式"></a>2. 文件编辑过程中的三种模式</h4><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_108.png"></p><p>一般模式(无法编辑)：通过按键控制VIM工作</p><p>编辑模式(可以编辑无法保存)：可以自由输入</p><p>指令模式(可以执行保存、查找等操作)：通过执行指令完成一些特殊操作</p><h4 id="3-一般模式下的按键操作"><a href="#3-一般模式下的按键操作" class="headerlink" title="3. 一般模式下的按键操作"></a>3. 一般模式下的按键操作</h4><p><code>vim 要编辑的文件路径</code>可以进入到<strong>一般模式</strong>,此时我们无法自由编辑文件，但是可以进行整行的复制、粘贴、删除</p><ul><li><code>yy</code>复制光标所在行</li><li><code>p</code>在下方粘贴一行</li><li><code>dd</code>删除光标所在行</li><li><code>u</code>撤销前一步操作</li><li><code>Ctrl + r</code>重做刚刚撤销的操作</li><li><code>r</code> 替换光标所在位置的一个字符，第一步：按一下r键，第二步：输入新的字符 </li><li><code>gg</code>将光标移动到第一行的开头</li><li><code>G</code>将光标移动到最后一行的开头</li><li><code>行数G</code>将光标移动到指定行的开头</li></ul><h4 id="4-进入编辑模式"><a href="#4-进入编辑模式" class="headerlink" title="4. 进入编辑模式"></a>4. 进入编辑模式</h4><p>因为一般模式下我们无法自由编辑内容，所以需要进入编辑模式来进行文件的编辑，进入编辑模式的方式有如下一些:</p><table><thead><tr><th>按键</th><th>大小写 说明</th><th>光标动作</th></tr></thead><tbody><tr><td>i</td><td>小写</td><td>不动，就在<strong>当前位置</strong>，开始输入</td></tr><tr><td>I</td><td>大写</td><td>移动到<strong>行的开头</strong>，开始输入</td></tr><tr><td>a</td><td>小写</td><td>光标<strong>向后移动一格</strong>，然后开始输入</td></tr><tr><td>A</td><td>大写</td><td>光标移动到<strong>行的末尾</strong>，然后开始输入</td></tr><tr><td>o</td><td>小写</td><td>先在光标所在行的<strong>下面插入空行</strong> 然后把光标移动到空行的开头，再开始输入</td></tr></tbody></table><p>在编辑模式下我们可以进行自由编辑，如果想回退到普通模式进行操作，则需要按<code>Esc</code>按键，编辑模式下我们无法进行查找、保存等等操作，需要进入指令模式才能完成。而进入指令模式需要从一般模式进入，所以需要先<code>Esc</code>退回一般模式</p><h4 id="5-指令模式下的操作"><a href="#5-指令模式下的操作" class="headerlink" title="5. 指令模式下的操作"></a>5. 指令模式下的操作</h4><h5 id="5-1-进入指令模式"><a href="#5-1-进入指令模式" class="headerlink" title="5.1 进入指令模式"></a>5.1 进入指令模式</h5><h6 id="5-1-1-进入特殊指令操作的指令模式"><a href="#5-1-1-进入特殊指令操作的指令模式" class="headerlink" title="5.1.1 进入特殊指令操作的指令模式"></a>5.1.1 进入特殊指令操作的指令模式</h6><p>在一般模式下输入英文的<code>:</code>，其实就是同时按<code>Shift</code>和<code>:</code>就可以看到文档最下方出现了一个<code>:</code>，并且光标也出现在了<code>:</code>后面，就表示进入了指令模式，此时我们就可以输入指令进行一些操作</p><h6 id="5-1-2-进入用于全文搜索的指令模式"><a href="#5-1-2-进入用于全文搜索的指令模式" class="headerlink" title="5.1.2 进入用于全文搜索的指令模式"></a>5.1.2 进入用于全文搜索的指令模式</h6><p>在一般模式下输入<code>/</code>，可以进入用于全文搜索的指令模式</p><h5 id="5-2-在全文搜索的指令模式下进行搜索"><a href="#5-2-在全文搜索的指令模式下进行搜索" class="headerlink" title="5.2 在全文搜索的指令模式下进行搜索"></a>5.2 在全文搜索的指令模式下进行搜索</h5><h6 id="5-2-1-搜索的具体步骤"><a href="#5-2-1-搜索的具体步骤" class="headerlink" title="5.2.1 搜索的具体步骤"></a>5.2.1 搜索的具体步骤</h6><ol><li>在<code>/</code>的光标处输入搜索关键字，然后按回车按钮进行搜索，搜索出来匹配关键字部分的内容，会高亮显示</li><li>遍历匹配内容: 输入<code>n</code>向下遍历查找，输入<code>N</code>向上遍历查找</li><li>取消高亮显示: <code>:noh</code></li></ol><h5 id="5-3-指令模式下常用的指令操作"><a href="#5-3-指令模式下常用的指令操作" class="headerlink" title="5.3 指令模式下常用的指令操作"></a>5.3 指令模式下常用的指令操作</h5><h6 id="5-3-1-显示行号"><a href="#5-3-1-显示行号" class="headerlink" title="5.3.1 显示行号"></a>5.3.1 显示行号</h6><p><code>set nu</code>指令可以显示文本的行号</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_109.png"></p><h6 id="5-3-2-保存已编辑的内容"><a href="#5-3-2-保存已编辑的内容" class="headerlink" title="5.3.2 保存已编辑的内容"></a>5.3.2 保存已编辑的内容</h6><p><code>w</code>指令可以保存已编辑的内容</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_110.png"></p><h6 id="5-3-3-退出vim编辑器"><a href="#5-3-3-退出vim编辑器" class="headerlink" title="5.3.3 退出vim编辑器"></a>5.3.3 退出vim编辑器</h6><p><code>q</code>指令可以退出vim编辑，但是当部分修改还没有保存，那么会看到下面的提示： </p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_111.png"></p><p>当我们想要放弃对文件的修改，不保存直接退出就使用:<code>q! </code>来代替<code>q</code>进行退出</p><h6 id="5-3-4-保存当前编辑并退出"><a href="#5-3-4-保存当前编辑并退出" class="headerlink" title="5.3.4 保存当前编辑并退出"></a>5.3.4 保存当前编辑并退出</h6><p><code>wq</code>指令可以先保存当前编辑的内容，然后再退出vim编辑器</p><h6 id="5-3-5-全文替换"><a href="#5-3-5-全文替换" class="headerlink" title="5.3.5 全文替换"></a>5.3.5 全文替换</h6><ol><li>准备文本内容</li></ol><pre><code class="tex">TIPOh,hello tom!Do you think this is a good time for me to say hello to Lily?Oh,hello tom!Do you think this is a good time for me to say hello to Lily?Oh,hello tom!Do you think this is a good time for me to say hello to Lily?Oh,hello tom!Do you think this is a good time for me to say hello to Lily?Oh,hello tom!Do you think this is a good time for me to say hello to Lily?Oh,hello tom!Do you think this is a good time for me to say hello to Lily?Oh,hello tom!Do you think this is a good time for me to say hello to Lily?Oh,hello tom!Do you think this is a good time for me to say hello to Lily?Oh,hello tom!Do you think this is a good time for me to say hello to Lily?</code></pre><p>执行替换:将<code>hello</code>替换成<code>hi</code>:</p><p><code>%s/hello/hi</code>,替换后的效果是:</p><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_112.png"></p><p>这时我们看到每一行只有第一个匹配的内容被替换了，后面的没有被替换。这是因为对正则表达式来说，它是以行为单位查找匹配的内容。每一行只要找到第一个匹配那么就可以判断这一行就是匹配的，没有必要继续向后查找了。如果我们需要将一行中的每一个匹配都替换，可以在指令后加/g </p><h4 id="6-常见的问题"><a href="#6-常见的问题" class="headerlink" title="6. 常见的问题"></a>6. 常见的问题</h4><h5 id="6-1-提示存在交换文件"><a href="#6-1-提示存在交换文件" class="headerlink" title="6.1 提示存在交换文件"></a>6.1 提示存在交换文件</h5><h6 id="6-1-1-错误示例"><a href="#6-1-1-错误示例" class="headerlink" title="6.1.1 错误示例"></a>6.1.1 错误示例</h6><p><img src="http://www.slx.blue/2021/12/16/Linux-01/tu_113.png"></p><h6 id="6-1-2-错误原因"><a href="#6-1-2-错误原因" class="headerlink" title="6.1.2 错误原因"></a>6.1.2 错误原因</h6><p>vim在打开一个文件的时候会同时创建一个临时文件，命名方式是“.原文件名.swp”，这就是所谓的<strong>交换文件</strong>。而当vim正常退出时，这个交换文件会被删除。所以如果正常操作我们是看不到这个提示界面的。</p><p>而之所以会出现上面的提示，是因为当前的vim命令在创建新的交换文件之前就已经检测到了<strong>已存在的交换文件</strong>。</p><p>再往前推理一步，为什么会有交换文件残留？</p><ul><li>可能原因1：其他窗口正在使用vim打开同一个文件</li><li>可能原因2：非正常关机等原因导致vim没有正常退出</li></ul><h6 id="6-1-3-解决方法"><a href="#6-1-3-解决方法" class="headerlink" title="6.1.3 解决方法"></a>6.1.3 解决方法</h6><p>先根据最下面的提示输入Q退出，然后检查是否在其他窗口已经用vim打开了这个文件：</p><ul><li>是：继续在这个vim中编辑文件。</li><li>否：删除交换文件，重新编辑。</li></ul><h5 id="6-2-屏幕被锁"><a href="#6-2-屏幕被锁" class="headerlink" title="6.2 屏幕被锁"></a>6.2 屏幕被锁</h5><p>在Windows环境下大家已经习惯了使用Ctrl+s保存文档，但是在Linux环境下Ctrl+s是锁屏。如果是因为Ctrl+s锁屏那么可以使用Ctrl+q解锁，然后继续操作。 </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springMVC-03</title>
      <link href="/2021/12/13/springMVC-03/"/>
      <url>/2021/12/13/springMVC-03/</url>
      
        <content type="html"><![CDATA[<h1 id="springmvc-day03"><a href="#springmvc-day03" class="headerlink" title="springmvc-day03"></a>springmvc-day03</h1><h2 id="第一章-拦截器-重点"><a href="#第一章-拦截器-重点" class="headerlink" title="第一章 拦截器(重点)"></a>第一章 拦截器(重点)</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><h4 id="1-1-使用场景"><a href="#1-1-使用场景" class="headerlink" title="1.1 使用场景"></a>1.1 使用场景</h4><h5 id="1-1-1-生活中坐地铁的场景"><a href="#1-1-1-生活中坐地铁的场景" class="headerlink" title="1.1.1 生活中坐地铁的场景"></a>1.1.1 生活中坐地铁的场景</h5><p>为了提高乘车效率，在乘客进入站台前统一检票： </p><p><img src="http://www.slx.blue/2021/12/13/springMVC-03/tu_001.png"></p><h5 id="1-1-2-程序中的校验登录场景"><a href="#1-1-2-程序中的校验登录场景" class="headerlink" title="1.1.2 程序中的校验登录场景"></a>1.1.2 程序中的校验登录场景</h5><p>在程序中，使用拦截器在请求到达具体 handler 方法前，统一执行检测。 </p><p><img src="http://www.slx.blue/2021/12/13/springMVC-03/tu_002.png"></p><h4 id="1-2-拦截器与过滤器的对比"><a href="#1-2-拦截器与过滤器的对比" class="headerlink" title="1.2 拦截器与过滤器的对比"></a>1.2 拦截器与过滤器的对比</h4><h5 id="1-2-1-相同点"><a href="#1-2-1-相同点" class="headerlink" title="1.2.1 相同点"></a>1.2.1 相同点</h5><p>三要素相同</p><ul><li>拦截(配置拦截路径)：必须先把请求拦住，才能执行后续操作</li><li>过滤(根据某种规则/业务逻辑进行筛选)：拦截器或过滤器存在的意义就是对请求进行统一处理</li><li>放行(满足规则/筛选条件，就让你访问你想访问的资源)：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源</li></ul><h5 id="1-2-2-不同点"><a href="#1-2-2-不同点" class="headerlink" title="1.2.2 不同点"></a>1.2.2 不同点</h5><ul><li>工作平台不同<ul><li>过滤器工作在 Servlet 容器中</li><li>拦截器工作在 SpringMVC 的基础上</li></ul></li><li>拦截的范围<ul><li>过滤器：能够拦截到的最大范围是整个 Web 应用</li><li>拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求(handler方法、view-controller跳转页面)</li></ul></li><li>IOC 容器支持<ul><li>过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的</li><li>拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC 容器中装配组件，也就是可以直接得到 IOC 容器的支持</li></ul></li></ul><h3 id="2-具体使用"><a href="#2-具体使用" class="headerlink" title="2. 具体使用"></a>2. 具体使用</h3><h4 id="2-1-创建拦截器类"><a href="#2-1-创建拦截器类" class="headerlink" title="2.1 创建拦截器类"></a>2.1 创建拦截器类</h4><pre><code class="java">public class Process01Interceptor implements HandlerInterceptor &#123;     Logger logger = LoggerFactory.getLogger(this.getClass());     // 在处理请求的目标 handler 方法前执行    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;                logger.debug(&quot;Process01Interceptor preHandle方法&quot;);                 // 返回true：放行        // 返回false：不放行        return true;    &#125;     // 在目标 handler 方法之后，渲染视图之前    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;         logger.debug(&quot;Process01Interceptor postHandle方法&quot;);            &#125;     // 渲染视图之后执行    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;                logger.debug(&quot;Process01Interceptor afterCompletion方法&quot;);            &#125;&#125;</code></pre><p><strong>单个拦截器执行顺序</strong>：</p><ul><li>preHandle() 方法</li><li>目标 handler 方法</li><li>postHandle() 方法</li><li>渲染视图</li><li>afterCompletion() 方法</li></ul><h4 id="2-2-注册拦截器"><a href="#2-2-注册拦截器" class="headerlink" title="2.2 注册拦截器"></a>2.2 注册拦截器</h4><h5 id="2-2-1-默认拦截全部请求"><a href="#2-2-1-默认拦截全部请求" class="headerlink" title="2.2.1 默认拦截全部请求"></a>2.2.1 默认拦截全部请求</h5><pre><code class="xml">&lt;!-- 注册拦截器 --&gt;&lt;mvc:interceptors&gt;     &lt;!-- 直接通过内部 bean 配置的拦截器默认拦截全部请求（SpringMVC 范围内） --&gt;    &lt;bean class=&quot;com.atguigu.interceptor.Demo01Interceptor&quot;/&gt;&lt;/mvc:interceptors&gt;</code></pre><h5 id="2-2-2-配置拦截路径"><a href="#2-2-2-配置拦截路径" class="headerlink" title="2.2.2 配置拦截路径"></a>2.2.2 配置拦截路径</h5><h6 id="2-2-2-1-精确匹配"><a href="#2-2-2-1-精确匹配" class="headerlink" title="2.2.2.1 精确匹配"></a>2.2.2.1 精确匹配</h6><pre><code class="xml">&lt;!-- 具体配置拦截器可以指定拦截的请求地址 --&gt;&lt;mvc:interceptor&gt;    &lt;!-- 精确匹配 --&gt;    &lt;mvc:mapping path=&quot;/hello/sayHello&quot;/&gt;    &lt;bean class=&quot;com.atguigu.interceptor.Demo01Interceptor&quot;/&gt;&lt;/mvc:interceptor&gt;</code></pre><h6 id="2-2-2-2-模糊匹配：匹配单层路径"><a href="#2-2-2-2-模糊匹配：匹配单层路径" class="headerlink" title="2.2.2.2 模糊匹配：匹配单层路径"></a>2.2.2.2 模糊匹配：匹配单层路径</h6><pre><code class="xml">&lt;mvc:interceptor&gt;    &lt;!-- /*匹配路径中的一层 --&gt;    &lt;mvc:mapping path=&quot;/hello/*&quot;/&gt;    &lt;bean class=&quot;com.atguigu.interceptor.Demo01Interceptor&quot;/&gt;&lt;/mvc:interceptor&gt;</code></pre><h6 id="2-2-2-3-模糊匹配：匹配多层路径"><a href="#2-2-2-3-模糊匹配：匹配多层路径" class="headerlink" title="2.2.2.3 模糊匹配：匹配多层路径"></a>2.2.2.3 模糊匹配：匹配多层路径</h6><pre><code class="xml">&lt;mvc:interceptor&gt;    &lt;!--模糊匹配多级目录--&gt;    &lt;mvc:mapping path=&quot;/hello/**&quot;/&gt;    &lt;!--排除--&gt;    &lt;mvc:exclude-mapping path=&quot;/hello/sayHello&quot;/&gt;    &lt;bean class=&quot;com.atguigu.interceptor.Demo01Interceptor&quot;/&gt;&lt;/mvc:interceptor&gt;</code></pre><h4 id="2-3-多个拦截器执行顺序"><a href="#2-3-多个拦截器执行顺序" class="headerlink" title="2.3 多个拦截器执行顺序"></a>2.3 多个拦截器执行顺序</h4><ul><li>preHandle()方法：和配置的顺序一样</li><li>目标handler方法</li><li>postHandle()方法：和配置的顺序相反</li><li>渲染视图</li><li>afterCompletion()方法：和配置的顺序相反</li></ul><h2 id="第二章-类型转换"><a href="#第二章-类型转换" class="headerlink" title="第二章 类型转换"></a>第二章 类型转换</h2><p>SpringMVC 将『把请求参数注入到 POJO 对象』这个操作称为<strong>『数据绑定』</strong>，英文单词是 binding。数据类型的转换和格式化就发生在数据绑定的过程中。 类型转换和格式化是密不可分的两个过程，很多带格式的数据必须明确指定格式之后才可以进行类型转换。最典型的就是日期类型。 </p><h3 id="1-自动类型转换"><a href="#1-自动类型转换" class="headerlink" title="1. 自动类型转换"></a>1. 自动类型转换</h3><p>HTTP 协议是一个无类型的协议，我们在服务器端接收到请求参数等形式的数据时，本质上都是字符串类型。请看 javax.servlet.ServletRequest 接口中获取全部请求参数的方法：</p><pre><code class="java">public Map&lt;String, String[]&gt; getParameterMap();</code></pre><p>而我们在实体类当中需要的类型是非常丰富的。对此，SpringMVC 对基本数据类型提供了自动的类型转换。例如：请求参数传入“100”字符串，我们实体类中需要的是 Integer 类型，那么 SpringMVC 会自动将字符串转换为 Integer 类型注入实体类。</p><h3 id="2-日期和数值类型转换"><a href="#2-日期和数值类型转换" class="headerlink" title="2. 日期和数值类型转换"></a>2. 日期和数值类型转换</h3><h4 id="2-1-通过注解设定数据格式"><a href="#2-1-通过注解设定数据格式" class="headerlink" title="2.1 通过注解设定数据格式"></a>2.1 通过注解设定数据格式</h4><pre><code class="java">package com.atguigu.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.springframework.format.annotation.DateTimeFormat;import org.springframework.format.annotation.NumberFormat;import java.util.Date;/** * 包名:com.atguigu.pojo * * @author Leevi * 日期2021-09-07  11:26 * SpringMVC提供了一些注解，可以让我们进行一些手动类型转换 * 1. DateTimeFormat注解:可以对日期时间类型进行转换 * 2. NumberFormat注解:可以对数值类型进行转换 */@Data@AllArgsConstructor@NoArgsConstructorpublic class Product &#123;    @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)    private Date productDate;    @NumberFormat(pattern = &quot;###,###,###.###&quot;)    private Double productPrice;&#125;</code></pre><h4 id="2-2-前端表单"><a href="#2-2-前端表单" class="headerlink" title="2.2 前端表单"></a>2.2 前端表单</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;首页&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form action=&quot;/springmvcday0303/hello/saveProduct&quot; method=&quot;post&quot;&gt;            生产日期：&lt;input type=&quot;text&quot; name=&quot;productDate&quot; value=&quot;1992-10-15 17:15:06&quot; /&gt;&lt;br/&gt;            产品价格：&lt;input type=&quot;text&quot; name=&quot;productPrice&quot; value=&quot;111,222,333.444&quot; /&gt;&lt;br/&gt;            &lt;button type=&quot;submit&quot;&gt;保存&lt;/button&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="2-3-handler-方法"><a href="#2-3-handler-方法" class="headerlink" title="2.3 handler 方法"></a>2.3 handler 方法</h4><pre><code class="java">@RequestMapping(&quot;/saveProduct&quot;)public String saveProduct(Product product)&#123;    logger.debug(product.toString());    return &quot;target&quot;;&#125;</code></pre><h4 id="2-4-转换失败后处理方式"><a href="#2-4-转换失败后处理方式" class="headerlink" title="2.4 转换失败后处理方式"></a>2.4 转换失败后处理方式</h4><h5 id="2-4-1-默认结果"><a href="#2-4-1-默认结果" class="headerlink" title="2.4.1 默认结果"></a>2.4.1 默认结果</h5><p><img src="http://www.slx.blue/2021/12/13/springMVC-03/tu_003.png"></p><h5 id="2-4-2-BindingResult-接口"><a href="#2-4-2-BindingResult-接口" class="headerlink" title="2.4.2 BindingResult 接口"></a>2.4.2 BindingResult 接口</h5><p>BindingResult 接口和它的父接口 Errors 中定义了很多和数据绑定相关的方法，如果在数据绑定过程中发生了错误，那么通过这个接口类型的对象就可以获取到相关错误信息。 </p><p><img src="http://www.slx.blue/2021/12/13/springMVC-03/tu_004.png"></p><h5 id="2-4-3-重构-handler-方法"><a href="#2-4-3-重构-handler-方法" class="headerlink" title="2.4.3 重构 handler 方法"></a>2.4.3 重构 handler 方法</h5><pre><code class="java">@RequestMapping(&quot;/saveProduct&quot;)public String saveProduct(Product product, BindingResult bindingResult)&#123;    if (bindingResult.hasErrors()) &#123;        //跳转到错误页面:显示错误数据        return &quot;error&quot;;    &#125;    logger.debug(product.toString());    return &quot;target&quot;;&#125;</code></pre><h5 id="2-4-4-在页面上显示错误消息"><a href="#2-4-4-在页面上显示错误消息" class="headerlink" title="2.4.4 在页面上显示错误消息"></a>2.4.4 在页面上显示错误消息</h5><p>页面是error.html，放在Thymeleaf前后缀控制范围之内</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 从请求域获取实体类信息时，属性名是按照类名首字母小写的规则 --&gt;        &lt;!-- $&#123;注入请求参数的实体类.出问题的字段&#125; --&gt;        &lt;p th:errors=&quot;$&#123;product.productDate&#125;&quot;&gt;这里显示具体错误信息&lt;/p&gt;        &lt;p th:errors=&quot;$&#123;product.productPrice&#125;&quot;&gt;这里显示具体错误信息&lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="3-自定义类型转换器"><a href="#3-自定义类型转换器" class="headerlink" title="3. 自定义类型转换器"></a>3. 自定义类型转换器</h3><h4 id="3-1-创建实体类"><a href="#3-1-创建实体类" class="headerlink" title="3.1 创建实体类"></a>3.1 创建实体类</h4><h5 id="3-1-1-Address"><a href="#3-1-1-Address" class="headerlink" title="3.1.1 Address"></a>3.1.1 Address</h5><pre><code class="java">@Data@AllArgsConstructor@NoArgsConstructorpublic class Address &#123;    private String province;    private String city;    private String street;&#125;</code></pre><h5 id="3-1-2-Student"><a href="#3-1-2-Student" class="headerlink" title="3.1.2 Student"></a>3.1.2 Student</h5><pre><code class="java">@Data@AllArgsConstructor@NoArgsConstructorpublic class Product &#123;    @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)    private Date productDate;    @NumberFormat(pattern = &quot;###,###,###.###&quot;)    private Double productPrice;    private Address productAddress;&#125;</code></pre><h4 id="3-2-表单"><a href="#3-2-表单" class="headerlink" title="3.2 表单"></a>3.2 表单</h4><p>现在我们希望通过一个文本框输入约定格式的字符串，然后转换为我们需要的类型，所以必须通过自定义类型转换器来实现，否则 SpringMVC 无法识别。 </p><pre><code class="html">&lt;form action=&quot;/springmvcday0303/hello/saveProduct&quot; method=&quot;post&quot;&gt;    生产日期：&lt;input type=&quot;text&quot; name=&quot;productDate&quot; value=&quot;1992-10-15 17:15:06&quot; /&gt;&lt;br/&gt;    产品价格：&lt;input type=&quot;text&quot; name=&quot;productPrice&quot; value=&quot;111,222,333.444&quot; /&gt;&lt;br/&gt;    生产地: &lt;input type=&quot;text&quot; name=&quot;productAddress&quot; value=&quot;广东省,深圳市,宝安区航城街道&quot;/&gt;    &lt;button type=&quot;submit&quot;&gt;保存&lt;/button&gt;&lt;/form&gt;</code></pre><h4 id="3-3-handler-方法"><a href="#3-3-handler-方法" class="headerlink" title="3.3 handler 方法"></a>3.3 handler 方法</h4><pre><code class="java">@RequestMapping(&quot;/saveProduct&quot;)public String saveProduct(Product product, BindingResult bindingResult)&#123;    if (bindingResult.hasErrors()) &#123;        //跳转到错误页面:显示错误数据        return &quot;error&quot;;    &#125;    logger.debug(product.toString());    return &quot;target&quot;;&#125;</code></pre><p>在目前代码的基础上，我们没有提供自定义类型转换器，所以处理请求时看到如下错误日志：</p><blockquote><p>Field error in object ‘student’ on field ‘address’: rejected value [aaa,bbb,ccc]; codes [typeMismatch.student.address,typeMismatch.address,typeMismatch.com.atguigu.mvc.entity.Address,typeMismatch]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [student.address,address]; arguments []; default message [address]]; default message [Failed to convert property value of type ‘java.lang.String’ to required type ‘com.atguigu.mvc.entity.Address’ for property ‘address’; nested exception is java.lang.IllegalStateException: Cannot convert value of type ‘java.lang.String’ to required type ‘com.atguigu.mvc.entity.Address’ for property ‘address’: no matching editors or conversion strategy found]]]</p></blockquote><p>页面返回 400。</p><h4 id="3-4-创建自定义类型转换器类"><a href="#3-4-创建自定义类型转换器类" class="headerlink" title="3.4 创建自定义类型转换器类"></a>3.4 创建自定义类型转换器类</h4><p>实现接口：org.springframework.core.convert.converter.Converter&lt;S,T&gt;</p><p>泛型 S：源类型（本例中是 String 类型）</p><p>泛型 T：目标类型（本例中是 Address 类型）</p><pre><code class="java">package com.atguigu.converter;import com.atguigu.pojo.Address;import org.springframework.core.convert.converter.Converter;/** * 包名:com.atguigu.converter * * @author Leevi * 日期2021-09-07  14:00 * 编写自定义类型转换器: * 1. 写一个类实现Converter接口 * 2. 重写convert方法进行转换 * 3. 在springmvc的配置文件中配置类型转换器 */public class AddressConverter implements Converter&lt;String , Address&gt; &#123;    @Override    public Address convert(String source) &#123;        //source就是要进行转换的那个字符串        //1. 解析字符串:获取省、市、街道        String[] strs = source.split(&quot;,&quot;);        //2. 创建一个Address对象        Address address = new Address();        //3. 将省、市、街道设置到Address对象中        address.setProvince(strs[0]);        address.setCity(strs[1]);        address.setStreet(strs[2]);        return address;    &#125;    @Override    public &lt;U&gt; Converter&lt;String, U&gt; andThen(Converter&lt;? super Address, ? extends U&gt; after) &#123;        return null;    &#125;&#125;</code></pre><h4 id="3-5-在springmvc配置文件中注册类型转换器"><a href="#3-5-在springmvc配置文件中注册类型转换器" class="headerlink" title="3.5 在springmvc配置文件中注册类型转换器"></a>3.5 在springmvc配置文件中注册类型转换器</h4><pre><code class="xml">&lt;!-- 在 mvc:annotation-driven 中注册 FormattingConversionServiceFactoryBean --&gt;&lt;mvc:annotation-driven conversion-service=&quot;formattingConversionService&quot;/&gt; &lt;!-- 在 FormattingConversionServiceFactoryBean 中注册自定义类型转换器 --&gt;&lt;bean id=&quot;formattingConversionService&quot;      class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;    &lt;!-- 在 converters 属性中指定自定义类型转换器 --&gt;    &lt;property name=&quot;converters&quot;&gt;        &lt;set&gt;            &lt;bean class=&quot;com.atguigu.mvc.converter.AddressConverter&quot;/&gt;        &lt;/set&gt;    &lt;/property&gt; &lt;/bean&gt;</code></pre><h2 id="第三章-数据校验-重要"><a href="#第三章-数据校验-重要" class="headerlink" title="第三章 数据校验(重要)"></a>第三章 数据校验(重要)</h2><p>在 Web 应用三层架构体系中，表述层负责接收浏览器提交的数据，业务逻辑层负责数据的处理。为了能够让业务逻辑层基于正确的数据进行处理，我们需要在表述层对数据进行检查，将错误的数据隔绝在业务逻辑层之外。 </p><h3 id="1-数据校验概述"><a href="#1-数据校验概述" class="headerlink" title="1. 数据校验概述"></a>1. 数据校验概述</h3><p>JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。 </p><table><thead><tr><th>注解</th><th>规则</th></tr></thead><tbody><tr><td>@Null</td><td>标注值必须为 null</td></tr><tr><td>@NotNull</td><td>标注值不可为 null</td></tr><tr><td>@AssertTrue</td><td>标注值必须为 true</td></tr><tr><td>@AssertFalse</td><td>标注值必须为 false</td></tr><tr><td>@Min(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@Max(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@DecimalMin(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@DecimalMax(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@Size(max,min)</td><td>标注值大小必须在 max 和 min 限定的范围内</td></tr><tr><td>@Digits(integer,fratction)</td><td>标注值值必须是一个数字，且必须在可接受的范围内</td></tr><tr><td>@Past</td><td>标注值只能用于日期型，且必须是过去的日期</td></tr><tr><td>@Future</td><td>标注值只能用于日期型，且必须是将来的日期</td></tr><tr><td>@Pattern(value)</td><td>标注值必须符合指定的正则表达式</td></tr></tbody></table><p>JSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解： </p><table><thead><tr><th>注解</th><th>规则</th></tr></thead><tbody><tr><td>@Email</td><td>标注值必须是格式正确的 Email 地址</td></tr><tr><td>@Length</td><td>标注值字符串大小必须在指定的范围内</td></tr><tr><td>@NotEmpty</td><td>标注值字符串不能是空字符串</td></tr><tr><td>@Range</td><td>标注值必须在指定的范围内</td></tr></tbody></table><p>Spring 4.0 版本已经拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在SpringMVC 中，可直接通过注解驱动 mvc:annotation-driven 的方式进行数据校验。Spring 的 LocalValidatorFactoryBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在Spring容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean中。Spring本身并没有提供JSR 303的实现，所以必须将JSR 303的实现者的jar包放到类路径下。</p><p>配置 mvc:annotation-driven 后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过<strong>在处理方法的入参上标注 @Validated 注解</strong>即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。</p><h3 id="2-具体操作"><a href="#2-具体操作" class="headerlink" title="2. 具体操作"></a>2. 具体操作</h3><p>前提:1.  springmvc环境   2. Tomcat8及以上版本</p><h4 id="2-1-引入依赖"><a href="#2-1-引入依赖" class="headerlink" title="2.1 引入依赖"></a>2.1 引入依赖</h4><pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;    &lt;version&gt;6.2.0.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt;    &lt;version&gt;6.2.0.Final&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="2-2-应用校验规则"><a href="#2-2-应用校验规则" class="headerlink" title="2.2 应用校验规则"></a>2.2 应用校验规则</h4><h5 id="2-2-1-给要进行校验的字段添加上校验规则注解"><a href="#2-2-1-给要进行校验的字段添加上校验规则注解" class="headerlink" title="2.2.1 给要进行校验的字段添加上校验规则注解"></a>2.2.1 给要进行校验的字段添加上校验规则注解</h5><pre><code class="java">@Data@AllArgsConstructor@NoArgsConstructorpublic class President &#123;    // 字符串长度：[3,6]    @Size(min = 3, max = 6)    private String username;    // 字符串必须满足Email格式    @Email    private String email;&#125;</code></pre><h5 id="2-2-2-给handler方法的形参加上Validated"><a href="#2-2-2-给handler方法的形参加上Validated" class="headerlink" title="2.2.2 给handler方法的形参加上Validated"></a>2.2.2 给handler方法的形参加上Validated</h5><pre><code class="java">@RequestMapping(&quot;/savePresident&quot;)public String savePresident(@Validated President president)&#123;    logger.debug(president.toString());    return &quot;target&quot;;&#125;</code></pre><h4 id="2-3-校验失败效果"><a href="#2-3-校验失败效果" class="headerlink" title="2.3 校验失败效果"></a>2.3 校验失败效果</h4><p>日志：</p><blockquote><p>Field error in object ‘president’ on field ‘email’: rejected value [aa]; codes [Email.president.email,Email.email,Email.java.lang.String,Email]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [president.email,email]; arguments []; default message [email],[Ljavax.validation.constraints.Pattern$Flag;@4a6addb7,.*]; default message [不是一个合法的电子邮件地址] Field error in object ‘president’ on field ‘email’: rejected value [aa]; codes [Size.president.email,Size.email,Size.java.lang.String,Size]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [president.email,email]; arguments []; default message [email],6,3]; default message [个数必须在3和6之间]]]</p></blockquote><p>同时页面返回 400。</p><h4 id="2-4-显示友好的错误提示"><a href="#2-4-显示友好的错误提示" class="headerlink" title="2.4 显示友好的错误提示"></a>2.4 显示友好的错误提示</h4><h5 id="2-4-1-重构-handler-方法"><a href="#2-4-1-重构-handler-方法" class="headerlink" title="2.4.1 重构 handler 方法"></a>2.4.1 重构 handler 方法</h5><pre><code class="java">@RequestMapping(&quot;/save/president&quot;)public String savePresident(        // 在实体类参数和 BindingResult 之间不能有任何其他参数        @Validated President president, BindingResult bindingResult) &#123;     if (bindingResult.hasErrors()) &#123;        return &quot;error&quot;;    &#125;         logger.debug(president.getEmail());     return &quot;target&quot;;&#125;</code></pre><h5 id="2-4-2-准备错误信息页面"><a href="#2-4-2-准备错误信息页面" class="headerlink" title="2.4.2 准备错误信息页面"></a>2.4.2 准备错误信息页面</h5><pre><code class="html">&lt;h1&gt;系统信息&lt;/h1&gt;&lt;!-- 从请求域获取实体类信息时，属性名是按照类名首字母小写的规则 --&gt;&lt;!-- $&#123;注入请求参数的实体类.出问题的字段&#125; --&gt;&lt;p th:errors=&quot;$&#123;president.email&#125;&quot;&gt;这里显示系统提示消息&lt;/p&gt;</code></pre><h2 id="第四章-异常映射"><a href="#第四章-异常映射" class="headerlink" title="第四章 异常映射"></a>第四章 异常映射</h2><h3 id="1-为什么需要异常映射"><a href="#1-为什么需要异常映射" class="headerlink" title="1. 为什么需要异常映射"></a>1. 为什么需要异常映射</h3><p>一个项目中会包含很多个模块，各个模块需要分工完成。如果张三负责的模块按照 A 方案处理异常，李四负责的模块按照 B 方法处理异常……各个模块处理异常的思路、代码、命名细节都不一样，那么就会让整个项目非常混乱。 </p><p>异常映射可以将异常类型和某个具体的视图关联起来，建立映射关系。好处是可以通过 SpringMVC 框架来帮助我们管理异常。</p><ul><li>声明式管理异常：在配置文件中指定异常类型和视图之间的对应关系。在配置文件或注解类中统一管理。</li><li>编程式管理异常：需要我们自己手动 try … catch … 捕获异常，然后再手动跳转到某个页面。</li></ul><h3 id="2-异常映射的优势"><a href="#2-异常映射的优势" class="headerlink" title="2. 异常映射的优势"></a>2. 异常映射的优势</h3><ul><li>使用声明式代替编程式来实现异常管理<ul><li>让异常控制和核心业务解耦，二者各自维护，结构性更好</li></ul></li><li>整个项目层面使用同一套规则来管理异常<ul><li>整个项目代码风格更加统一、简洁</li><li>便于团队成员之间的彼此协作</li></ul></li></ul><h3 id="3-基于-XML-的异常映射"><a href="#3-基于-XML-的异常映射" class="headerlink" title="3. 基于 XML 的异常映射"></a>3. 基于 XML 的异常映射</h3><h4 id="3-1-XML配置"><a href="#3-1-XML配置" class="headerlink" title="3.1 XML配置"></a>3.1 XML配置</h4><p>SpringMVC 会根据异常映射信息，在捕获到指定异常对象后，将异常对象存入请求域，然后转发到和异常类型关联的视图。</p><pre><code class="xml">&lt;!--配置异常处理--&gt;&lt;bean id=&quot;exceptionResolver&quot;      class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;    &lt;!-- 配置异常映射关系 --&gt;    &lt;property name=&quot;exceptionMappings&quot;&gt;        &lt;props&gt;            &lt;!-- key属性：指定异常类型 --&gt;            &lt;!-- 文本标签体：和异常类型对应的逻辑视图 --&gt;            &lt;prop key=&quot;java.lang.ArithmeticException&quot;&gt;error-arith&lt;/prop&gt;            &lt;prop key=&quot;java.lang.ClassNotFoundException&quot;&gt;error-class&lt;/prop&gt;            &lt;prop key=&quot;java.lang.RuntimeException&quot;&gt;error-runtime&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;    &lt;!--            SimpleMappingExceptionResolver在处理异常的时候，会将异常对象存储到请求域中            我们下面的配置，就是用于指定将异常对象存储进请求域的时候，使用的是key叫什么        --&gt;    &lt;property name=&quot;exceptionAttribute&quot; value=&quot;atguiguException&quot;/&gt;&lt;/bean&gt;</code></pre><h4 id="3-2-异常范围"><a href="#3-2-异常范围" class="headerlink" title="3.2 异常范围"></a>3.2 异常范围</h4><p>如果在配置文件中，发现有多个匹配的异常类型，那么 SpringMVC 会采纳范围上最接近的异常映射关系。 </p><pre><code class="xml">&lt;prop key=&quot;java.lang.ArithmeticException&quot;&gt;error-arith&lt;/prop&gt;&lt;prop key=&quot;java.lang.RuntimeException&quot;&gt;error-runtime&lt;/prop&gt;</code></pre><h3 id="4-基于注解的异常映射"><a href="#4-基于注解的异常映射" class="headerlink" title="4. 基于注解的异常映射"></a>4. 基于注解的异常映射</h3><h4 id="4-1-创建异常处理器类"><a href="#4-1-创建异常处理器类" class="headerlink" title="4.1 创建异常处理器类"></a>4.1 创建异常处理器类</h4><p><img src="http://www.slx.blue/2021/12/13/springMVC-03/tu_005.png"></p><h4 id="4-2-异常处理器对象加入-IOC-容器"><a href="#4-2-异常处理器对象加入-IOC-容器" class="headerlink" title="4.2 异常处理器对象加入 IOC 容器"></a>4.2 异常处理器对象加入 IOC 容器</h4><h5 id="4-2-1-包扫描"><a href="#4-2-1-包扫描" class="headerlink" title="4.2.1 包扫描"></a>4.2.1 包扫描</h5><pre><code class="xml">&lt;!--1.包扫描--&gt;&lt;context:component-scan base-package=&quot;com.atguigu&quot;/&gt;</code></pre><h5 id="4-2-2-给异常处理器类标记注解"><a href="#4-2-2-给异常处理器类标记注解" class="headerlink" title="4.2.2 给异常处理器类标记注解"></a>4.2.2 给异常处理器类标记注解</h5><pre><code class="java">// 异常处理器类需要使用 @ControllerAdvice 注解标记@ControllerAdvicepublic class MyExceptionHandler &#123;    &#125;</code></pre><h4 id="4-3-声明处理异常的方法"><a href="#4-3-声明处理异常的方法" class="headerlink" title="4.3 声明处理异常的方法"></a>4.3 声明处理异常的方法</h4><pre><code class="java">// @ExceptionHandler注解：标记异常处理方法// value属性：指定匹配的异常类型// 异常类型的形参：SpringMVC 捕获到的异常对象@ExceptionHandler(value = NullPointerException.class)public String resolveNullPointerException(Exception e, Model model) &#123;     // 我们可以自己手动将异常对象存入模型    model.addAttribute(&quot;atguiguException&quot;, e);     // 返回逻辑视图名称    return &quot;error-nullpointer&quot;;&#125;</code></pre><p>当同一个异常类型在基于 XML 和注解的配置中都能够找到对应的映射，那么以注解为准。 </p><h3 id="5-区分请求类型"><a href="#5-区分请求类型" class="headerlink" title="5. 区分请求类型"></a>5. 区分请求类型</h3><h4 id="5-1-为什么要区分请求类型"><a href="#5-1-为什么要区分请求类型" class="headerlink" title="5.1 为什么要区分请求类型"></a>5.1 为什么要区分请求类型</h4><p>异常处理机制和拦截器机制都面临这样的问题： </p><p><img src="http://www.slx.blue/2021/12/13/springMVC-03/tu_006.png"></p><h4 id="5-2-判断依据"><a href="#5-2-判断依据" class="headerlink" title="5.2 判断依据"></a>5.2 判断依据</h4><p>查看请求消息头中是否包含 Ajax 请求独有的特征：</p><ul><li>Accept 请求消息头：包含 application/json</li><li>X-Requested-With 请求消息头：包含 XMLHttpRequest</li></ul><p>两个条件满足一个即可。</p><pre><code class="java">/**     * 判断请求类型，如果返回true就是同步请求，返回false就是异步请求     * @param request     * @return     */private boolean judgeRequestType(HttpServletRequest request) &#123;    //加入代码判断当前请求是同步请求还是异步请求:通过accept或者X-Requested-With    String acceptHeader = request.getHeader(&quot;Accept&quot;);    String xRequestHeader = request.getHeader(&quot;X-Requested-With&quot;);    return !((acceptHeader != null &amp;&amp; acceptHeader.contains(&quot;application/json&quot;)) ||             (xRequestHeader != null &amp;&amp; xRequestHeader.equals(&quot;XMLHttpRequest&quot;)));&#125;</code></pre><h4 id="5-3-重构异常处理器兼容两种请求的处理方法"><a href="#5-3-重构异常处理器兼容两种请求的处理方法" class="headerlink" title="5.3 重构异常处理器兼容两种请求的处理方法"></a>5.3 重构异常处理器兼容两种请求的处理方法</h4><pre><code class="java">@ExceptionHandler(value = Exception.class)public String resolveNullPointerException(HttpServletResponse response,                                          HttpServletRequest request,                                          Exception e, Model model) throws IOException &#123;    //这个方法处理空指针异常    if(!judgeRequestType(request))&#123;        //说明当前是异步请求:使用response向客户端响应异常信息        response.getWriter().write(e.getMessage());        return null;    &#125;    //要获取异常信息，并且将异常信息存储到请求域    model.addAttribute(&quot;atguiguException&quot;,e);    //这个方法返回:异常处理页面的逻辑视图    return &quot;error&quot;;&#125;</code></pre><h2 id="第五章-文件上传-重要"><a href="#第五章-文件上传-重要" class="headerlink" title="第五章 文件上传(重要)"></a>第五章 文件上传(重要)</h2><h3 id="1-前端表单"><a href="#1-前端表单" class="headerlink" title="1. 前端表单"></a>1. 前端表单</h3><p>需要满足的要求:</p><ul><li>第一点：请求方式必须是 POST</li><li>第二点：请求体的编码方式必须是 multipart/form-data（通过 form 标签的 enctype 属性设置）</li><li>第三点：使用 input 标签、type 属性设置为 file 来生成文件上传框</li></ul><pre><code class="html">&lt;form th:action=&quot;@&#123;/atguigu/upload&#125;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;        &lt;input type=&quot;file&quot; name=&quot;picture&quot; /&gt;    &lt;button type=&quot;submit&quot;&gt;上传头像&lt;/button&gt;     &lt;/form&gt;</code></pre><h3 id="2-SpringMVC-环境"><a href="#2-SpringMVC-环境" class="headerlink" title="2. SpringMVC 环境"></a>2. SpringMVC 环境</h3><h4 id="2-1-引入依赖-1"><a href="#2-1-引入依赖-1" class="headerlink" title="2.1 引入依赖"></a>2.1 引入依赖</h4><pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h4><p>在 SpringMVC 的配置文件中加入 multipart 类型数据的解析器： </p><pre><code class="xml">&lt;bean id=&quot;multipartResolver&quot;       class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;        &lt;!-- 由于上传文件的表单请求体编码方式是 multipart/form-data 格式，所以要在解析器中指定字符集 --&gt;    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt;    &lt;/bean&gt;</code></pre><h3 id="3-handler-方法接收数据"><a href="#3-handler-方法接收数据" class="headerlink" title="3. handler 方法接收数据"></a>3. handler 方法接收数据</h3><pre><code class="java">@RequestMapping(&quot;/simple/upload&quot;)public String doUpload(         // 表单提交的数据仍然是请求参数，所以使用 @RequestParam 注解接收        @RequestParam(&quot;nickName&quot;) String nickName,         // 对于上传的文件使用 MultipartFile 类型接收其相关数据        @RequestParam(&quot;picture&quot;) MultipartFile picture        ) throws IOException &#123;     String inputName = picture.getName();    logger.debug(&quot;文件上传表单项的 name 属性值：&quot; + inputName);     // 获取这个数据通常都是为了获取文件本身的扩展名    String originalFilename = picture.getOriginalFilename();    logger.debug(&quot;文件在用户本地原始的文件名：&quot; + originalFilename);     String contentType = picture.getContentType();    logger.debug(&quot;文件的内容类型：&quot; + contentType);     boolean empty = picture.isEmpty();    logger.debug(&quot;文件是否为空：&quot; + empty);     long size = picture.getSize();    logger.debug(&quot;文件大小：&quot; + size);     byte[] bytes = picture.getBytes();    logger.debug(&quot;文件二进制数据的字节数组：&quot; + Arrays.asList(bytes));     InputStream inputStream = picture.getInputStream();    logger.debug(&quot;读取文件数据的输入流对象：&quot; + inputStream);     Resource resource = picture.getResource();    logger.debug(&quot;代表当前 MultiPartFile 对象的资源对象&quot; + resource);     return &quot;target&quot;;&#125;</code></pre><h3 id="4-MultipartFile接口介绍"><a href="#4-MultipartFile接口介绍" class="headerlink" title="4. MultipartFile接口介绍"></a>4. MultipartFile接口介绍</h3><p><img src="http://www.slx.blue/2021/12/13/springMVC-03/tu_007.png"></p><h3 id="5-文件转存"><a href="#5-文件转存" class="headerlink" title="5. 文件转存"></a>5. 文件转存</h3><h4 id="5-1-底层原理"><a href="#5-1-底层原理" class="headerlink" title="5.1 底层原理"></a>5.1 底层原理</h4><p><img src="http://www.slx.blue/2021/12/13/springMVC-03/tu_008.png"></p><h4 id="5-2-三种去向"><a href="#5-2-三种去向" class="headerlink" title="5.2 三种去向"></a>5.2 三种去向</h4><h5 id="5-2-1-本地转存"><a href="#5-2-1-本地转存" class="headerlink" title="5.2.1 本地转存"></a>5.2.1 本地转存</h5><p><img src="http://www.slx.blue/2021/12/13/springMVC-03/tu_009.png"></p><h6 id="5-2-1-1-创建保存文件的目录"><a href="#5-2-1-1-创建保存文件的目录" class="headerlink" title="5.2.1.1  创建保存文件的目录"></a>5.2.1.1  <strong>创建保存文件的目录</strong></h6><p><img src="http://www.slx.blue/2021/12/13/springMVC-03/tu_010.png"></p><p>这个目录如果是空目录，那么服务器部署运行时很容易会忽略这个目录。为了避免这个问题，在这个目录下随便创建一个文件，随便写点内容即可。 </p><h6 id="5-2-1-2-编写转存代码"><a href="#5-2-1-2-编写转存代码" class="headerlink" title="5.2.1.2  编写转存代码"></a>5.2.1.2  <strong>编写转存代码</strong></h6><p>下面是负责处理文件上传请求的 handler 方法的转存部分： </p><pre><code class="java">@Autowiredprivate ServletContext servletContext;Logger logger = LoggerFactory.getLogger(this.getClass());@RequestMapping(&quot;/upload&quot;)public String upload(@RequestParam(&quot;nickname&quot;) String nickname,@RequestParam(&quot;picture&quot;) MultipartFile multipartFile) throws IOException &#123;    //获取请求参数(除了文件之外)，还是和以前一样的方式获取    logger.debug(nickname);    //multipartFile对象就表示客户端上传的文件    //1. 指定转存的目录路径:动态获取部署的目录路径    String dirPath = servletContext.getRealPath(&quot;head-picture&quot;);    //2. 获取文件名:在获取到原文件的文件名之后，将其文件名改成一个唯一的名字，这样就能保证不会出现上传文件同名的情况    String UUIDName = UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;);    //获取文件名的后缀    String originalFilename = multipartFile.getOriginalFilename();    String suffix = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));    //唯一的文件名就是UUIDName拼接后缀    String fileName = UUIDName + suffix;    //要将该文件转存到目录中    multipartFile.transferTo(new File(dirPath+&quot;/&quot;+fileName));    return &quot;target&quot;;&#125;</code></pre><h6 id="5-2-1-3-缺陷"><a href="#5-2-1-3-缺陷" class="headerlink" title="5.2.1.3 缺陷"></a>5.2.1.3 缺陷</h6><ul><li>Web 应用重新部署时通常都会清理旧的构建结果，此时用户以前上传的文件会被删除，导致数据丢失。</li><li>项目运行很长时间后，会导致上传的文件积累非常多，体积非常大，从而拖慢 Tomcat 运行速度。</li><li>当服务器以集群模式运行时，文件上传到集群中的某一个实例，其他实例中没有这个文件，就会造成数据不一致。</li><li>不支持动态扩容，一旦系统增加了新的硬盘或新的服务器实例，那么上传、下载时使用的路径都需要跟着变化，导致 Java 代码需要重新编写、重新编译，进而导致整个项目重新部署。</li></ul><p><img src="http://www.slx.blue/2021/12/13/springMVC-03/tu_011.png"></p><h5 id="5-2-2-文件服务器"><a href="#5-2-2-文件服务器" class="headerlink" title="5.2.2 文件服务器"></a>5.2.2 文件服务器</h5><p><img src="http://www.slx.blue/2021/12/13/springMVC-03/tu_012.png"></p><h6 id="5-2-2-1-优势"><a href="#5-2-2-1-优势" class="headerlink" title="5.2.2.1 优势"></a>5.2.2.1 优势</h6><ul><li>不受 Web 应用重新部署影响</li><li>在应用服务器集群环境下不会导致数据不一致</li><li>针对文件读写进行专门的优化，性能有保障</li><li>能够实现动态扩容</li></ul><p><img src="http://www.slx.blue/2021/12/13/springMVC-03/tu_013.png"></p><h6 id="5-2-2-2-常见的文件服务器类型"><a href="#5-2-2-2-常见的文件服务器类型" class="headerlink" title="5.2.2.2 常见的文件服务器类型"></a>5.2.2.2 常见的文件服务器类型</h6><ul><li>第三方平台：<ul><li>阿里的 OSS 对象存储服务</li><li>七牛云</li></ul></li><li>自己搭建服务器：FastDFS等</li></ul><h5 id="5-2-3-上传到其他模块-了解"><a href="#5-2-3-上传到其他模块-了解" class="headerlink" title="5.2.3 上传到其他模块(了解)"></a>5.2.3 上传到其他模块(了解)</h5><p>这种情况肯定出现在分布式架构中，常规业务功能不会这么做，采用这个方案的一定的特殊情况。 </p><p><img src="http://www.slx.blue/2021/12/13/springMVC-03/tu_014.png"></p><h2 id="第六章-文件下载-了解"><a href="#第六章-文件下载-了解" class="headerlink" title="第六章 文件下载(了解)"></a>第六章 文件下载(了解)</h2><h3 id="1-原始形态"><a href="#1-原始形态" class="headerlink" title="1. 原始形态"></a>1. 原始形态</h3><p>使用链接地址指向要下载的文件。此时浏览器会尽可能解析对应的文件，只要是能够在浏览器窗口展示的，就都会直接显示，而不是提示下载。 </p><pre><code class="html">&lt;a href=&quot;download/hello.atguigu&quot;&gt;下载&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;download/tank.jpg&quot;&gt;下载&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;download/chapter04.zip&quot;&gt;下载&lt;/a&gt;&lt;br/&gt;</code></pre><p>上面例子中，只有 chapter04.zip 文件是直接提示下载的，其他两个都是直接显示。 </p><h3 id="2-明确要求浏览器提示下载"><a href="#2-明确要求浏览器提示下载" class="headerlink" title="2. 明确要求浏览器提示下载"></a>2. 明确要求浏览器提示下载</h3><pre><code class="java">@Autowiredprivate ServletContext servletContext;@RequestMapping(&quot;/download&quot;)public ResponseEntity download(@RequestParam(&quot;fileName&quot;) String fileName) throws IOException &#123;    //用来下载文件:    //1. 使用输入流读取要下载的文件    //1.1 获取要下载的文件路径    String downloadPath = servletContext.getRealPath(&quot;download/&quot;+fileName);    //1.2 读取要下载的文件    FileInputStream fileInputStream = new FileInputStream(downloadPath);    int len = fileInputStream.available();    byte[] buffer = new byte[len];    fileInputStream.read(buffer);    //2. 将要下载的文件输出到浏览器:使用响应    //ResponseEntity表示响应实体:要下载的文件是通过响应体响应给客户端的    //创建添加响应头    MultiValueMap&lt;String, String&gt; headers = new HttpHeaders();    //获取要下载的文件的mime-type,设置Content-Type响应头    String contentType = servletContext.getMimeType(fileName);    headers.add(&quot;Content-Type&quot;,contentType);    //Content-Disposition:响应头是指示客户端下载内容    headers.add(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+fileName);    return new ResponseEntity&lt;&gt;(buffer, headers,HttpStatus.OK);&#125;</code></pre><h3 id="3-典型应用场景举例"><a href="#3-典型应用场景举例" class="headerlink" title="3. 典型应用场景举例"></a>3. 典型应用场景举例</h3><p>我们目前实现的是一个较为简单的下载，可以用在下面的一些场合：</p><ul><li>零星小文件下载</li><li>将系统内部的数据导出为 Excel、PDF 等格式，然后以下载的方式返回给用户</li></ul>]]></content>
      
      
      <categories>
          
          <category> springMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springMVC-04</title>
      <link href="/2021/12/13/springMVC-04/"/>
      <url>/2021/12/13/springMVC-04/</url>
      
        <content type="html"><![CDATA[<h1 id="springmvc-day04"><a href="#springmvc-day04" class="headerlink" title="springmvc-day04"></a>springmvc-day04</h1><h2 id="第一章-SpringMVC运行原理"><a href="#第一章-SpringMVC运行原理" class="headerlink" title="第一章 SpringMVC运行原理"></a>第一章 SpringMVC运行原理</h2><h3 id="第一节-启动过程"><a href="#第一节-启动过程" class="headerlink" title="第一节 启动过程"></a>第一节 启动过程</h3><h4 id="1-Servlet-生命周期回顾"><a href="#1-Servlet-生命周期回顾" class="headerlink" title="1. Servlet 生命周期回顾"></a>1. Servlet 生命周期回顾</h4><table><thead><tr><th>生命周期环节</th><th>调用的方法</th><th>时机</th><th>次数</th></tr></thead><tbody><tr><td>创建对象</td><td>无参构造器</td><td><strong>默认：第一次请求 修改：Web应用启动时</strong></td><td>一次</td></tr><tr><td>初始化</td><td>init(ServletConfig servletConfig)</td><td>创建对象后</td><td>一次</td></tr><tr><td>处理请求</td><td>service(ServletRequest servletRequest,  ServletResponse servletResponse)</td><td>接收到请求后</td><td>多次</td></tr><tr><td>清理操作</td><td>destroy()</td><td>Web应用卸载之前</td><td>一次</td></tr></tbody></table><h4 id="2-初始化操作调用路线图"><a href="#2-初始化操作调用路线图" class="headerlink" title="2. 初始化操作调用路线图"></a>2. 初始化操作调用路线图</h4><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_001.png"></p><h4 id="3-IOC容器创建"><a href="#3-IOC容器创建" class="headerlink" title="3. IOC容器创建"></a>3. IOC容器创建</h4><p>所在类：org.springframework.web.servlet.FrameworkServlet </p><pre><code class="java">protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) &#123;    Class&lt;?&gt; contextClass = getContextClass();    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;        throw new ApplicationContextException(                &quot;Fatal initialization error in servlet with name &#39;&quot; + getServletName() +                &quot;&#39;: custom WebApplicationContext class [&quot; + contextClass.getName() +                &quot;] is not of type ConfigurableWebApplicationContext&quot;);    &#125;        // 通过反射创建 IOC 容器对象    ConfigurableWebApplicationContext wac =            (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);    wac.setEnvironment(getEnvironment());        // 设置父容器    wac.setParent(parent);    String configLocation = getContextConfigLocation();    if (configLocation != null) &#123;        wac.setConfigLocation(configLocation);    &#125;    configureAndRefreshWebApplicationContext(wac);    return wac;&#125;</code></pre><h4 id="4-将-IOC-容器对象存入应用域"><a href="#4-将-IOC-容器对象存入应用域" class="headerlink" title="4. 将 IOC 容器对象存入应用域"></a>4. 将 IOC 容器对象存入应用域</h4><p>所在类：org.springframework.web.servlet.FrameworkServlet </p><pre><code class="java">protected WebApplicationContext initWebApplicationContext() &#123;    WebApplicationContext rootContext =            WebApplicationContextUtils.getWebApplicationContext(getServletContext());    WebApplicationContext wac = null;    if (this.webApplicationContext != null) &#123;        wac = this.webApplicationContext;        if (wac instanceof ConfigurableWebApplicationContext) &#123;            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;            if (!cwac.isActive()) &#123;                if (cwac.getParent() == null) &#123;                    cwac.setParent(rootContext);                &#125;                configureAndRefreshWebApplicationContext(cwac);            &#125;        &#125;    &#125;    if (wac == null) &#123;        wac = findWebApplicationContext();    &#125;    if (wac == null) &#123;        // 创建 IOC 容器        wac = createWebApplicationContext(rootContext);    &#125;    if (!this.refreshEventReceived) &#123;        synchronized (this.onRefreshMonitor) &#123;            onRefresh(wac);        &#125;    &#125;    if (this.publishContext) &#123;        // 获取存入应用域时专用的属性名        String attrName = getServletContextAttributeName();                // 存入        getServletContext().setAttribute(attrName, wac);    &#125;    return wac;&#125;</code></pre><p>看到这一点的意义：SpringMVC 有一个工具方法，可以从应用域获取 IOC 容器对象的引用。</p><p>工具类：org.springframework.web.context.support.WebApplicationContextUtils</p><p>工具方法：getWebApplicationContext()</p><pre><code class="java">@Nullablepublic static WebApplicationContext getWebApplicationContext(ServletContext sc) &#123;    return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);&#125;</code></pre><h4 id="5-请求映射初始化"><a href="#5-请求映射初始化" class="headerlink" title="5. 请求映射初始化"></a>5. 请求映射初始化</h4><p>FrameworkServlet.createWebApplicationContext()→configureAndRefreshWebApplicationContext()→wac.refresh()→触发刷新事件→org.springframework.web.servlet.DispatcherServlet.initStrategies()→org.springframework.web.servlet.DispatcherServlet.initHandlerMappings() </p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_002.png"></p><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h4><p>整个启动过程我们关心如下要点：</p><ul><li>DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。</li><li>DispatcherServlet 的父类是 FrameworkServlet。<ul><li>FrameworkServlet 负责框架本身相关的创建和初始化。</li><li>DispatcherServlet 负责请求处理相关的初始化。</li></ul></li><li>FrameworkServlet 创建 IOC 容器对象之后会存入应用域。</li><li>FrameworkServlet 完成初始化会调用 IOC 容器的刷新方法。</li><li>刷新方法完成触发刷新事件，在刷新事件的响应函数中，调用 DispatcherServlet 的初始化方法。</li><li>在 DispatcherServlet 的初始化方法中初始化了请求映射等。</li></ul><h2 id="第二章-请求处理过程"><a href="#第二章-请求处理过程" class="headerlink" title="第二章 请求处理过程"></a>第二章 请求处理过程</h2><h3 id="第一节-总体阶段"><a href="#第一节-总体阶段" class="headerlink" title="第一节 总体阶段"></a>第一节 总体阶段</h3><h4 id="1-流程描述"><a href="#1-流程描述" class="headerlink" title="1. 流程描述"></a>1. 流程描述</h4><ul><li>目标 handler 方法执行<strong>前</strong><ul><li>建立调用链，确定整个执行流程</li><li>拦截器的 preHandle() 方法</li><li>注入请求参数</li><li>准备目标 handler 方法所需所有参数</li></ul></li><li><strong>调用</strong>目标 handler 方法</li><li>目标 handler 方法执行<strong>后</strong><ul><li>拦截器的 postHandle() 方法</li><li>渲染视图</li><li>拦截器的 afterCompletion() 方法</li></ul></li></ul><h4 id="2-核心代码"><a href="#2-核心代码" class="headerlink" title="2. 核心代码"></a>2. 核心代码</h4><p>整个请求处理过程都是 doDispatch() 方法在宏观上协调和调度，把握了这个方法就理解了 SpringMVC 总体上是如何处理请求的。</p><p>所在类：org.springframework.web.servlet.<strong>DispatcherServlet</strong></p><p>所在方法：doDispatch()</p><p>核心方法中的核心代码：</p><pre><code class="java">// Actually invoke the handler.mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code></pre><h3 id="第二节-调用前阶段"><a href="#第二节-调用前阶段" class="headerlink" title="第二节 调用前阶段"></a>第二节 调用前阶段</h3><h4 id="1-建立调用链"><a href="#1-建立调用链" class="headerlink" title="1. 建立调用链"></a>1. 建立调用链</h4><h5 id="1-1-相关组件"><a href="#1-1-相关组件" class="headerlink" title="1.1 相关组件"></a>1.1 相关组件</h5><p>全类名：org.springframework.web.servlet.HandlerExecutionChain </p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_003.png"></p><p>拦截器索引默认是 -1，说明开始的时候，它指向第一个拦截器前面的位置。每执行一个拦截器，就把索引向前移动一个位置。所以这个索引每次都是指向当前拦截器。所以它相当于拦截器的<strong>指针</strong>。 </p><h5 id="1-2-对应操作"><a href="#1-2-对应操作" class="headerlink" title="1.2 对应操作"></a>1.2 对应操作</h5><p>所在类：org.springframework.web.servlet.handler.AbstractHandlerMapping </p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_004.png"></p><p>结论：调用链是由拦截器和目标 handler 对象组成的。 </p><h4 id="2-调用拦截器-preHandle"><a href="#2-调用拦截器-preHandle" class="headerlink" title="2. 调用拦截器 preHandle()"></a>2. 调用拦截器 preHandle()</h4><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><p>所在方法：doDispatch()</p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_005.png"></p><p>具体调用细节：正序调用</p><p>所在类：org.springframework.web.servlet.HandlerExecutionChain</p><p>所在方法：applyPreHandle</p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_006.png"></p><p>从这部分代码我们也能看到，为什么拦截器中的 preHandle() 方法通过返回布尔值能够控制是否放行。</p><ul><li>每一个拦截器的 preHandle() 方法都返回 true：applyPreHandle() 方法返回 true，被取反就不执行 if 分支，继续执行后续操作，这就是放行。</li><li>任何一个拦截器的 preHandle() 方法返回 false：applyPreHandle() 方法返回 false，被取反执行 if 分支，return，导致 doDispatch() 方法结束，不执行后续操作，就是不放行。</li></ul><h4 id="3-调用handler方法"><a href="#3-调用handler方法" class="headerlink" title="3. 调用handler方法"></a>3. 调用handler方法</h4><h5 id="3-1-相关组件"><a href="#3-1-相关组件" class="headerlink" title="3.1 相关组件"></a>3.1 相关组件</h5><p>接口：org.springframework.web.servlet.HandlerAdapter</p><p>作用：字面含义是适配器的意思，具体功能有三个</p><ul><li>将请求参数绑定到实体类对象中</li><li>给目标 handler 方法准备所需的其他参数，例如：<ul><li>Model、ModelMap、Map……</li><li>原生 Servlet API：request、response、session……</li><li>BindingResult</li><li>@RequestParam 注解标记的零散请求参数</li><li>@PathVariable 注解标记的路径变量</li></ul></li><li>调用目标 handler 方法</li></ul><h5 id="3-2-创建并获取这个组件"><a href="#3-2-创建并获取这个组件" class="headerlink" title="3.2 创建并获取这个组件"></a>3.2 创建并获取这个组件</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><p>所在方法：doDispatch()</p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_007.png"></p><h5 id="3-3-具体操作：调用目标-handler-方法"><a href="#3-3-具体操作：调用目标-handler-方法" class="headerlink" title="3.3 具体操作：调用目标 handler 方法"></a>3.3 具体操作：调用目标 handler 方法</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><p>所在方法：doDispatch()</p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_008.png"></p><h5 id="3-4-具体操作：注入请求参数"><a href="#3-4-具体操作：注入请求参数" class="headerlink" title="3.4 具体操作：注入请求参数"></a>3.4 具体操作：注入请求参数</h5><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_009.png">                         </p><p>通过反射给对应属性注入请求参数应该是下面的过程：</p><ul><li>获取请求参数名称</li><li>将请求参数名称首字母设定为大写</li><li>在首字母大写后的名称前附加 set，得到目标方法名</li><li>通过反射调用 setXxx() 方法</li></ul><h4 id="4-准备其他参数"><a href="#4-准备其他参数" class="headerlink" title="4. 准备其他参数"></a>4. 准备其他参数</h4><p>以 Model 为例来进行说明。</p><h5 id="4-1-背景"><a href="#4-1-背景" class="headerlink" title="4.1 背景"></a>4.1 背景</h5><p>在 handler 方法中，如果需要 Model、ModelMap、Map 等对象用来存放模型数据，那么直接在 handler 方法中声明这些类型的形参即可。</p><p>而不管我们声明 Model、ModelMap、Map 三者中的任何一个，其实实际传入的对象都是 BindingAwareModelMap 类型的。</p><h5 id="4-2-相关组件"><a href="#4-2-相关组件" class="headerlink" title="4.2 相关组件"></a>4.2 相关组件</h5><p>组件类：org.springframework.web.method.support.ModelAndViewContainer</p><p>相关属性：defaultModel</p><pre><code class="java">private final ModelMap defaultModel = new BindingAwareModelMap();</code></pre><p>从这个属性的声明能够看出：defaultModel 直接就是用 BindingAwareModelMap 对象来初始化的。</p><h5 id="4-3-相关操作"><a href="#4-3-相关操作" class="headerlink" title="4.3 相关操作"></a>4.3 相关操作</h5><p>相关接口：org.springframework.web.servlet.HandlerAdapter</p><p>所在类：org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</p><p>所在方法：invokeHandlerMethod()</p><p>操作1：创建 ModelAndViewContainer 对象</p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_010.png"></p><p>操作2：把 ModelAndViewContainer 对象传给 invokeAndHandle() 方法 </p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_011.png"></p><h3 id="第三节-调用后阶段"><a href="#第三节-调用后阶段" class="headerlink" title="第三节 调用后阶段"></a>第三节 调用后阶段</h3><h4 id="1-调用拦截器的-postHandle-方法"><a href="#1-调用拦截器的-postHandle-方法" class="headerlink" title="1. 调用拦截器的 postHandle() 方法"></a>1. 调用拦截器的 postHandle() 方法</h4><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><p>所在方法：doDispatch()</p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_012.png"></p><p>调用细节：从拦截器集合长度 - 1 开始循环，循环到 0 为止。所以是<strong>倒序</strong>执行 </p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_013.png"></p><h4 id="2-渲染视图"><a href="#2-渲染视图" class="headerlink" title="2. 渲染视图"></a>2. 渲染视图</h4><h5 id="2-1-所有后续操作的入口"><a href="#2-1-所有后续操作的入口" class="headerlink" title="2.1 所有后续操作的入口"></a>2.1 所有后续操作的入口</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><p>所在方法：doDispatch()</p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_014.png"></p><h5 id="2-2-后续细节1：处理异常"><a href="#2-2-后续细节1：处理异常" class="headerlink" title="2.2 后续细节1：处理异常"></a>2.2 后续细节1：处理异常</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><p>所在方法：processDispatchResult()</p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_015.png"></p><h5 id="2-3-后续细节2：渲染视图"><a href="#2-3-后续细节2：渲染视图" class="headerlink" title="2.3 后续细节2：渲染视图"></a>2.3 后续细节2：渲染视图</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><p>所在方法：processDispatchResult()</p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_016.png"></p><p>补充细节：模型数据存入请求域的具体位置</p><p>所在类：org.thymeleaf.context.WebEngineContext.RequestAttributesVariablesMap</p><p>所在方法：setVariable()</p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_018.png"></p><h4 id="3-调用拦截器的-afterCompletion-方法"><a href="#3-调用拦截器的-afterCompletion-方法" class="headerlink" title="3. 调用拦截器的 afterCompletion() 方法"></a>3. 调用拦截器的 afterCompletion() 方法</h4><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><p>所在方法：processDispatchResult()</p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_017.png"></p><p>调用细节：从拦截器索引开始循环，直到循环变量 i 被减到 0 为止。这样的效果是前面执行拦截器到哪里，就从哪里倒回去执行；前面没有执行的拦截器，现在也不执行。 </p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_019.png"></p><h2 id="第三章-ContextLoaderListener"><a href="#第三章-ContextLoaderListener" class="headerlink" title="第三章 ContextLoaderListener"></a>第三章 ContextLoaderListener</h2><h3 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a>第一节 概述</h3><p>目前情况：DispatcherServlet 加载 spring-mvc.xml，此时整个 Web 应用中只创建一个 IOC 容器。将来整合Mybatis、配置声明式事务，全部在 spring-mvc.xml 配置文件中配置也是可以的。可是这样会导致配置文件太长，不容易维护。</p><p>所以想到把配置文件分开：</p><ul><li>处理浏览器请求相关：spring-mvc.xml 配置文件</li><li>声明式事务和整合Mybatis相关：spring-persist.xml 配置文件</li></ul><p>配置文件分开之后，可以让 DispatcherServlet 加载多个配置文件。例如：</p><pre><code class="xml">&lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;</code></pre><p>如果希望这两个配置文件使用不同的机制来加载：</p><ul><li>DispatcherServlet 加载 spring-mvc.xml 配置文件：它们和处理浏览器请求相关</li><li>ContextLoaderListener 加载 spring-persist.xml 配置文件：不需要处理浏览器请求，需要配置持久化层相关功能</li></ul><p>此时会带来一个新的问题：在 Web 一个应用中就会出现两个 IOC 容器</p><ul><li>DispatcherServlet 创建一个 IOC 容器</li><li>ContextLoaderListener 创建一个 IOC 容器</li></ul><p>注意：本节我们探讨的这个技术方案并不是<strong>『必须』</strong>这样做，而仅仅是<strong>『可以』</strong>这样做。</p><h3 id="第二节-配置-ContextLoaderListener"><a href="#第二节-配置-ContextLoaderListener" class="headerlink" title="第二节 配置 ContextLoaderListener"></a>第二节 配置 ContextLoaderListener</h3><h4 id="1-创建-spring-persist-xml"><a href="#1-创建-spring-persist-xml" class="headerlink" title="1. 创建 spring-persist.xml"></a>1. 创建 spring-persist.xml</h4><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_020.png"></p><h4 id="2-配置-ContextLoaderListener"><a href="#2-配置-ContextLoaderListener" class="headerlink" title="2. 配置 ContextLoaderListener"></a>2. 配置 ContextLoaderListener</h4><pre><code class="xml">&lt;!-- 通过全局初始化参数指定 Spring 配置文件的位置 --&gt;&lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:spring-persist.xml&lt;/param-value&gt;&lt;/context-param&gt; &lt;listener&gt;    &lt;!-- 指定全类名，配置监听器 --&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;</code></pre><table><thead><tr><th>方法名</th><th>执行时机</th><th>作用</th></tr></thead><tbody><tr><td>contextInitialized()</td><td>Web 应用启动时执行</td><td>创建并初始化 IOC 容器</td></tr><tr><td>contextDestroyed()</td><td>Web 应用卸载时执行</td><td>关闭 IOC 容器</td></tr></tbody></table><h4 id="3-ContextLoader"><a href="#3-ContextLoader" class="headerlink" title="3. ContextLoader"></a>3. ContextLoader</h4><h5 id="3-1-指定配置文件位置的参数名"><a href="#3-1-指定配置文件位置的参数名" class="headerlink" title="3.1 指定配置文件位置的参数名"></a>3.1 指定配置文件位置的参数名</h5><pre><code class="java">/** * Name of servlet context parameter (i.e., &#123;@value&#125;) that can specify the * config location for the root context, falling back to the implementation&#39;s * default otherwise. * @see org.springframework.web.context.support.XmlWebApplicationContext#DEFAULT_CONFIG_LOCATION */public static final String CONFIG_LOCATION_PARAM = &quot;contextConfigLocation&quot;;</code></pre><h5 id="3-2-初始化-IOC-容器"><a href="#3-2-初始化-IOC-容器" class="headerlink" title="3.2 初始化 IOC 容器"></a>3.2 初始化 IOC 容器</h5><p>方法名：initWebApplicationContext() </p><h5 id="3-3-创建-IOC-容器"><a href="#3-3-创建-IOC-容器" class="headerlink" title="3.3 创建 IOC 容器"></a>3.3 创建 IOC 容器</h5><p>方法名：createWebApplicationContext() </p><h3 id="第三节-探讨两个IOC容器之间的关系"><a href="#第三节-探讨两个IOC容器之间的关系" class="headerlink" title="第三节 探讨两个IOC容器之间的关系"></a>第三节 探讨两个IOC容器之间的关系</h3><p>打印两个 IOC 容器对象的 toString() 方法：  </p><pre><code class="java">Object springIOC = servletContext.getAttribute(&quot;org.springframework.web.context.WebApplicationContext.ROOT&quot;logger.debug(springIOC.toString());Object springMVCIOC = servletContext.getAttribute(&quot;org.springframework.web.servlet.FrameworkServlet.CONTEXT.dispatcherServlet&quot;);logger.debug(springMVCIOC.toString());</code></pre><p>打印效果是：</p><blockquote><p><strong>Root</strong> WebApplicationContext, started on Thu Jun 17 14:49:17 CST 2021</p><p>WebApplicationContext for namespace ‘dispatcherServlet-servlet’, started on Thu Jun 17 14:49:18 CST 2021, <strong>parent</strong>: Root WebApplicationContext</p></blockquote><p>结论：两个组件分别创建的 IOC 容器是<strong>父子</strong>关系。</p><ul><li>父容器：ContextLoaderListener 创建的 IOC 容器</li><li>子容器：DispatcherServlet 创建的 IOC 容器</li></ul><p>父子关系是如何决定的？</p><ul><li>ContextLoaderListener 初始化时如果检查到有已经存在的根级别 IOC 容器，那么会抛出异常。</li><li>DispatcherServlet 创建的 IOC 容器会在初始化时先检查当前环境下是否存在已经创建好的 IOC 容器。<ul><li>如果有：则将已存在的这个 IOC 容器设置为自己的父容器</li><li>如果没有：则将自己设置为 root 级别的 IOC 容器</li></ul></li><li>同时 Tomcat 在读取 web.xml 之后，加载组件的顺序就是监听器、过滤器、Servlet。</li></ul><p>DispatcherServlet 创建的 IOC 容器设置父容器的源码截图：</p><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><p>所在方法：createWebApplicationContext()</p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_021.png"></p><h3 id="第四节-探讨两个-IOC-容器之间-bean-的互相访问"><a href="#第四节-探讨两个-IOC-容器之间-bean-的互相访问" class="headerlink" title="第四节 探讨两个 IOC 容器之间 bean 的互相访问"></a>第四节 探讨两个 IOC 容器之间 bean 的互相访问</h3><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_022.png"></p><p>spring-mvc.xml配置方式：</p><pre><code class="xml">&lt;context:component-scan base-package=&quot;com.atguigu.spring.component.controller&quot;/&gt;</code></pre><p>spring-persist.xml配置方式：</p><pre><code class="xml">&lt;context:component-scan base-package=&quot;com.atguigu.spring.component.service,com.atguigu.spring.component.dao&quot;/&gt;</code></pre><p>所以bean所属IOC容器的关系：</p><ul><li>父容器<ul><li>EmpService</li><li>EmpDao</li></ul></li><li>子容器<ul><li>EmpController</li></ul></li></ul><p>结论：子容器中的 EmpController 装配父容器中的 EmpService 能够正常工作。说明子容器可以访问父容器中的bean。</p><p>分析：“子可用父，父不能用子”的根本原因是子容器中有一个属性 <strong>getParent()</strong> 可以获取到父容器这个对象的引用。</p><p>源码依据：</p><ul><li>在 AbstractApplicationContext 类中，有 parent 属性</li><li>在 AbstractApplicationContext 类中，有获取 parent 属性的 getParent() 方法</li><li>子容器可以通过 getParent() 方法获取到父容器对象的引用</li><li>进而调用父容器中类似 “getBean()” 这样的方法获取到需要的 bean 完成装配</li><li>而父容器中并没有类似 “getChildren()“ 这样的方法，所以没法拿到子容器对象的引用</li></ul><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_023.png"></p><h3 id="第五节-有可能重复创建对象"><a href="#第五节-有可能重复创建对象" class="headerlink" title="第五节 有可能重复创建对象"></a>第五节 有可能重复创建对象</h3><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_024.png"></p><h4 id="1-查看日志确认是否重复创建了对象"><a href="#1-查看日志确认是否重复创建了对象" class="headerlink" title="1. 查看日志确认是否重复创建了对象"></a>1. 查看日志确认是否重复创建了对象</h4><blockquote><p>Root WebApplicationContext: initialization started</p><p>……</p><p>Creating shared instance of singleton bean ‘helloDao’ Creating shared instance of singleton bean ‘helloHandler’ Creating shared instance of singleton bean ‘helloService’</p><p>……</p><p>Root WebApplicationContext initialized in 1150 ms</p><p>……</p><p>Refreshing WebApplicationContext for namespace ‘dispatcherServlet-servlet’</p><p>……</p><p>Creating shared instance of singleton bean ‘helloDao’</p><p>Creating shared instance of singleton bean ‘helloHandler’</p><p>Creating shared instance of singleton bean ‘helloService’</p><p>……</p></blockquote><h4 id="2-重复创建对象的问题"><a href="#2-重复创建对象的问题" class="headerlink" title="2. 重复创建对象的问题"></a>2. 重复创建对象的问题</h4><ul><li><p>浪费内存空间</p></li><li><p>两个 IOC 容器能力是不同的</p><ul><li><p>spring-mvc.xml：仅配置和处理请求相关的功能。所以不能给 service 类附加声明式事务功能。</p><p>结论：基于 spring-mvc.xml 配置文件创建的 EmpService 的 bean 不带有声明式事务的功能</p><p>影响：DispatcherServlet 处理浏览器请求时会调用自己创建的 EmpController，然后再调用自己创建的EmpService，而这个 EmpService 是没有事务的，所以处理请求时<strong>没有事务功能的支持</strong>。</p></li><li><p>spring-persist.xml：配置声明式事务。所以可以给 service 类附加声明式事务功能。</p><p>结论：基于 spring-persist.xml 配置文件创建的 EmpService 有声明式事务的功能</p><p>影响：由于 DispatcherServlet 的 IOC 容器会优先使用自己创建的 EmpController，进而装配自己创建的EmpService，所以基于 spring-persist.xml 配置文件创建的有声明式事务的 EmpService 用不上。</p></li></ul></li></ul><h4 id="3-解决重复创建对象的问题"><a href="#3-解决重复创建对象的问题" class="headerlink" title="3. 解决重复创建对象的问题"></a>3. 解决重复创建对象的问题</h4><h5 id="3-1-解决方案一"><a href="#3-1-解决方案一" class="headerlink" title="3.1 解决方案一"></a>3.1 解决方案一</h5><p>让两个配置文件配置自动扫描的包时，各自扫描各自的组件。</p><ul><li>SpringMVC 就扫描 XxxHandler</li><li>Spring 扫描 XxxService 和 XxxDao</li></ul><h5 id="3-2-解决方案二"><a href="#3-2-解决方案二" class="headerlink" title="3.2 解决方案二"></a>3.2 解决方案二</h5><p>如果由于某种原因，必须扫描同一个包，确实存在重复创建对象的问题，可以采取下面的办法处理。</p><ul><li>spring-mvc.xml 配置文件在整体扫描的基础上进一步配置：仅包含被 @Controller 注解标记的类。</li><li>spring-persist.xml 配置在整体扫描的基础上进一步配置：排除被 @Controller 注解标记的类。</li></ul><p>具体spring-mvc.xml配置文件中的配置方式如下：</p><pre><code class="xml">&lt;!-- 两个Spring的配置文件扫描相同的包 --&gt;&lt;!-- 为了解决重复创建对象的问题，需要进一步制定扫描组件时的规则 --&gt;&lt;!-- 目标：『仅』包含@Controller注解标记的类 --&gt;&lt;!-- use-default-filters=&quot;false&quot;表示关闭默认规则，表示什么都不扫描，此时不会把任何组件加入IOC容器；        再配合context:include-filter实现“『仅』包含”效果 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu.spring.component&quot; use-default-filters=&quot;false&quot;&gt;    &lt;!-- context:include-filter标签配置一个“扫描组件时要包含的类”的规则，追加到默认规则中 --&gt;    &lt;!-- type属性：指定规则的类型，根据什么找到要包含的类，现在使用annotation表示基于注解来查找 --&gt;    &lt;!-- expression属性：规则的表达式。如果type属性选择了annotation，那么expression属性配置注解的全类名 --&gt;    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt;</code></pre><p>具体spring-persist.xml配置文件中的配置方式如下： </p><pre><code class="xml">&lt;!-- 两个Spring的配置文件扫描相同的包 --&gt;&lt;!-- 在默认规则的基础上排除标记了@Controller注解的类 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu.spring.component&quot;&gt;    &lt;!-- 配置具体排除规则：把标记了@Controller注解的类排除在扫描范围之外 --&gt;    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt;</code></pre><h3 id="第六节-小结"><a href="#第六节-小结" class="headerlink" title="第六节 小结"></a>第六节 小结</h3><ul><li>DispatcherServlet 和 ContextLoaderListener 并存<ul><li>DispatcherServlet 负责加载 SpringMVC 的配置文件，例如：spring-mvc.xml</li><li>ContextLoaderListener 负责加载 Spring 的配置文件，例如：spring-persist.xml</li></ul></li><li>两个 IOC 容器的关系：<ul><li>ContextLoaderListener 创建的容器是父容器</li><li>DispatcherServlet 创建的容器是子容器</li></ul></li><li>bean 的装配<ul><li>子容器可以访问父容器中的 bean</li><li>父容器不能访问子容器中的 bean</li></ul></li><li>两个容器扫描同一个包会导致重复创建对象<ul><li>解决办法一：各自扫描各自的包</li><li>解决办法二：<ul><li>DispatcherServlet 创建的容器仅扫描 handler</li><li>ContextLoaderListener 创建的容器不扫描 handler</li></ul></li></ul></li></ul><h2 id="第四章-SSM整合-重点"><a href="#第四章-SSM整合-重点" class="headerlink" title="第四章 SSM整合(重点)"></a>第四章 SSM整合(重点)</h2><h3 id="第一节-Spring-和-Mybatis-整合"><a href="#第一节-Spring-和-Mybatis-整合" class="headerlink" title="第一节 Spring 和 Mybatis 整合"></a>第一节 Spring 和 Mybatis 整合</h3><h4 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h4><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_025.png"></p><h4 id="2-Mybatis-Spring技术"><a href="#2-Mybatis-Spring技术" class="headerlink" title="2. Mybatis-Spring技术"></a>2. Mybatis-Spring技术</h4><p><a href="http://mybatis.org/spring/zh/index.html">官方介绍</a></p><p>相关技术之间版本匹配说明：</p><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_026.png"></p><p>Mybatis-Spring 的依赖：</p><pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;2.0.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="3-总体-SSM-整合所需依赖"><a href="#3-总体-SSM-整合所需依赖" class="headerlink" title="3. 总体 SSM 整合所需依赖"></a>3. 总体 SSM 整合所需依赖</h4><pre><code class="xml">&lt;!-- SpringMVC --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring 持久化层所需依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;    &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 日志 --&gt;&lt;dependency&gt;    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;    &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- ServletAPI --&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- Spring5和Thymeleaf整合包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;    &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;    &lt;version&gt;3.0.12.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Mybatis核心 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.7&lt;/version&gt;&lt;/dependency&gt;&lt;!-- MySQL驱动 --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据源 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.0.31&lt;/version&gt;&lt;/dependency&gt;&lt;!-- junit5 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;    &lt;version&gt;5.7.0&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- Spring 的测试功能 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Mybatis 和 Spring 的整合包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;2.0.6&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入LomBok的依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.8&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre><h4 id="4-配置数据源"><a href="#4-配置数据源" class="headerlink" title="4. 配置数据源"></a>4. 配置数据源</h4><h5 id="4-1-创建-jdbc-properties"><a href="#4-1-创建-jdbc-properties" class="headerlink" title="4.1 创建 jdbc.properties"></a>4.1 创建 jdbc.properties</h5><pre><code class="properties">jdbc.user=rootjdbc.password=123456jdbc.url=jdbc:mysql://localhost:3306/mybatis-examplejdbc.driver=com.mysql.jdbc.Driver</code></pre><h5 id="4-2-加入日志配置文件"><a href="#4-2-加入日志配置文件" class="headerlink" title="4.2 加入日志配置文件"></a>4.2 加入日志配置文件</h5><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_027.png"></p><h5 id="4-3-创建spring配置文件"><a href="#4-3-创建spring配置文件" class="headerlink" title="4.3 创建spring配置文件"></a>4.3 创建spring配置文件</h5><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_028.png"></p><pre><code class="xml">&lt;!-- 加载外部属性文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 配置数据源 --&gt;&lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;&lt;/bean&gt;</code></pre><h5 id="4-4-创建-junit-测试类"><a href="#4-4-创建-junit-测试类" class="headerlink" title="4.4 创建 junit 测试类"></a>4.4 创建 junit 测试类</h5><pre><code class="java">@SpringJUnitConfig(locations = &#123;&quot;classpath:spring-persist.xml&quot;&#125;)public class SSMTest &#123;     @Autowired    private DataSource dataSource;     Logger logger = LoggerFactory.getLogger(getClass());     @Test    public void testConn() throws SQLException &#123;        Connection connection = dataSource.getConnection();        logger.debug(connection.toString());    &#125; &#125;</code></pre><h4 id="5-配置-SqlSessionFactoryBean"><a href="#5-配置-SqlSessionFactoryBean" class="headerlink" title="5. 配置 SqlSessionFactoryBean"></a>5. 配置 SqlSessionFactoryBean</h4><h5 id="5-1-创建-Mybatis-全局配置文件"><a href="#5-1-创建-Mybatis-全局配置文件" class="headerlink" title="5.1 创建 Mybatis 全局配置文件"></a>5.1 创建 Mybatis 全局配置文件</h5><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_029.png"></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;     &lt;!-- Mybatis全局配置 --&gt;    &lt;settings&gt;        &lt;!-- 将数据库表字段映射到驼峰式命名的Java实体类属性中 --&gt;        &lt;!-- 数据库表字段格式：单词_单词 --&gt;        &lt;!-- Java实体类属性：首字母小写的驼峰式命名 --&gt;        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;    &lt;/settings&gt; &lt;/configuration&gt;</code></pre><h5 id="5-2-创建模型"><a href="#5-2-创建模型" class="headerlink" title="5.2 创建模型"></a>5.2 创建模型</h5><pre><code class="java">package com.atguigu.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;/** * 包名:com.atguigu.pojo * * @author Leevi * 日期2021-09-10  09:04 */@Data@AllArgsConstructor@NoArgsConstructorpublic class Employee &#123;    private Integer empId;    private String empName;    private Double empSalary;&#125;</code></pre><h5 id="5-3-创建Mapper接口"><a href="#5-3-创建Mapper接口" class="headerlink" title="5.3 创建Mapper接口"></a>5.3 创建Mapper接口</h5><pre><code class="java">package com.atguigu.mapper;import com.atguigu.pojo.Employee;import java.util.List;/** * 包名:com.atguigu.mapper * * @author Leevi * 日期2021-09-10  09:05 */public interface EmployeeMapper &#123;    /**     * 查询所有员工     * @return     */    List&lt;Employee&gt; findAll();&#125;</code></pre><h5 id="5-4-创建Mapper配置文件-存放路径在resources中要与对应的接口的路径一致"><a href="#5-4-创建Mapper配置文件-存放路径在resources中要与对应的接口的路径一致" class="headerlink" title="5.4 创建Mapper配置文件(存放路径在resources中要与对应的接口的路径一致)"></a>5.4 创建Mapper配置文件(存放路径在resources中要与对应的接口的路径一致)</h5><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_037.png" style="zoom:80%;"><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper            PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;            &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.atguigu.mapper.EmployeeMapper&quot;&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;Employee&quot;&gt;        select * from t_emp    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h5 id="5-5-配置-SqlSessionFactoryBean"><a href="#5-5-配置-SqlSessionFactoryBean" class="headerlink" title="5.5 配置 SqlSessionFactoryBean"></a>5.5 配置 SqlSessionFactoryBean</h5><h6 id="5-5-1-风格一：保留-Mybatis-全局配置文件"><a href="#5-5-1-风格一：保留-Mybatis-全局配置文件" class="headerlink" title="5.5.1 风格一：保留 Mybatis 全局配置文件"></a>5.5.1 风格一：保留 Mybatis 全局配置文件</h6><pre><code class="xml">&lt;bean id=&quot;sqlSessionFactoryBean&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!--注入数据源--&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt;        &lt;!--注入mybatis的全局配置文件的路径--&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;    &lt;/bean&gt;</code></pre><h6 id="5-5-2-风格二：彻底舍弃-Mybatis-全局配置文件"><a href="#5-5-2-风格二：彻底舍弃-Mybatis-全局配置文件" class="headerlink" title="5.5.2 风格二：彻底舍弃 Mybatis 全局配置文件"></a>5.5.2 风格二：彻底舍弃 Mybatis 全局配置文件</h6><pre><code class="xml">&lt;bean id=&quot;sqlSessionFactoryBean&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;!--注入数据源--&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt;    &lt;!--想配置驼峰,但是又没有Mybatis的核心配置文件--&gt;    &lt;property name=&quot;configuration&quot;&gt;        &lt;bean class=&quot;org.apache.ibatis.session.Configuration&quot;&gt;            &lt;!--驼峰配置--&gt;            &lt;property name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;            &lt;!--懒加载配置--&gt;            &lt;property name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;        &lt;/bean&gt;    &lt;/property&gt;    &lt;!--配置别名包扫描--&gt;    &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.atguigu.pojo&quot;/&gt;    &lt;!--单独扫描映射配置文件:注意不是目录路径--&gt;    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mappers/*Mapper.xml&quot;/&gt;&lt;/bean&gt;</code></pre><p>注意：上面两种方式如果并存，会抛出异常：</p><blockquote><p>java.lang.IllegalStateException: Property ‘configuration’ and ‘configLocation’ can not specified with together</p></blockquote><h4 id="6-配置-Mapper-接口扫描器"><a href="#6-配置-Mapper-接口扫描器" class="headerlink" title="6. 配置 Mapper 接口扫描器"></a>6. 配置 Mapper 接口扫描器</h4><h5 id="6-1-方式一：使用扫描器"><a href="#6-1-方式一：使用扫描器" class="headerlink" title="6.1 方式一：使用扫描器"></a>6.1 方式一：使用扫描器</h5><pre><code class="xml">&lt;!-- 配置 Mapper 接口类型的bean的扫描器 --&gt;&lt;bean id=&quot;mapperScannerConfigurer&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;com.atguigu.mapper&quot;/&gt;&lt;/bean&gt;</code></pre><h5 id="6-2-方式二：使用-mybatis-spring-名称空间"><a href="#6-2-方式二：使用-mybatis-spring-名称空间" class="headerlink" title="6.2 方式二：使用 mybatis-spring 名称空间"></a>6.2 方式二：使用 mybatis-spring 名称空间</h5><pre><code class="xml">&lt;!--        3. Mapper接口的包扫描        目的:创建Mapper接口的代理对象    --&gt;&lt;mybatis-spring:scan base-package=&quot;com.atguigu.mapper&quot;/&gt;</code></pre><h4 id="7-测试"><a href="#7-测试" class="headerlink" title="7. 测试"></a>7. 测试</h4><pre><code class="java">@Autowiredprivate EmpMapper empMapper; @Testpublic void testMybatis() &#123;    List&lt;Emp&gt; empList = empMapper.selectAll();     for (Emp emp : empList) &#123;        logger.debug(emp.toString());    &#125;&#125;</code></pre><h3 id="第二节-加入声明式事务"><a href="#第二节-加入声明式事务" class="headerlink" title="第二节 加入声明式事务"></a>第二节 加入声明式事务</h3><h4 id="1-配置事务管理器"><a href="#1-配置事务管理器" class="headerlink" title="1. 配置事务管理器"></a>1. 配置事务管理器</h4><pre><code class="xml">&lt;!-- 配置事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;!-- 装配数据源 --&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt;&lt;/bean&gt; &lt;!-- 开启基于注解的声明式事务 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</code></pre><h4 id="2-测试"><a href="#2-测试" class="headerlink" title="2. 测试"></a>2. 测试</h4><h5 id="2-1-创建-Service-组件"><a href="#2-1-创建-Service-组件" class="headerlink" title="2.1 创建 Service 组件"></a>2.1 创建 Service 组件</h5><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_030.png"></p><pre><code class="java">@Servicepublic class EmpServiceImpl implements EmpService &#123;     @Autowired    private EmpMapper empMapper;     @Override    @Transactional(readOnly = true)    public List&lt;Emp&gt; getAll() &#123;        return empMapper.selectAll();    &#125;&#125;</code></pre><h5 id="2-2-配置自动扫描的包"><a href="#2-2-配置自动扫描的包" class="headerlink" title="2.2 配置自动扫描的包"></a>2.2 配置自动扫描的包</h5><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_028.png"></p><pre><code class="xml">&lt;!--包扫描:配置业务层的组件--&gt;&lt;context:component-scan base-package=&quot;com.atguigu.service&quot;/&gt;</code></pre><h5 id="2-3-junit"><a href="#2-3-junit" class="headerlink" title="2.3 junit"></a>2.3 junit</h5><pre><code class="java">@Autowiredprivate EmpService empService; @Testpublic void testTx() &#123;    List&lt;Emp&gt; empList = empService.getAll();    for (Emp emp : empList) &#123;        System.out.println(&quot;emp = &quot; + emp);    &#125;&#125;</code></pre><h3 id="第三节-Spring-和-SpringMVC-整合"><a href="#第三节-Spring-和-SpringMVC-整合" class="headerlink" title="第三节 Spring 和 SpringMVC 整合"></a>第三节 Spring 和 SpringMVC 整合</h3><h4 id="1-整合的本质"><a href="#1-整合的本质" class="headerlink" title="1. 整合的本质"></a>1. 整合的本质</h4><ul><li>ContextLoaderListener：读取 spring-persist.xml</li><li>DispatcherServlet：读取 spring-mvc.xml</li></ul><h4 id="2-web-xml配置"><a href="#2-web-xml配置" class="headerlink" title="2. web.xml配置"></a>2. web.xml配置</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;         version=&quot;2.5&quot;&gt;    &lt;!--        在服务器启动的时候加载配置文件，创建ioc容器有两种方式:        1. DispatcherServlet        2. ContextLoaderListener    --&gt;    &lt;!--1. 使用DispatcherServlet加载spring-mvc.xml--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;!--使用ContextLoaderListener加载spring-persist.xml--&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:spring-persist.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;!-- 配置过滤器解决 POST 请求的字符乱码问题 --&gt;    &lt;filter&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;!-- encoding参数指定要使用的字符集名称 --&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;!-- 请求强制编码 --&gt;        &lt;init-param&gt;            &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt;            &lt;param-value&gt;true&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;!-- 响应强制编码 --&gt;        &lt;init-param&gt;            &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt;            &lt;param-value&gt;true&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;</code></pre><h4 id="3-SpringMVC-配置"><a href="#3-SpringMVC-配置" class="headerlink" title="3. SpringMVC 配置"></a>3. SpringMVC 配置</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/context                           https://www.springframework.org/schema/context/spring-context.xsd                           http://www.springframework.org/schema/mvc                           https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!--1. 包扫描--&gt;    &lt;context:component-scan base-package=&quot;com.atguigu.handler&quot;/&gt;    &lt;!--2. 加载mvc注解驱动--&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!--3. 静态资源处理--&gt;    &lt;mvc:default-servlet-handler/&gt;    &lt;!--4. 配置Thymeleaf的模板解析器--&gt;    &lt;!-- Thymeleaf视图解析器 --&gt;    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt;        &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt;        &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt;        &lt;property name=&quot;templateEngine&quot;&gt;            &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt;                &lt;property name=&quot;templateResolver&quot;&gt;                    &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt;                        &lt;!-- 视图前缀 --&gt;                        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt;                        &lt;!-- 视图后缀 --&gt;                        &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt;                        &lt;!--模板类型--&gt;                        &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt;                        &lt;!--模板的字符编码--&gt;                        &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt;                    &lt;/bean&gt;                &lt;/property&gt;            &lt;/bean&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!--配置view-controller--&gt;    &lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;portal&quot;/&gt;    &lt;mvc:view-controller path=&quot;/index.html&quot; view-name=&quot;portal&quot;/&gt;&lt;/beans&gt;</code></pre><h4 id="4-创建组件"><a href="#4-创建组件" class="headerlink" title="4. 创建组件"></a>4. 创建组件</h4><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_031.png"></p><pre><code class="java">package com.atguigu.handler;import com.atguigu.pojo.Employee;import com.atguigu.service.EmployeeService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;/** * 包名:com.atguigu.handler * * @author Leevi * 日期2021-09-10  10:01 */@Controller@RequestMapping(&quot;/employee&quot;)public class EmployeeHandler &#123;    @Autowired    private EmployeeService employeeService;    @RequestMapping(&quot;/findAll&quot;)    public String findAll(Model model)&#123;        //1. 调用业务层的方法查询所有员工信息        List&lt;Employee&gt; employeeList = employeeService.findAll();        //2. 将employeeList存储到请求域        model.addAttribute(&quot;list&quot;,employeeList);        //3. 返回逻辑视图        return &quot;emp-list&quot;;    &#125;&#125;</code></pre><h4 id="5-页面操作"><a href="#5-页面操作" class="headerlink" title="5. 页面操作"></a>5. 页面操作</h4><h5 id="5-1-首页超链接"><a href="#5-1-首页超链接" class="headerlink" title="5.1 首页超链接"></a>5.1 首页超链接</h5><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_032.png"></p><pre><code class="html">&lt;a th:href=&quot;@&#123;/employee/findAll&#125;&quot;&gt;显示员工列表&lt;/a&gt;</code></pre><h5 id="5-2-显示数据的页面"><a href="#5-2-显示数据的页面" class="headerlink" title="5.2 显示数据的页面"></a>5.2 显示数据的页面</h5><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_033.png"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;员工信息展示页面&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            table &#123;                border-collapse: collapse;                margin: 0px auto 0px auto;            &#125;            table th, td &#123;                border: 1px solid black;                text-align: center;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;table&gt;            &lt;tr&gt;                &lt;th&gt;ID&lt;/th&gt;                &lt;th&gt;NAME&lt;/th&gt;                &lt;th&gt;SALARY&lt;/th&gt;            &lt;/tr&gt;            &lt;tbody th:if=&quot;$&#123;#lists.isEmpty(list)&#125;&quot;&gt;                &lt;tr&gt;                    &lt;td colspan=&quot;3&quot;&gt;抱歉！没有查询到数据！&lt;/td&gt;                &lt;/tr&gt;            &lt;/tbody&gt;            &lt;tbody th:if=&quot;$&#123;not #lists.isEmpty(list)&#125;&quot;&gt;                &lt;tr th:each=&quot;emp : $&#123;list&#125;&quot;&gt;                    &lt;td th:text=&quot;$&#123;emp.empId&#125;&quot;&gt;这里显示员工ID&lt;/td&gt;                    &lt;td th:text=&quot;$&#123;emp.empName&#125;&quot;&gt;这里显示员工NAME&lt;/td&gt;                    &lt;td th:text=&quot;$&#123;emp.empSalary&#125;&quot;&gt;这里显示员工SALARY&lt;/td&gt;                &lt;/tr&gt;            &lt;/tbody&gt;        &lt;/table&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="第五章-分页"><a href="#第五章-分页" class="headerlink" title="第五章 分页"></a>第五章 分页</h2><h3 id="第一节-分页的概述"><a href="#第一节-分页的概述" class="headerlink" title="第一节 分页的概述"></a>第一节 分页的概述</h3><h4 id="1-为什么要分页"><a href="#1-为什么要分页" class="headerlink" title="1. 为什么要分页"></a>1. 为什么要分页</h4><p>如果应用程序显示数据不分页，会有三个问题：</p><ul><li>用户查看数据非常不方便。</li><li>所有数据不分冷热全部显示出来，冷数据白白占用存储空间，浪费内存。</li><li>在服务器端查询全部数据占用内存很大，给整个系统增加了很大压力。</li></ul><h4 id="2-分页本身的概念"><a href="#2-分页本身的概念" class="headerlink" title="2. 分页本身的概念"></a>2. 分页本身的概念</h4><p>把系统中要显示的数据分成较小的单元，每个单元作为『一页』显示给用户。每次访问服务器只查询一页数据。</p><p>分页的好处：</p><ul><li>用户体验较好。</li><li>服务器端每次只查询一部分数据，内存压力减小。</li><li>对冷数据减少查询的次数，据此对系统性能进行优化。</li></ul><h4 id="3-分页的细节"><a href="#3-分页的细节" class="headerlink" title="3. 分页的细节"></a>3. 分页的细节</h4><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_034.png"></p><h4 id="4-实现分页的基本逻辑"><a href="#4-实现分页的基本逻辑" class="headerlink" title="4. 实现分页的基本逻辑"></a>4. 实现分页的基本逻辑</h4><h5 id="4-1-物理分页"><a href="#4-1-物理分页" class="headerlink" title="4.1 物理分页"></a>4.1 物理分页</h5><p>具体数据库不同，分页语法有区别。下面我们以 MySQL 为例来说明。MySQL 的分页需要借助 LIMIT 子句来完成。 </p><pre><code class="mysql">select emp_id,emp_name,emp_salary from t_emp limit 0,5; # 查询第一页数据select emp_id,emp_name,emp_salary from t_emp limit 5,5; # 查询第二页数据select emp_id,emp_name,emp_salary from t_emp limit 10,5;# 查询第三页数据</code></pre><p>LIMIT 子句的公式：</p><blockquote><p>limit (pageNo-1)*pageSize,pageSize</p></blockquote><p>注意：在 SQL 的语法中，LIMIT 子句必须出现在 SQL 语句最后。</p><h5 id="4-2-逻辑分页"><a href="#4-2-逻辑分页" class="headerlink" title="4.2 逻辑分页"></a>4.2 逻辑分页</h5><h6 id="4-2-1-需求"><a href="#4-2-1-需求" class="headerlink" title="4.2.1 需求"></a>4.2.1 需求</h6><p>为了能够在页面上全面显示分页相关的细节数据，总页数需要计算得到。 </p><h6 id="4-2-2-总页数计算方式"><a href="#4-2-2-总页数计算方式" class="headerlink" title="4.2.2 总页数计算方式"></a>4.2.2 总页数计算方式</h6><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_035.png"></p><h6 id="4-2-3-页码的合理化"><a href="#4-2-3-页码的合理化" class="headerlink" title="4.2.3 页码的合理化"></a>4.2.3 页码的合理化</h6><p>页码的有效范围：1~总页数。修正方式：</p><ul><li>用户输入的页码 &lt; 1：将页码设定为第一页</li><li>用户输入的页码 &gt; 总页数：将页码设定为最后一页</li></ul><h6 id="4-2-4-分页执行流程"><a href="#4-2-4-分页执行流程" class="headerlink" title="4.2.4 分页执行流程"></a>4.2.4 分页执行流程</h6><ul><li>查询总记录数(用count()函数)</li><li>查询当前页数据(使用limit查询)</li><li>根据总记录数和每页条数计算总页数</li><li>在1~总页数之间修正页码</li><li>封装上述所有数据，发送到页面显示</li></ul><h3 id="第二节-实现分页"><a href="#第二节-实现分页" class="headerlink" title="第二节 实现分页"></a>第二节 实现分页</h3><h4 id="1-Mybatis的分页插件"><a href="#1-Mybatis的分页插件" class="headerlink" title="1. Mybatis的分页插件"></a>1. Mybatis的分页插件</h4><p>具体使用细节可以参考：<a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md">官方文档</a> </p><h5 id="1-1-引入依赖"><a href="#1-1-引入依赖" class="headerlink" title="1.1 引入依赖"></a>1.1 引入依赖</h5><pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;    &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h5 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2 配置"></a>1.2 配置</h5><pre><code class="xml">&lt;!-- 配置 SqlSessionFactoryBean --&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;     ……     &lt;!-- 在 plugins 属性中配置 Mybatis 插件 --&gt;    &lt;property name=&quot;plugins&quot;&gt;        &lt;array&gt;            &lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;                &lt;property name=&quot;properties&quot;&gt;                    &lt;props&gt;                        &lt;!-- 设置 reasonable 为 true 表示将页码进行合理化修正。页码的有效范围：1~总页数 --&gt;                        &lt;prop key=&quot;reasonable&quot;&gt;true&lt;/prop&gt;                                                &lt;!-- 数据库方言：同样都是 SQL 语句，拿到不同数据库中，在语法上会有差异 --&gt;                        &lt;!-- 默认情况下，按照 MySQL 作为数据库方言来运行 --&gt;                        &lt;prop key=&quot;helperDialect&quot;&gt;mysql&lt;/prop&gt;                    &lt;/props&gt;                &lt;/property&gt;            &lt;/bean&gt;        &lt;/array&gt;    &lt;/property&gt; &lt;/bean&gt;</code></pre><h4 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><h5 id="2-1-首页超链接"><a href="#2-1-首页超链接" class="headerlink" title="2.1 首页超链接"></a>2.1 首页超链接</h5><pre><code class="html">&lt;a th:href=&quot;@&#123;/get/page/1&#125;&quot;&gt;显示分页数据&lt;/a&gt;</code></pre><h5 id="2-2-handler-方法"><a href="#2-2-handler-方法" class="headerlink" title="2.2 handler 方法"></a>2.2 handler 方法</h5><pre><code class="java">@RequestMapping(&quot;/get/page/&#123;pageNo&#125;&quot;)public String getPage(        @PathVariable(&quot;pageNo&quot;) Integer pageNo,         Model model) &#123;     // PageInfo 对象封装了和分页相关的所有信息    PageInfo&lt;Emp&gt; pageInfo = empService.getPageInfo(pageNo);        // 将 PageInfo 对象存入模型    model.addAttribute(&quot;pageInfo&quot;, pageInfo);        return &quot;emp-page&quot;;&#125;</code></pre><h5 id="2-3-service-方法"><a href="#2-3-service-方法" class="headerlink" title="2.3 service 方法"></a>2.3 service 方法</h5><pre><code class="java">@Overridepublic PageInfo&lt;Emp&gt; getPageInfo(Integer pageNo) &#123;     // 1、确定每页显示数据的条数    int pageSize = 5;     // 2、设定分页数据：开启分页功能。开启后，后面执行的 SELECT 语句会自动被附加 LIMIT 子句，    // 而且会自动查询总记录数    PageHelper.startPage(pageNo, pageSize);     // 3、正常执行查询    List&lt;Emp&gt; empList = empMapper.selectAll();     // 4、封装为 PageInfo 对象返回    return new PageInfo&lt;&gt;(empList);&#125;</code></pre><h5 id="2-4-页面展示分页数据"><a href="#2-4-页面展示分页数据" class="headerlink" title="2.4 页面展示分页数据"></a>2.4 页面展示分页数据</h5><h6 id="2-4-1-显示列表"><a href="#2-4-1-显示列表" class="headerlink" title="2.4.1 显示列表"></a>2.4.1 显示列表</h6><pre><code class="html">……    &lt;tr th:each=&quot;emp : $&#123;pageInfo.list&#125;&quot;&gt;……</code></pre><h6 id="2-4-2-显示翻页导航栏"><a href="#2-4-2-显示翻页导航栏" class="headerlink" title="2.4.2 显示翻页导航栏"></a>2.4.2 显示翻页导航栏</h6><pre><code class="html">&lt;span th:if=&quot;$&#123;pageInfo.hasPreviousPage&#125;&quot;&gt;    &lt;a th:href=&quot;@&#123;/get/page/1&#125;&quot;&gt;首页&lt;/a&gt;    &lt;a th:href=&quot;@&#123;/get/page/&#125;+$&#123;pageInfo.prePage&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/span&gt; &lt;span th:each=&quot;navigator : $&#123;pageInfo.navigatepageNums&#125;&quot;&gt;     &lt;!-- th:if 判断当前标签是否是当前页 --&gt;    &lt;!-- 如果不是当前页则显示超链接 --&gt;    &lt;a th:if=&quot;$&#123;navigator != pageInfo.pageNum&#125;&quot;       th:href=&quot;@&#123;/get/page/&#125;+$&#123;navigator&#125;&quot;       th:text=&quot;&#39;[&#39;+$&#123;navigator&#125;+&#39;]&#39;&quot;&gt;&lt;/a&gt;     &lt;!-- 如果是当前页则显示页码本身 --&gt;    &lt;span th:if=&quot;$&#123;navigator == pageInfo.pageNum&#125;&quot; th:text=&quot;&#39;[&#39;+$&#123;navigator&#125;+&#39;]&#39;&quot;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span th:if=&quot;$&#123;pageInfo.hasNextPage&#125;&quot;&gt;    &lt;a th:href=&quot;@&#123;/get/page/&#125;+$&#123;pageInfo.nextPage&#125;&quot;&gt;下一页&lt;/a&gt;    &lt;a th:href=&quot;@&#123;/get/page/&#125;+$&#123;pageInfo.pages&#125;&quot;&gt;最后一页&lt;/a&gt;&lt;/span&gt; &lt;span th:text=&quot;$&#123;pageInfo.pageNum&#125;+&#39;/&#39;+$&#123;pageInfo.pages&#125;&quot;&gt;&lt;/span&gt;</code></pre><h5 id="2-5-打印的-SQL-语句"><a href="#2-5-打印的-SQL-语句" class="headerlink" title="2.5 打印的 SQL 语句"></a>2.5 打印的 SQL 语句</h5><p><img src="http://www.slx.blue/2021/12/13/springMVC-04/tu_036.png"></p><h3 id="第三节-为什么是-PageInfo-而不是-Page"><a href="#第三节-为什么是-PageInfo-而不是-Page" class="headerlink" title="第三节 为什么是 PageInfo 而不是 Page"></a>第三节 为什么是 PageInfo 而不是 Page</h3><h4 id="1-List接口的具体实现"><a href="#1-List接口的具体实现" class="headerlink" title="1. List接口的具体实现"></a>1. List接口的具体实现</h4><p>当我们开启了分页功能后，查询一个 List 集合，实际返回的是：com.github.pagehelper.Page 类型。这个 Page 类继承了 ArrayList，所以也兼容 List 接口类型。</p><h4 id="2-提出问题"><a href="#2-提出问题" class="headerlink" title="2. 提出问题"></a>2. 提出问题</h4><p>如果我们将 Page 类型的对象存入模型，转发到视图模板上显示数据，会存在一个问题：视图模板技术只承认这个对象是一个 List 集合，不识别 List 集合之外的其它属性。</p><p>这一点在其他场合也需要注意：我们开发时尽量不要继承 ArrayList、HashMap 等类似的集合实现类。如果继承了，那么页面视图模板技术或其他表达式往往只能识别我们的对象是一个集合，而无法访问额外封装的其他属性。</p><p>所以 Page 对象需要封装为 PageInfo，让 list、pageNum 等等数据作为 PageInfo 对象的属性；PageInfo 本身并不是一个 List 类型的集合。</p><h4 id="3-PageHelper-非侵入式的体现"><a href="#3-PageHelper-非侵入式的体现" class="headerlink" title="3. PageHelper 非侵入式的体现"></a>3. PageHelper 非侵入式的体现</h4><pre><code>PageHelper.startPage(pageNo, pageSize);</code></pre><p>开启分页功能，就在 SQL 语句后面附加 LIMIT 子句并查询总记录数；不开启就还是按照原样查询。分页功能对原有的 Mapper 接口、SQL 语句没有任何影响。这个效果可以称之为是非侵入式，也可以说是可插拔的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>ContextLoaderListener: 在服务器启动的时候加载配置文件创建IOC容器<ol><li>ContextLoaderListener创建的IOC是DispatcherServlet 创建的IOC容器的父容器；</li><li>子容器中可以拿到父容器中的对象</li><li>在我们项目中DispatchServlet只负责表现层，只扫描Controller或者是RestController</li><li>ContextLoaderListener负责其它的</li></ol></li><li>Spring与Mybatis整合<ol><li>引入mybatis-spring的整合的依赖</li><li>mybatis的使用和以前一样，只是不用写全局配置文件，并且也不用写创建持久层代理对象的那一堆代码</li><li>整合的目的: 在Spring的IOC容器中持有持久层的代理对象</li><li>整合的步骤:<ol><li>在spring的配置文件中配置SqlSessionFactoryBean<ol><li>注入dataSource</li><li>别名包扫描</li><li>驼峰配置</li><li>懒加载等等配置</li><li>指定映射配置文件的路径</li></ol></li><li>扫描持久层接口所在的包</li></ol></li></ol></li><li>PageHelper分页插件<ol><li>目标: 以非侵入的方式在后端进行分页</li><li>使用步骤:<ol><li>引入分页插件的依赖</li><li>在SqlSessionFactoryBean的配置中，配置分页插件</li><li>在业务层中:<ol><li>调用PageHelper.startPage(pageNo,pageSize)开启分页</li><li>调用查询所有的持久层方法</li><li>使用PageInfo封装分页数据    </li></ol></li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> springMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-备忘录模式</title>
      <link href="/2021/12/13/java-memento/"/>
      <url>/2021/12/13/java-memento/</url>
      
        <content type="html"><![CDATA[<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><h4 id="基本介绍："><a href="#基本介绍：" class="headerlink" title="基本介绍："></a>基本介绍：</h4><ol><li>备忘录模式(Memento patten)在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。</li><li>现实生活中的备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的含义，备忘录主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作。</li></ol><p><img src="http://www.slx.blue/2021/12/13/java-memento/memento01.png" alt="image-20211213193806376"></p><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><pre><code class="java">//用来保存状态 state可以替换为各种想要保存的东西public class Memento &#123;    private String state;    //构造器    public Memento(String state) &#123;        super();        this.state = state;    &#125;    public String getState() &#123;        return state;    &#125;&#125;</code></pre><pre><code class="java">//想要使用备忘录的对象 拥有恢复状态可备份状态的功能public class Originator &#123;    private String state;//状态信息    public String getState() &#123;        return state;    &#125;    public void setState(String state) &#123;        this.state = state;    &#125;        //编写一个方法，可以保存一个状态对象 Memento    //因此编写一个方法，返回 Memento    public Memento saveStateMemento() &#123;        return new Memento(state);    &#125;        //通过备忘录对象，恢复状态    public void getStateFromMemento(Memento memento) &#123;        state = memento.getState();    &#125;&#125;</code></pre><pre><code class="java">//对应一个角色可以有很多个状态，所以用List来保存便于管理public class Caretaker &#123;        //在List 集合中会有很多的备忘录对象    private List&lt;Memento&gt; mementoList = new ArrayList&lt;&gt;();        public void add(Memento memento) &#123;        mementoList.add(memento);    &#125;        //获取到第index个Originator 的 备忘录对象(即保存状态)    public Memento get(int index) &#123;        return mementoList.get(index);    &#125;&#125;</code></pre><pre><code class="java">//客户端public class Client &#123;    public static void main(String[] args) &#123;        Originator originator = new Originator();        Caretaker caretaker = new Caretaker();                originator.setState(&quot; 状态#1 攻击力 100 &quot;);        //保存了当前的状态        caretaker.add(originator.saveStateMemento());                originator.setState(&quot; 状态#2 攻击力 80 &quot;);        caretaker.add(originator.saveStateMemento());                originator.setState(&quot; 状态#3 攻击力 50 &quot;);        caretaker.add(originator.saveStateMemento());                System.out.println(&quot;当前的状态是 =&quot; + originator.getState());        //希望得到状态 1, 将 originator 恢复到状态1                originator.getStateFromMemento(caretaker.get(0));        System.out.println(&quot;恢复到状态1 , 当前的状态是&quot;);        System.out.println(&quot;当前的状态是 =&quot; + originator.getState());    &#125;&#125;</code></pre><p>游戏案例代码实现：</p><pre><code class="java">//守护者对象, 保存游戏角色的状态public class Caretaker &#123;    //如果只保存一次状态    private Memento memento;    //对GameRole 保存多次状态    //private ArrayList&lt;Memento&gt; mementos;    //对多个游戏角色保存多个状态    //private HashMap&lt;String, ArrayList&lt;Memento&gt;&gt; rolesMementos;    public Memento getMemento() &#123;        return memento;    &#125;    public void setMemento(Memento memento) &#123;        this.memento = memento;    &#125;&#125;</code></pre><pre><code class="java">public class GameRole &#123;    private int vit;    private int def;        //创建Memento ,即根据当前的状态得到Memento    public Memento createMemento() &#123;        return new Memento(vit, def);    &#125;        //从备忘录对象，恢复GameRole的状态    public void recoverGameRoleFromMemento(Memento memento) &#123;        this.vit = memento.getVit();        this.def = memento.getDef();    &#125;        //显示当前游戏角色的状态    public void display() &#123;        System.out.println(&quot;游戏角色当前的攻击力：&quot; + this.vit + &quot; 防御力: &quot; + this.def);    &#125;    public int getVit() &#123;        return vit;    &#125;    public void setVit(int vit) &#123;        this.vit = vit;    &#125;    public int getDef() &#123;        return def;    &#125;    public void setDef(int def) &#123;        this.def = def;    &#125;&#125;</code></pre><pre><code class="java">public class Memento &#123;    //攻击力    private int vit;    //防御力    private int def;    public Memento(int vit, int def) &#123;        super();        this.vit = vit;        this.def = def;    &#125;    public int getVit() &#123;        return vit;    &#125;    public void setVit(int vit) &#123;        this.vit = vit;    &#125;    public int getDef() &#123;        return def;    &#125;    public void setDef(int def) &#123;        this.def = def;    &#125;&#125;</code></pre><pre><code class="java">public class Client &#123;    public static void main(String[] args) &#123;        //创建游戏角色        GameRole gameRole = new GameRole();        gameRole.setVit(100);        gameRole.setDef(100);                System.out.println(&quot;和boss大战前的状态&quot;);        gameRole.display();                //把当前状态保存caretaker        Caretaker caretaker = new Caretaker();        caretaker.setMemento(gameRole.createMemento());                System.out.println(&quot;和boss大战~~~&quot;);        gameRole.setDef(30);        gameRole.setVit(30);                gameRole.display();                System.out.println(&quot;大战后，使用备忘录对象恢复到站前&quot;);                gameRole.recoverGameRoleFromMemento(caretaker.getMemento());        System.out.println(&quot;恢复后的状态&quot;);        gameRole.display();    &#125;&#125;</code></pre><h4 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ol><li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便的回到某个历史的状态。</li><li>实现了信息的封装，使得用户不需要关心状态的保存细节。</li><li>如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存、这个需要注意。</li><li>使用的应用场景<ul><li>后悔药</li><li>游戏存档</li><li>Windows里的ctrl+z</li><li>浏览器的回退 </li><li>数据库的事务管理</li></ul></li><li>为了节省内存，备忘录模式可以结合原型模式一起食用</li></ol>]]></content>
      
      
      <categories>
          
          <category> designMode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springmvc-day02</title>
      <link href="/2021/12/11/springMVC-02/"/>
      <url>/2021/12/11/springMVC-02/</url>
      
        <content type="html"><![CDATA[<h1 id="springmvc-day02"><a href="#springmvc-day02" class="headerlink" title="springmvc-day02"></a>springmvc-day02</h1><h2 id="第一章-RESTFul风格交互方式"><a href="#第一章-RESTFul风格交互方式" class="headerlink" title="第一章 RESTFul风格交互方式"></a>第一章 RESTFul风格交互方式</h2><h3 id="第一节-RESTFul概述"><a href="#第一节-RESTFul概述" class="headerlink" title="第一节 RESTFul概述"></a>第一节 RESTFul概述</h3><h4 id="1-REST的概念"><a href="#1-REST的概念" class="headerlink" title="1. REST的概念"></a>1. REST的概念</h4><p>REST：<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，表现层资源状态转移。 </p><ul><li>定位：互联网软件架构风格</li><li>倡导者：Roy Thomas Fielding</li><li>文献：Roy Thomas Fielding的博士论文</li></ul><h4 id="2-REST要解决的问题-将针对功能设计系统转变成针对资源设计系统"><a href="#2-REST要解决的问题-将针对功能设计系统转变成针对资源设计系统" class="headerlink" title="2. REST要解决的问题: 将针对功能设计系统转变成针对资源设计系统"></a>2. REST要解决的问题: 将针对功能设计系统转变成针对资源设计系统</h4><p>传统的软件系统仅在本地工作，但随着项目规模的扩大和复杂化，不但整个项目会拓展为分布式架构，很多功能也会通过网络访问第三方接口来实现。在通过网络访问一个功能的情况下，我们不能轻易假设网络状况稳定可靠。所以当一个请求发出后没有接收到对方的回应，那我们该如何判定本次操作成功与否？</p><p>下面以保存操作为例来说明一下针对功能和针对资源进行操作的区别：</p><ul><li><p>针对功能设计系统</p><p>保存一个 Employee 对象，没有接收到返回结果，判定操作失败，再保存一次。但是其实在服务器端保存操作已经成功了，只是返回结果在网络传输过程中丢失了。而第二次的补救行为则保存了重复、冗余但 id 不同的数据，这对整个系统数据来说是一种破坏。</p></li><li><p>针对资源设计系统</p><p>针对 id 为 3278 的资源执行操作，服务器端会判断指定 id 的资源是否存在。如果不存在，则执行保存操作新建数据；如果存在，则执行更新操作。所以这个操作不论执行几次，对系统的影响都是一样的。在网络状态不可靠的情况下可以多次重试，不会破坏系统数据。</p></li></ul><blockquote><p>幂等性：如果一个操作执行一次和执行 N 次对系统的影响相同，那么我们就说这个操作满足幂等性。而幂等性正是 REST 规范所倡导的。</p></blockquote><h4 id="3-RESTFul风格的架构特点"><a href="#3-RESTFul风格的架构特点" class="headerlink" title="3. RESTFul风格的架构特点"></a>3. RESTFul风格的架构特点</h4><h5 id="3-1-通过URL就知道要操作什么资源"><a href="#3-1-通过URL就知道要操作什么资源" class="headerlink" title="3.1 通过URL就知道要操作什么资源"></a>3.1 通过URL就知道要操作什么资源</h5><p>REST是针对资源设计系统，所以在REST中一个URL就对应一个资源， 为实现操作<strong>幂等性</strong>奠定基础。 </p><h5 id="3-2-通过Http请求的方式就知道要对资源进行何种操作"><a href="#3-2-通过Http请求的方式就知道要对资源进行何种操作" class="headerlink" title="3.2 通过Http请求的方式就知道要对资源进行何种操作"></a>3.2 通过Http请求的方式就知道要对资源进行何种操作</h5><p>在REST中，针对同一资源的增删改查操作的URL是完全相同的，它是通过Http协议的不同请求方式来区分不同操作的</p><p>REST 风格<strong>主张</strong>在项目设计、开发过程中，具体的操作符合 HTTP 协议定义的请求方式的<strong>语义</strong>。</p><table><thead><tr><th>操作</th><th>请求方式</th></tr></thead><tbody><tr><td>查询操作</td><td>GET</td></tr><tr><td>保存操作</td><td>POST</td></tr><tr><td>删除操作</td><td>DELETE</td></tr><tr><td>更新操作</td><td>PUT</td></tr></tbody></table><blockquote><p>另有一种说法：</p><ul><li>POST 操作针对功能执行，没有锁定资源 id，是非幂等性操作。</li><li>PUT 操作锁定资源 id，即使操作失败仍然可以针对原 id 重新执行，对整个系统来说满足幂等性。<ul><li>id 对应的资源不存在：执行保存操作</li><li>id 对应的资源存在：执行更新操作</li></ul></li></ul></blockquote><h5 id="3-3-URL更加简洁也更加隐晦"><a href="#3-3-URL更加简洁也更加隐晦" class="headerlink" title="3.3 URL更加简洁也更加隐晦"></a>3.3 URL更加简洁也更加隐晦</h5><p>REST风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。还有一点是不要使用请求扩展名。</p><p>使用问号键值对的方式给服务器传递数据太明显，容易被人利用来对系统进行破坏。使用 REST 风格携带数据不再需要明显的暴露数据的名称。 </p><table><thead><tr><th>操作</th><th>传统风格</th><th>REST 风格</th></tr></thead><tbody><tr><td>保存</td><td>/CRUD/saveEmp</td><td>URL 地址：/CRUD/emp 请求方式：POST</td></tr><tr><td>删除</td><td>/CRUD/removeEmp?empId=2</td><td>URL 地址：/CRUD/emp/2 请求方式：DELETE</td></tr><tr><td>更新</td><td>/CRUD/updateEmp</td><td>URL 地址：/CRUD/emp 请求方式：PUT</td></tr><tr><td>查询（表单回显）</td><td>/CRUD/editEmp?empId=2</td><td>URL 地址：/CRUD/emp/2 请求方式：GET</td></tr></tbody></table><h3 id="第二节-四种请求方式的映射"><a href="#第二节-四种请求方式的映射" class="headerlink" title="第二节 四种请求方式的映射"></a>第二节 四种请求方式的映射</h3><h4 id="1-为什么要进行请求方式的映射"><a href="#1-为什么要进行请求方式的映射" class="headerlink" title="1. 为什么要进行请求方式的映射"></a>1. 为什么要进行请求方式的映射</h4><p>在 HTML 中，GET 和 POST 请求可以天然实现，但是 DELETE 和 PUT 请求无法直接做到。SpringMVC 提供了 <strong>HiddenHttpMethodFilter</strong> 帮助我们<strong>将 POST 请求转换为 DELETE 或 PUT 请求</strong>。</p><h4 id="2-具体执行映射操作"><a href="#2-具体执行映射操作" class="headerlink" title="2. 具体执行映射操作"></a>2. 具体执行映射操作</h4><h5 id="2-1-映射PUT-请求"><a href="#2-1-映射PUT-请求" class="headerlink" title="2.1 映射PUT 请求"></a>2.1 映射PUT 请求</h5><h6 id="2-1-1-修改web-xml文件"><a href="#2-1-1-修改web-xml文件" class="headerlink" title="2.1.1 修改web.xml文件"></a>2.1.1 修改web.xml文件</h6><pre><code class="xml">&lt;!--一定要配置在解决乱码的Filter之后--&gt;&lt;filter&gt;    &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><h6 id="2-1-2-页面的表单"><a href="#2-1-2-页面的表单" class="headerlink" title="2.1.2 页面的表单"></a>2.1.2 页面的表单</h6><ul><li>要点1：原请求方式必须是 post</li><li>要点2：新的请求方式名称通过请求参数发送</li><li>要点3：请求参数名称必须是 _method</li><li>要点4：请求参数的值就是要改成的请求方式</li></ul><pre><code class="html">&lt;form th:action=&quot;@&#123;/rest/movie&#125;&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;/&gt;    &lt;button&gt;发送请求&lt;/button&gt;&lt;/form&gt;</code></pre><h6 id="2-1-3-handler方法"><a href="#2-1-3-handler方法" class="headerlink" title="2.1.3 handler方法"></a>2.1.3 handler方法</h6><pre><code class="java">@PutMapping(&quot;/movie&quot;)public String updateMovie()&#123;    logger.debug(&quot;PUT请求....&quot;);    return &quot;target&quot;;&#125;</code></pre><h5 id="2-2-映射DELETE请求"><a href="#2-2-映射DELETE请求" class="headerlink" title="2.2 映射DELETE请求"></a>2.2 映射DELETE请求</h5><h6 id="2-2-1-web-xml中要维持之前映射PUT请求的配置"><a href="#2-2-1-web-xml中要维持之前映射PUT请求的配置" class="headerlink" title="2.2.1 web.xml中要维持之前映射PUT请求的配置"></a>2.2.1 web.xml中要维持之前映射PUT请求的配置</h6><h6 id="2-2-2-前端页面"><a href="#2-2-2-前端页面" class="headerlink" title="2.2.2 前端页面"></a>2.2.2 前端页面</h6><p>通常删除超链接会出现在列表页面： </p><pre><code class="html">&lt;h3&gt;将XXX请求转换为DELETE请求&lt;/h3&gt;&lt;div id=&quot;app&quot;&gt;    &lt;table id=&quot;dataTable&quot;&gt;        &lt;tr&gt;            &lt;th&gt;姓名&lt;/th&gt;            &lt;th&gt;年龄&lt;/th&gt;            &lt;th&gt;删除&lt;/th&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;张三&lt;/td&gt;            &lt;td&gt;40&lt;/td&gt;            &lt;td&gt;                &lt;a th:href=&quot;@&#123;/rest/movie&#125;&quot; @click=&quot;deleteMovie&quot;&gt;删除&lt;/a&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;李四&lt;/td&gt;            &lt;td&gt;30&lt;/td&gt;            &lt;td&gt;                &lt;a th:href=&quot;@&#123;/rest/movie&#125;&quot; @click=&quot;deleteMovie&quot;&gt;删除&lt;/a&gt;            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/div&gt;</code></pre><p>创建负责转换的表单</p><pre><code class="html">&lt;form id=&quot;myForm&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;/&gt;&lt;/form&gt;</code></pre><p>使用vue给删除超链接绑定单击响应函数:</p><ol><li>引入vue</li></ol><p><img src="http://www.slx.blue/2021/12/11/springMVC-02/tu_001.png"></p><pre><code class="html">&lt;!--引入vue--&gt;&lt;script th:src=&quot;@&#123;/static/javaScript/vue.js&#125;&quot;&gt;&lt;/script&gt;</code></pre><ol start="2"><li>绑定单击响应函数</li></ol><pre><code class="javascript">var vue = new Vue(&#123;    &quot;el&quot;:&quot;#app&quot;,    &quot;methods&quot;:&#123;        deleteMovie()&#123;            console.log(&quot;aaaaaaa&quot;)            //真正发送删除请求:            //1. 阻止标签的默认行为            event.preventDefault()            //2. 创建一个空表单:先动态设置表单的action            var myForm = document.getElementById(&quot;myForm&quot;);            myForm.action = event.target.href            //并且使用js代码提交表单            myForm.submit()        &#125;    &#125;&#125;);</code></pre><h6 id="2-2-3-handler方法"><a href="#2-2-3-handler方法" class="headerlink" title="2.2.3 handler方法"></a>2.2.3 handler方法</h6><pre><code class="java">@DeleteMapping(&quot;/movie&quot;)public String deleteMovieById()&#123;    logger.debug(&quot;DELETE请求....&quot;);    return &quot;target&quot;;&#125;</code></pre><h3 id="第三节-PathVariable注解获取路径参数"><a href="#第三节-PathVariable注解获取路径参数" class="headerlink" title="第三节 PathVariable注解获取路径参数"></a>第三节 PathVariable注解获取路径参数</h3><h4 id="1-REST-风格路径参数"><a href="#1-REST-风格路径参数" class="headerlink" title="1. REST 风格路径参数"></a>1. REST 风格路径参数</h4><p>请看下面链接：</p><blockquote><p>/emp/20</p><p>/shop/product/iphone</p></blockquote><p>如果我们想要获取链接地址中的某个部分的值，就可以使用 @PathVariable 注解，例如上面地址中的20、iphone部分。</p><h4 id="2-具体操作"><a href="#2-具体操作" class="headerlink" title="2. 具体操作"></a>2. 具体操作</h4><h5 id="2-1-单个路径参数"><a href="#2-1-单个路径参数" class="headerlink" title="2.1 单个路径参数"></a>2.1 单个路径参数</h5><h6 id="2-1-1-发送请求携带参数"><a href="#2-1-1-发送请求携带参数" class="headerlink" title="2.1.1 发送请求携带参数"></a>2.1.1 发送请求携带参数</h6><pre><code class="html">&lt;a th:href=&quot;@&#123;/rest/movie/2&#125;&quot;&gt;携带参数movieId&lt;/a&gt;</code></pre><h6 id="2-1-2-handler方法获取路径参数"><a href="#2-1-2-handler方法获取路径参数" class="headerlink" title="2.1.2 handler方法获取路径参数"></a>2.1.2 handler方法获取路径参数</h6><pre><code class="java">//注意:&#123;movieId是一个占位符&#125;，表示获取该位置的值，@PathVariable(&quot;movieId&quot;)表示获取占位符为&quot;movieId&quot;的值@GetMapping(&quot;/movie/&#123;movieId&#125;&quot;)public String findMovieById(@PathVariable(&quot;movieId&quot;) Integer movieId)&#123;    logger.debug(&quot;GET请求....&quot;+movieId);    return &quot;target&quot;;&#125;</code></pre><h5 id="2-2-多个路径参数"><a href="#2-2-多个路径参数" class="headerlink" title="2.2 多个路径参数"></a>2.2 多个路径参数</h5><h6 id="2-2-1-发送请求携带参数"><a href="#2-2-1-发送请求携带参数" class="headerlink" title="2.2.1 发送请求携带参数"></a>2.2.1 发送请求携带参数</h6><pre><code class="html">&lt;a th:href=&quot;@&#123;/rest/movie/2/22/123&#125;&quot;&gt;携带多个参数&lt;/a&gt;</code></pre><h6 id="2-2-2-handler方法获取路径参数"><a href="#2-2-2-handler方法获取路径参数" class="headerlink" title="2.2.2 handler方法获取路径参数"></a>2.2.2 handler方法获取路径参数</h6><pre><code class="java">@GetMapping(&quot;/movie/&#123;categoryId&#125;/&#123;groupId&#125;/&#123;movieId&#125;&quot;)public String findMovieById(@PathVariable(&quot;categoryId&quot;) Integer categoryId,@PathVariable(&quot;groupId&quot;)Integer groupId,@PathVariable(&quot;movieId&quot;) Integer movieId)&#123;    logger.debug(&quot;GET请求....&quot;+categoryId+&quot;:&quot;+groupId+&quot;:&quot;+movieId);    return &quot;target&quot;;&#125;</code></pre><h3 id="第四节-RESTFul综合案例"><a href="#第四节-RESTFul综合案例" class="headerlink" title="第四节 RESTFul综合案例"></a>第四节 RESTFul综合案例</h3><h4 id="1-案例准备"><a href="#1-案例准备" class="headerlink" title="1. 案例准备"></a>1. 案例准备</h4><p>将前面的传统CRUD案例复制并且重新导入</p><h4 id="2-功能清单"><a href="#2-功能清单" class="headerlink" title="2. 功能清单"></a>2. 功能清单</h4><table><thead><tr><th>功能</th><th>URL 地址</th><th>请求方式</th></tr></thead><tbody><tr><td>访问首页</td><td>/</td><td>GET</td></tr><tr><td>查询全部数据</td><td>/movie</td><td>GET</td></tr><tr><td>删除</td><td>/movie/2</td><td>DELETE</td></tr><tr><td>跳转到添加数据的表单</td><td>/movie/add.html</td><td>GET</td></tr><tr><td>执行保存</td><td>/movie</td><td>POST</td></tr><tr><td>跳转到更新数据的表单</td><td>/movie/2</td><td>GET</td></tr><tr><td>执行更新</td><td>/movie</td><td>PUT</td></tr></tbody></table><h4 id="3-访问首页"><a href="#3-访问首页" class="headerlink" title="3. 访问首页"></a>3. 访问首页</h4><h5 id="3-1-配置view-controller"><a href="#3-1-配置view-controller" class="headerlink" title="3.1 配置view-controller"></a>3.1 配置view-controller</h5><pre><code class="xml">&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;portal&quot;/&gt;</code></pre><p>其它不用做任何修改</p><h4 id="4-查询全部"><a href="#4-查询全部" class="headerlink" title="4. 查询全部"></a>4. 查询全部</h4><h5 id="4-1-案例流程"><a href="#4-1-案例流程" class="headerlink" title="4.1 案例流程"></a>4.1 案例流程</h5><p><img src="http://www.slx.blue/2021/12/11/springMVC-02/tu_002.png"></p><h5 id="4-2-具体实现"><a href="#4-2-具体实现" class="headerlink" title="4.2 具体实现"></a>4.2 具体实现</h5><h6 id="4-2-1-handler方法"><a href="#4-2-1-handler方法" class="headerlink" title="4.2.1 handler方法"></a>4.2.1 handler方法</h6><pre><code class="java">//因为类上的RequestMapping注解的值已经是&quot;/movie&quot;了@GetMappingpublic String showList(Model model)&#123;    //1. 调用业务层的方法查询所有的movie    List&lt;Movie&gt; movieList = movieService.getAll();    //2. 将查询到的所有movie存储到请求域    model.addAttribute(&quot;movieList&quot;,movieList);    //3. 解析Thymeleaf模板显示所有movie    return &quot;list&quot;;&#125;</code></pre><h6 id="4-2-2-portal-html页面a标签的路径"><a href="#4-2-2-portal-html页面a标签的路径" class="headerlink" title="4.2.2 portal.html页面a标签的路径"></a>4.2.2 portal.html页面a标签的路径</h6><pre><code class="html">&lt;a th:href=&quot;@&#123;/movie&#125;&quot;&gt;显示电影列表&lt;/a&gt;</code></pre><h6 id="4-2-3-list页面展示-不用修改"><a href="#4-2-3-list页面展示-不用修改" class="headerlink" title="4.2.3 list页面展示(不用修改)"></a>4.2.3 list页面展示(不用修改)</h6><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;电影列表页面&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            table &#123;                border-collapse: collapse;                margin: 0px auto 0px auto;            &#125;            table th,td &#123;                border: 1px solid black;                text-align: center;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;table&gt;            &lt;thead&gt;                &lt;tr&gt;                    &lt;th&gt;电影ID&lt;/th&gt;                    &lt;th&gt;电影名称&lt;/th&gt;                    &lt;th&gt;电影票价格&lt;/th&gt;                    &lt;th&gt;删除&lt;/th&gt;                    &lt;th&gt;更新&lt;/th&gt;                &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody th:if=&quot;$&#123;#lists.isEmpty(movieList)&#125;&quot;&gt;                &lt;tr&gt;                    &lt;td colspan=&quot;5&quot;&gt;抱歉！没有查询到数据！&lt;/td&gt;                &lt;/tr&gt;            &lt;/tbody&gt;            &lt;tbody th:unless=&quot;$&#123;#lists.isEmpty(movieList)&#125;&quot;&gt;                &lt;tr th:each=&quot;movie : $&#123;movieList&#125;&quot;&gt;                    &lt;td th:text=&quot;$&#123;movie.movieId&#125;&quot;&gt;电影ID&lt;/td&gt;                    &lt;td th:text=&quot;$&#123;movie.movieName&#125;&quot;&gt;电影名称&lt;/td&gt;                    &lt;td th:text=&quot;$&#123;movie.moviePrice&#125;&quot;&gt;电影票价格&lt;/td&gt;                    &lt;td&gt;                        &lt;a th:href=&quot;@&#123;/movie/removeMovie(movieId=$&#123;movie.movieId&#125;)&#125;&quot;&gt;删除&lt;/a&gt;                    &lt;/td&gt;                    &lt;td&gt;&lt;a th:href=&quot;@&#123;/movie/toUpdatePage(movieId=$&#123;movie.movieId&#125;)&#125;&quot;&gt;更新&lt;/a&gt;&lt;/td&gt;                &lt;/tr&gt;            &lt;/tbody&gt;            &lt;tfoot&gt;                &lt;tr&gt;                    &lt;td colspan=&quot;5&quot;&gt;&lt;a th:href=&quot;@&#123;/add.html&#125;&quot;&gt;添加&lt;/a&gt;&lt;/td&gt;                &lt;/tr&gt;            &lt;/tfoot&gt;        &lt;/table&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="5-删除一行数据"><a href="#5-删除一行数据" class="headerlink" title="5. 删除一行数据"></a>5. 删除一行数据</h4><h5 id="5-1-案例流程"><a href="#5-1-案例流程" class="headerlink" title="5.1 案例流程"></a>5.1 案例流程</h5><p><img src="http://www.slx.blue/2021/12/11/springMVC-02/tu_003.png"></p><p>重点在于将 GET 请求转换为 DELETE。基本思路是：通过一个<strong>通用表单</strong>，使用 <strong>Vue</strong> 代码先把 GET 请求转换为 POST，然后再借助 <strong>hiddenHttpMethodFilter</strong> 在服务器端把 POST 请求转为 DELETE。 </p><h5 id="5-2-具体实现"><a href="#5-2-具体实现" class="headerlink" title="5.2 具体实现"></a>5.2 具体实现</h5><h6 id="5-2-1-创建通用表单"><a href="#5-2-1-创建通用表单" class="headerlink" title="5.2.1 创建通用表单"></a>5.2.1 创建通用表单</h6><pre><code class="html">&lt;!-- 组件名称：通用表单 --&gt;&lt;!-- 组件作用：把删除超链接的 GET 请求转换为 POST，并携带 _method 请求参数 --&gt;&lt;form id=&quot;convertForm&quot; method=&quot;post&quot;&gt;        &lt;!-- 请求参数作用：告诉服务器端 hiddenHttpMethodFilter 要转换的目标请求方式 --&gt;    &lt;!-- 请求参数名：_method，这是 hiddenHttpMethodFilter 中规定的 --&gt;    &lt;!-- 请求参数值：delete，这是因为我们希望服务器端将请求方式最终转换为 delete --&gt;    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;/&gt;&lt;/form&gt;</code></pre><h6 id="5-2-2-删除超链接绑定单击响应函数"><a href="#5-2-2-删除超链接绑定单击响应函数" class="headerlink" title="5.2.2 删除超链接绑定单击响应函数"></a>5.2.2 删除超链接绑定单击响应函数</h6><ol><li>引入vue</li></ol><p><img src="http://www.slx.blue/2021/12/11/springMVC-02/tu_004.png"></p><pre><code class="html">&lt;script th:src=&quot;@&#123;/script/vue.js&#125;&quot;&gt;&lt;/script&gt;</code></pre><ol start="2"><li> 删除超链接绑定单击事件</li></ol><pre><code class="html">&lt;a th:href=&quot;@&#123;/movie/&#125;+$&#123;movie.movieId&#125;&quot; @click=&quot;deleteMovie()&quot;&gt;删除&lt;/a&gt;</code></pre><ol start="3"><li>vue代码</li></ol><pre><code class="javascript">var vue = new Vue(&#123;    &quot;el&quot;:&quot;#app&quot;,    &quot;methods&quot;:&#123;        deleteMovie()&#123;            //1. 阻止默认事件            event.preventDefault()            //2. 创建一个空表单:设置表单的action的值和当前a标签的路径一致            var deleteForm = document.getElementById(&quot;deleteForm&quot;);            deleteForm.action = event.target.href            //3. 提交表单            deleteForm.submit()        &#125;    &#125;&#125;);</code></pre><h6 id="5-2-3-handler方法"><a href="#5-2-3-handler方法" class="headerlink" title="5.2.3 handler方法"></a>5.2.3 handler方法</h6><pre><code class="java">@DeleteMapping(&quot;/&#123;movieId&#125;&quot;)public String removeMovie(@PathVariable(&quot;movieId&quot;) String movieId)&#123;    //调用业务层的方法根据id删除movie    movieService.removeMovieById(movieId);    //重新查询所有    return &quot;redirect:/movie&quot;;&#125;</code></pre><h4 id="6-跳转到添加数据的表单-不用修改"><a href="#6-跳转到添加数据的表单-不用修改" class="headerlink" title="6. 跳转到添加数据的表单(不用修改)"></a>6. 跳转到添加数据的表单(不用修改)</h4><h5 id="6-1-案例流程"><a href="#6-1-案例流程" class="headerlink" title="6.1 案例流程"></a>6.1 案例流程</h5><p><img src="http://www.slx.blue/2021/12/11/springMVC-02/tu_005.png"></p><h5 id="6-2-具体实现"><a href="#6-2-具体实现" class="headerlink" title="6.2 具体实现"></a>6.2 具体实现</h5><h6 id="6-2-1-配置view-controller"><a href="#6-2-1-配置view-controller" class="headerlink" title="6.2.1 配置view-controller"></a>6.2.1 配置view-controller</h6><pre><code class="xml">&lt;!--8. 使用view-controller访问添加页面--&gt;&lt;mvc:view-controller path=&quot;/add.html&quot; view-name=&quot;add&quot;/&gt;</code></pre><h6 id="6-2-2-创建页面"><a href="#6-2-2-创建页面" class="headerlink" title="6.2.2 创建页面"></a>6.2.2 创建页面</h6><p><img src="http://www.slx.blue/2021/12/11/springMVC-02/tu_006.png"></p><pre><code class="html">&lt;form th:action=&quot;@&#123;/movie&#125;&quot; method=&quot;post&quot;&gt;        电影名称：&lt;input type=&quot;text&quot; name=&quot;movieName&quot; /&gt;&lt;br/&gt;    电影票价格：&lt;input type=&quot;text&quot; name=&quot;moviePrice&quot; /&gt;&lt;br/&gt;        &lt;button type=&quot;submit&quot;&gt;保存&lt;/button&gt;    &lt;/form&gt;</code></pre><h4 id="7-执行添加"><a href="#7-执行添加" class="headerlink" title="7. 执行添加"></a>7. 执行添加</h4><h5 id="7-1-案例流程"><a href="#7-1-案例流程" class="headerlink" title="7.1 案例流程"></a>7.1 案例流程</h5><p><img src="http://www.slx.blue/2021/12/11/springMVC-02/tu_007.png"></p><h5 id="7-2-具体实现"><a href="#7-2-具体实现" class="headerlink" title="7.2 具体实现"></a>7.2 具体实现</h5><h6 id="7-2-1-handler方法"><a href="#7-2-1-handler方法" class="headerlink" title="7.2.1 handler方法"></a>7.2.1 handler方法</h6><pre><code class="java">@PostMappingpublic String addMovie(Movie movie)&#123;    //调用业务层的方法添加Movie    movieService.saveMovie(movie);    //重新查询所有    return &quot;redirect:/movie&quot;;&#125;</code></pre><h6 id="7-2-2-添加页面"><a href="#7-2-2-添加页面" class="headerlink" title="7.2.2 添加页面"></a>7.2.2 添加页面</h6><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;添加电影页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form th:action=&quot;@&#123;/movie&#125;&quot; method=&quot;post&quot;&gt;        电影名称：&lt;input type=&quot;text&quot; name=&quot;movieName&quot; /&gt;&lt;br/&gt;        电影票价格：&lt;input type=&quot;text&quot; name=&quot;moviePrice&quot; /&gt;&lt;br/&gt;        &lt;button type=&quot;submit&quot;&gt;保存&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="8-跳转到更新数据页面"><a href="#8-跳转到更新数据页面" class="headerlink" title="8. 跳转到更新数据页面"></a>8. 跳转到更新数据页面</h4><h5 id="8-1-案例流程"><a href="#8-1-案例流程" class="headerlink" title="8.1 案例流程"></a>8.1 案例流程</h5><p><img src="http://www.slx.blue/2021/12/11/springMVC-02/tu_008.png"></p><h5 id="8-2-具体实现"><a href="#8-2-具体实现" class="headerlink" title="8.2 具体实现"></a>8.2 具体实现</h5><h6 id="8-2-1-handler方法"><a href="#8-2-1-handler方法" class="headerlink" title="8.2.1 handler方法"></a>8.2.1 handler方法</h6><pre><code class="java">@GetMapping(&quot;/&#123;movieId&#125;&quot;)public String toUpdatePage(@PathVariable(&quot;movieId&quot;) String movieId,Model model)&#123;    //1. 根据要修改的电影的id查询到当前电影的信息    Movie movie = movieService.getMovieById(movieId);    //2. 将当前电影的信息存储到请求域    model.addAttribute(&quot;movie&quot;,movie);    //3. 解析update页面    return &quot;update&quot;;&#125;</code></pre><h6 id="8-2-2-修改更新的超链接"><a href="#8-2-2-修改更新的超链接" class="headerlink" title="8.2.2 修改更新的超链接"></a>8.2.2 修改更新的超链接</h6><pre><code class="html">&lt;a th:href=&quot;@&#123;/movie/&#125;+$&#123;movie.movieId&#125;&quot;&gt;更新&lt;/a&gt;</code></pre><h6 id="8-2-3-页面回显数据"><a href="#8-2-3-页面回显数据" class="headerlink" title="8.2.3 页面回显数据"></a>8.2.3 页面回显数据</h6><pre><code class="html">&lt;form th:action=&quot;@&#123;/movie&#125;&quot; method=&quot;post&quot;&gt;    &lt;!--映射成put请求--&gt;    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;/&gt;    &lt;!--使用隐藏域绑定movieId--&gt;    &lt;input type=&quot;hidden&quot; name=&quot;movieId&quot; th:value=&quot;$&#123;movie.movieId&#125;&quot; /&gt;    电影名称：&lt;input type=&quot;text&quot; name=&quot;movieName&quot; th:value=&quot;$&#123;movie.movieName&#125;&quot; /&gt;&lt;br/&gt;    电影票价格：&lt;input type=&quot;text&quot; name=&quot;moviePrice&quot; th:value=&quot;$&#123;movie.moviePrice&#125;&quot; /&gt;&lt;br/&gt;    &lt;button type=&quot;submit&quot;&gt;更新&lt;/button&gt;&lt;/form&gt;</code></pre><h4 id="9-执行更新"><a href="#9-执行更新" class="headerlink" title="9. 执行更新"></a>9. 执行更新</h4><h5 id="9-1-案例流程"><a href="#9-1-案例流程" class="headerlink" title="9.1 案例流程"></a>9.1 案例流程</h5><p><img src="http://www.slx.blue/2021/12/11/springMVC-02/tu_009.png"></p><h5 id="9-2-具体实现"><a href="#9-2-具体实现" class="headerlink" title="9.2 具体实现"></a>9.2 具体实现</h5><h6 id="9-2-1-handler方法"><a href="#9-2-1-handler方法" class="headerlink" title="9.2.1 handler方法"></a>9.2.1 handler方法</h6><pre><code class="java">@PutMappingpublic String updateMovie(Movie movie)&#123;    //1. 调用业务层的方法修改电影信息    movieService.updateMovie(movie);    //2. 重新查询所有    return &quot;redirect:/movie&quot;;&#125;</code></pre><h3 id="第五节-REST的小结"><a href="#第五节-REST的小结" class="headerlink" title="第五节 REST的小结"></a>第五节 REST的小结</h3><ol><li>解决什么问题: 从根据功能设计url变成根据资源设计url</li><li>是什么:资源状态转移<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer</li><li>特征:<ol><li>一个url就代表一个资源，也就是说通过url我们可以知道当前请求操作的是什么资源</li><li>请求方式代表操作,也就是说通过请求方式我们知道当前请求对当前资源做的是何种操作</li></ol></li><li>效果:<ol><li>url更加简洁</li><li>url更加隐晦</li><li>操作的幂等性</li></ol></li><li>怎么实现:<ol><li>请求方式映射:HTML默认只能发送GET和POST请求，SpringMVC在某些时候需要将POST请求映射成PUT或者DELETE请求</li><li>GetMapping、PostMapping、DeleteMapping、PutMapping要选择情况使用</li><li>合理设计url</li><li>使用Pathvariable注解获取REST风格的url上的路径参数</li></ol></li></ol><h2 id="第二章-Ajax交互"><a href="#第二章-Ajax交互" class="headerlink" title="第二章 Ajax交互"></a>第二章 Ajax交互</h2><h3 id="第一节-获取请求参数"><a href="#第一节-获取请求参数" class="headerlink" title="第一节 获取请求参数"></a>第一节 获取请求参数</h3><h4 id="1-获取普通类型参数-与之前获取请求参数的方式一致"><a href="#1-获取普通类型参数-与之前获取请求参数的方式一致" class="headerlink" title="1. 获取普通类型参数(与之前获取请求参数的方式一致)"></a>1. 获取普通类型参数(与之前获取请求参数的方式一致)</h4><h5 id="1-1-引入JavaScript库"><a href="#1-1-引入JavaScript库" class="headerlink" title="1.1 引入JavaScript库"></a>1.1 引入JavaScript库</h5><p><img src="http://www.slx.blue/2021/12/11/springMVC-02/tu_010.png"></p><pre><code class="html">&lt;script type=&quot;text/javascript&quot; src=&quot;script/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;script/axios.min.js&quot;&gt;&lt;/script&gt;</code></pre><h5 id="1-2-前端代码"><a href="#1-2-前端代码" class="headerlink" title="1.2 前端代码"></a>1.2 前端代码</h5><pre><code class="javascript">sendCommon()&#123;    axios(&#123;        &quot;method&quot;:&quot;POST&quot;,        &quot;url&quot;:&quot;ajax/commonParameter&quot;,        //params表示携带普通类型的参数        &quot;params&quot;:&#123;            &quot;userName&quot;:&quot;tom&quot;,            &quot;password&quot;:&quot;123456&quot;        &#125;    &#125;).then(response =&gt; &#123;    &#125;)&#125;</code></pre><h5 id="1-3-后端代码"><a href="#1-3-后端代码" class="headerlink" title="1.3 后端代码"></a>1.3 后端代码</h5><pre><code class="java">@RequestMapping(&quot;/commonParameter&quot;)public String commonParameter(User user)&#123;    //获取异步请求携带的普通类型参数，和以前获取同步请求携带的参数是一样的    logger.debug(user.toString());    return &quot;hello&quot;;&#125;</code></pre><h4 id="2-获取JSON请求体参数"><a href="#2-获取JSON请求体参数" class="headerlink" title="2. 获取JSON请求体参数"></a>2. 获取JSON请求体参数</h4><h5 id="2-1-前端代码"><a href="#2-1-前端代码" class="headerlink" title="2.1 前端代码"></a>2.1 前端代码</h5><pre><code class="javascript">sendJsonBody()&#123;    axios(&#123;        &quot;method&quot;:&quot;POST&quot;,        &quot;url&quot;:&quot;ajax/jsonBodyParameter&quot;,        //data表示携带json请求体类型的参数        &quot;data&quot;:&#123;            &quot;userName&quot;:&quot;tom&quot;,            &quot;password&quot;:&quot;123456&quot;        &#125;    &#125;).then(response =&gt; &#123;    &#125;)&#125;</code></pre><h5 id="2-2-后端代码"><a href="#2-2-后端代码" class="headerlink" title="2.2 后端代码"></a>2.2 后端代码</h5><h6 id="2-2-1-引入jackson依赖"><a href="#2-2-1-引入jackson依赖" class="headerlink" title="2.2.1 引入jackson依赖"></a>2.2.1 引入jackson依赖</h6><pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.12.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>如果忘记导入这个依赖，会看到下面的错误页面 </p><p><img src="http://www.slx.blue/2021/12/11/springMVC-02/tu_011.png"></p><p>关于 SpringMVC 和 Jackson jar包之间的关系，需要注意：当 SpringMVC 需要解析 JSON 数据时就需要使用 Jackson 的支持。但是 SpringMVC 的 jar 包并没有依赖 Jackson，所以需要我们自己导入。</p><p>我们自己导入时需要注意：SpringMVC 和 Jackson 配合使用有版本的要求。二者中任何一个版本太高或太低都不行。</p><p>SpringMVC 解析 JSON 数据包括两个方向：</p><ul><li>从 JSON 字符串到 Java 实体类。</li><li>从 Java 实体类到 JSON 字符串。</li></ul><p>另外，如果导入了 Jackson 依赖，但是没有开启 mvc:annotation-driven 功能，那么仍然会返回上面的错误页面。</p><p>也就是说，我们可以这么总结 SpringMVC 想要解析 JSON 数据需要两方面支持：</p><ul><li>mvc:annotation-driven</li><li>引入 Jackson 依赖</li></ul><p>还有一点，如果运行环境是 Tomcat7，那么在 Web 应用启动时会抛出下面异常：</p><blockquote><p>org.apache.tomcat.util.bcel.classfile.ClassFormatException: Invalid byte tag in constant pool: 19</p></blockquote><p>解决办法是使用 Tomcat8 或更高版本。</p><h6 id="2-2-2-handler方法"><a href="#2-2-2-handler方法" class="headerlink" title="2.2.2 handler方法"></a>2.2.2 handler方法</h6><pre><code class="java">@RequestMapping(&quot;/jsonBodyParameter&quot;)public String jsonBodyParameter(@RequestBody User user)&#123;    //1. 获取Json请求体类型的参数必须要封装到POJO对象或者是Map中    //2. POJO参数或者Map参数的前面一定要加入RequestBody注解    //3. 你的项目中一定要引入jackson的依赖(因为SpringMVC默认支持jackson)    //获取Json请求体类型的请求参数和获取普通类型的参数不一样    logger.debug(user.toString());    return &quot;success&quot;;&#125;</code></pre><h6 id="2-2-3-RequestBody注解"><a href="#2-2-3-RequestBody注解" class="headerlink" title="2.2.3 RequestBody注解"></a>2.2.3 RequestBody注解</h6><p>适用 @RequestBody 注解的场景：请求体整个是一个 JSON 数据 </p><p><img src="http://www.slx.blue/2021/12/11/springMVC-02/tu_012.png"></p><p>Request Payload 翻译成中文大致可以说：请求负载。 </p><h3 id="第二节-响应JSON类型数据"><a href="#第二节-响应JSON类型数据" class="headerlink" title="第二节 响应JSON类型数据"></a>第二节 响应JSON类型数据</h3><h4 id="1-前端代码"><a href="#1-前端代码" class="headerlink" title="1. 前端代码"></a>1. 前端代码</h4><pre><code class="javascript">sendJsonBody()&#123;    axios(&#123;        &quot;method&quot;:&quot;POST&quot;,        &quot;url&quot;:&quot;ajax/jsonBodyParameter&quot;,        //data表示携带json请求体类型的参数        &quot;data&quot;:&#123;            &quot;userName&quot;:&quot;tom&quot;,            &quot;password&quot;:&quot;123456&quot;        &#125;    &#125;).then(response =&gt; &#123;        console.log(response.data.movieName)    &#125;)&#125;</code></pre><h4 id="2-后端代码"><a href="#2-后端代码" class="headerlink" title="2. 后端代码"></a>2. 后端代码</h4><p>前提是项目中引入了jackson的依赖</p><pre><code class="java">@ResponseBody@RequestMapping(&quot;/jsonBodyParameter&quot;)public Movie jsonBodyParameter(@RequestBody User user)&#123;    logger.debug(user.toString());    Movie movie = new Movie(1, &quot;西游记&quot;, 40.0);    //目标:将movie转成json字符串响应给客户端    //1. handler方法的返回值就是你要转成json的那个对象    //2. handler方法上必须添加ResponseBody注解    //3. 你的项目中一定要引入了jackson的依赖    return movie;&#125;</code></pre><h4 id="3-常见错误"><a href="#3-常见错误" class="headerlink" title="3. 常见错误"></a>3. 常见错误</h4><h5 id="3-1-500-错误"><a href="#3-1-500-错误" class="headerlink" title="3.1 500 错误"></a>3.1 500 错误</h5><p><img src="http://www.slx.blue/2021/12/11/springMVC-02/tu_014.png"></p><p>出现上面的错误页面，表示SpringMVC 为了将 实体类对象转换为 JSON 数据, 需要转换器。但是现在找不到转换器。它想要成功完成转换需要两方面支持：</p><ul><li>mvc:annotation-driven</li><li>引入Jackson依赖</li></ul><h5 id="3-2-406-错误-了解"><a href="#3-2-406-错误-了解" class="headerlink" title="3.2 406 错误(了解)"></a>3.2 406 错误(了解)</h5><p>问题出现的原因：</p><ul><li>请求地址扩展名：html</li><li>服务器端打算返回的数据格式：JSON</li></ul><p>上面二者不一致。SpringMVC 要坚守一个商人的良心，不能干『挂羊头，卖狗肉』的事儿。解决办法有三种思路：</p><ul><li>第一种方法：不使用请求扩展名</li><li>第二种方法：使用和实际返回的数据格式一致的扩展名</li></ul><pre><code class="xml">&lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;    &lt;url-pattern&gt;*.json&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><ul><li>第三种方法：使用一个 HTTP 协议中没有被定义的扩展名，例如：*.do</li></ul><h4 id="4-RestController注解"><a href="#4-RestController注解" class="headerlink" title="4. RestController注解"></a>4. RestController注解</h4><h5 id="4-1-提取ResponseBody注解"><a href="#4-1-提取ResponseBody注解" class="headerlink" title="4.1 提取ResponseBody注解"></a>4.1 提取ResponseBody注解</h5><p>如果类中每个方法上都标记了 @ResponseBody 注解，那么这些注解就可以提取到类上。 </p><h5 id="4-2-合并注解"><a href="#4-2-合并注解" class="headerlink" title="4.2 合并注解"></a>4.2 合并注解</h5><p>类上的ResponseBody 注解可以和Controller 注解合并为RestController 注解。所以使用了RestController 注解就相当于给类中的每个方法都加了ResponseBody 注解。 </p><h5 id="4-3-RestController源码"><a href="#4-3-RestController源码" class="headerlink" title="4.3 RestController源码"></a>4.3 RestController源码</h5><pre><code class="java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Controller@ResponseBodypublic @interface RestController &#123;     /**     * The value may indicate a suggestion for a logical component name,     * to be turned into a Spring bean in case of an autodetected component.     * @return the suggested component name, if any (or empty String otherwise)     * @since 4.0.1     */    @AliasFor(annotation = Controller.class)    String value() default &quot;&quot;;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> springMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springMVC-01</title>
      <link href="/2021/12/10/springMVC-01/"/>
      <url>/2021/12/10/springMVC-01/</url>
      
        <content type="html"><![CDATA[<h1 id="springmvc-day01"><a href="#springmvc-day01" class="headerlink" title="springmvc-day01"></a>springmvc-day01</h1><h2 id="第一章-SpringMVC入门"><a href="#第一章-SpringMVC入门" class="headerlink" title="第一章 SpringMVC入门"></a>第一章 SpringMVC入门</h2><h3 id="第一节-SpringMVC概述"><a href="#第一节-SpringMVC概述" class="headerlink" title="第一节 SpringMVC概述"></a>第一节 SpringMVC概述</h3><h4 id="1-SpringMVC-优势"><a href="#1-SpringMVC-优势" class="headerlink" title="1. SpringMVC 优势"></a>1. SpringMVC 优势</h4><p>SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的<strong>首选方案</strong>。之所以能做到这一点，是因为 SpringMVC 具备如下显著优势：</p><ul><li><strong>Spring 家族原生产品</strong>，与 IOC 容器等基础设施无缝对接</li><li>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>，提供<strong>全面解决方案</strong></li><li><strong>代码清新简洁</strong>，大幅度提升开发效率</li><li>内部组件化程度高，可插拔式组件<strong>即插即用</strong>，想要什么功能配置相应组件即可</li><li><strong>性能卓著</strong>，尤其适合现代大型、超大型互联网项目要求</li></ul><h4 id="2-表述层框架要解决的基本问题"><a href="#2-表述层框架要解决的基本问题" class="headerlink" title="2. 表述层框架要解决的基本问题"></a>2. 表述层框架要解决的基本问题</h4><ul><li>请求映射:让一个方法处理一个请求</li><li>数据输入:获取请求参数</li><li>类型转换:内置或者自定义类型转换器，对请求参数的类型进行转换</li><li>数据校验:参数的非空校验</li><li>视图界面:Thymeleaf</li><li>请求分发:请求转发</li><li>与域对象交互</li><li>会话控制:Session</li><li>过滤拦截:Filter</li><li>异步交互</li><li>文件上传</li><li>文件下载</li></ul><h3 id="第二节-SpringMVC入门案例-重点"><a href="#第二节-SpringMVC入门案例-重点" class="headerlink" title="第二节 SpringMVC入门案例(重点)"></a>第二节 SpringMVC入门案例(重点)</h3><h4 id="1-功能需求"><a href="#1-功能需求" class="headerlink" title="1. 功能需求"></a>1. 功能需求</h4><h5 id="1-1-访问首页"><a href="#1-1-访问首页" class="headerlink" title="1.1 访问首页"></a>1.1 访问首页</h5><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_001.png" style="zoom: 80%;"><h5 id="1-2-在首页点超链接"><a href="#1-2-在首页点超链接" class="headerlink" title="1.2 在首页点超链接"></a>1.2 在首页点超链接</h5><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_002.png" style="zoom:80%;"><h4 id="2-搭建环境"><a href="#2-搭建环境" class="headerlink" title="2. 搭建环境"></a>2. 搭建环境</h4><h5 id="2-1-导入依赖"><a href="#2-1-导入依赖" class="headerlink" title="2.1 导入依赖"></a>2.1 导入依赖</h5><pre><code class="xml">&lt;dependencies&gt;    &lt;!-- SpringMVC --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;        &lt;!-- 日志 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;        &lt;version&gt;1.2.3&lt;/version&gt;    &lt;/dependency&gt;        &lt;!-- ServletAPI --&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;        &lt;version&gt;3.1.0&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;        &lt;!-- Spring5和Thymeleaf整合包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;        &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;        &lt;version&gt;3.0.12.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。 </p><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_003.png"></p><h5 id="2-2-日志配置文件"><a href="#2-2-日志配置文件" class="headerlink" title="2.2 日志配置文件"></a>2.2 日志配置文件</h5><p>文件名：logback.xml </p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;true&quot;&gt;    &lt;!-- 指定日志输出的位置 --&gt;    &lt;appender name=&quot;STDOUT&quot;              class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;encoder&gt;            &lt;!-- 日志输出的格式 --&gt;            &lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;            &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;    &lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;    &lt;root level=&quot;DEBUG&quot;&gt;        &lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;    &lt;/root&gt;    &lt;!-- 根据特殊需求指定局部日志级别 --&gt;    &lt;logger name=&quot;org.springframework.web.servlet.DispatcherServlet&quot; level=&quot;DEBUG&quot; /&gt;&lt;/configuration&gt;</code></pre><h5 id="2-3-web-xml配置"><a href="#2-3-web-xml配置" class="headerlink" title="2.3 web.xml配置"></a>2.3 web.xml配置</h5><pre><code class="xml">&lt;!-- 配置SpringMVC中负责处理请求的核心Servlet，也被称为SpringMVC的前端控制器 --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;        &lt;!-- DispatcherServlet的全类名 --&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!-- 通过初始化参数指定SpringMVC配置文件位置 --&gt;    &lt;init-param&gt;            &lt;!-- 如果不记得contextConfigLocation配置项的名称，可以到DispatcherServlet的父类FrameworkServlet中查找 --&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;!-- 使用classpath:说明这个路径从类路径的根目录开始才查找 --&gt;        &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;        &lt;!-- 作为框架的核心组件，在启动过程中有大量的初始化操作要做，这些操作放在第一次请求时才执行非常不恰当 --&gt;    &lt;!-- 我们应该将DispatcherServlet设置为随Web应用一起启动 --&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;        &lt;!-- 对DispatcherServlet来说，url-pattern有两种方式配置 --&gt;    &lt;!-- 方式一：配置“/”，表示匹配整个Web应用范围内所有请求。 --&gt;    &lt;!-- 方式二：配置“*.扩展名”，表示匹配整个Web应用范围内部分请求 --&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><h5 id="2-4-Spring配置文件"><a href="#2-4-Spring配置文件" class="headerlink" title="2.4 Spring配置文件"></a>2.4 Spring配置文件</h5><pre><code class="xml">&lt;!-- 自动扫描包 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu.mvc.handler&quot;/&gt;    &lt;!-- Thymeleaf视图解析器 --&gt;&lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt;    &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt;    &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt;    &lt;property name=&quot;templateEngine&quot;&gt;        &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt;            &lt;property name=&quot;templateResolver&quot;&gt;                &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt;                        &lt;!-- 视图前缀 --&gt;                    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt;                        &lt;!-- 视图后缀 --&gt;                    &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt;                    &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt;                    &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt;                &lt;/bean&gt;            &lt;/property&gt;        &lt;/bean&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h4><h5 id="3-1-创建请求处理器类"><a href="#3-1-创建请求处理器类" class="headerlink" title="3.1 创建请求处理器类"></a>3.1 创建请求处理器类</h5><h6 id="3-1-1-命名规范"><a href="#3-1-1-命名规范" class="headerlink" title="3.1.1 命名规范"></a>3.1.1 命名规范</h6><p>SpringMVC 对处理请求的类并没有特殊要求，只要是 JavaBean 即可。我们自己习惯上有两种命名方式：</p><ul><li>XxxHandler：意思是 Xxx 处理器的意思</li><li>XxxController：意思是 Xxx 控制器的意思</li></ul><p>这只是一个命名的习惯，不是语法要求。所以往往把处理请求的类叫做『Handler类』，处理请求的方法叫做『Handler方法』。</p><h6 id="3-1-2-创建处理器类"><a href="#3-1-2-创建处理器类" class="headerlink" title="3.1.2 创建处理器类"></a>3.1.2 创建处理器类</h6><pre><code class="java">@Controllerpublic class Demo01HelloHandler &#123;    &#125;</code></pre><h5 id="3-2-实现访问首页"><a href="#3-2-实现访问首页" class="headerlink" title="3.2 实现访问首页"></a>3.2 实现访问首页</h5><h6 id="3-2-1-创建-handler-方法"><a href="#3-2-1-创建-handler-方法" class="headerlink" title="3.2.1 创建 handler 方法"></a>3.2.1 创建 handler 方法</h6><pre><code class="java">@Controllerpublic class Demo01Handler &#123;    @RequestMapping(&quot;/&quot;)    public String showPortal()&#123;        System.out.println(&quot;showPortal()方法被调用了...&quot;);        //handler方法的返回值就是对应的Thymeleaf模板的逻辑视图        return &quot;index&quot;;    &#125;&#125;</code></pre><h6 id="3-2-2-在首页编写超链接"><a href="#3-2-2-在首页编写超链接" class="headerlink" title="3.2.2 在首页编写超链接"></a>3.2.2 在首页编写超链接</h6><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_004.png"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;首页&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;欢迎来到SpringMVC首页&lt;/h1&gt;        &lt;!--&quot;@&#123;/&#125;&quot;表示&quot;/项目名/&quot;--&gt;        &lt;a th:href=&quot;@&#123;/toTarget&#125;&quot;&gt;访问目标页面&lt;/a&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="3-3-实现点击超链接"><a href="#3-3-实现点击超链接" class="headerlink" title="3.3 实现点击超链接"></a>3.3 实现点击超链接</h5><h6 id="3-3-1-加入日志记录仪"><a href="#3-3-1-加入日志记录仪" class="headerlink" title="3.3.1 加入日志记录仪"></a>3.3.1 加入日志记录仪</h6><p>在 handler 类中声明一个成员变量：</p><pre><code class="java">private Logger logger = LoggerFactory.getLogger(this.getClass());</code></pre><ul><li>Logger：org.slf4j.Logger</li><li>LoggerFactory：org.slf4j.LoggerFactory</li></ul><h6 id="3-3-2-声明-handler-方法"><a href="#3-3-2-声明-handler-方法" class="headerlink" title="3.3.2 声明 handler 方法"></a>3.3.2 声明 handler 方法</h6><pre><code class="java">@RequestMapping(&quot;/toTarget&quot;)public String toTarget()&#123;    logger.debug(&quot;toTarget方法被调用了...&quot;);    return &quot;target&quot;;&#125;</code></pre><h6 id="3-3-3-创建目标页面"><a href="#3-3-3-创建目标页面" class="headerlink" title="3.3.3 创建目标页面"></a>3.3.3 创建目标页面</h6><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;目标页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;欢迎来到目标页面&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="3-4-整体流程解析"><a href="#3-4-整体流程解析" class="headerlink" title="3.4 整体流程解析"></a>3.4 整体流程解析</h5><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_006.png"></p><h3 id="第三节-常见注解"><a href="#第三节-常见注解" class="headerlink" title="第三节 常见注解"></a>第三节 常见注解</h3><h4 id="1-RequestMapping注解-重点"><a href="#1-RequestMapping注解-重点" class="headerlink" title="1. RequestMapping注解(重点)"></a>1. RequestMapping注解(重点)</h4><h5 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h5><p>从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求的 URL 地址和处理请求的方式关联起来，建立映射关系。</p><p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的方法来处理这个请求。</p><h5 id="1-2-使用位置"><a href="#1-2-使用位置" class="headerlink" title="1.2 使用位置"></a>1.2 使用位置</h5><h6 id="1-2-1-准备客户端访问路径"><a href="#1-2-1-准备客户端访问路径" class="headerlink" title="1.2.1 准备客户端访问路径"></a>1.2.1 准备客户端访问路径</h6><pre><code class="html">&lt;h3&gt;测试@RequestMapping注解标记在类上&lt;/h3&gt;&lt;a th:href=&quot;@&#123;/user/login&#125;&quot;&gt;用户登录&lt;/a&gt;&lt;br/&gt;&lt;a th:href=&quot;@&#123;/user/register&#125;&quot;&gt;用户注册&lt;/a&gt;&lt;br/&gt;&lt;a th:href=&quot;@&#123;/user/logout&#125;&quot;&gt;用户退出&lt;/a&gt;&lt;br/&gt;</code></pre><h6 id="1-2-2-仅标记在方法上的RequestMapping注解"><a href="#1-2-2-仅标记在方法上的RequestMapping注解" class="headerlink" title="1.2.2 仅标记在方法上的RequestMapping注解"></a>1.2.2 仅标记在方法上的RequestMapping注解</h6><pre><code class="java">@RequestMapping(&quot;/user/login&quot;)@RequestMapping(&quot;/user/register&quot;)@RequestMapping(&quot;/user/logout&quot;)</code></pre><h6 id="1-2-3-分别标记在类和方法上的-RequestMapping注解"><a href="#1-2-3-分别标记在类和方法上的-RequestMapping注解" class="headerlink" title="1.2.3 分别标记在类和方法上的@RequestMapping注解"></a>1.2.3 分别标记在类和方法上的@RequestMapping注解</h6><p>在类级别：抽取各个方法上@RequestMapping注解地址中前面重复的部分 </p><pre><code class="java">@RequestMapping(&quot;/user&quot;)</code></pre><p>在方法级别：省略被类级别抽取的部分 </p><pre><code class="java">@RequestMapping(&quot;/login&quot;)@RequestMapping(&quot;/register&quot;)@RequestMapping(&quot;/logout&quot;)</code></pre><h5 id="1-3-指定请求方式"><a href="#1-3-指定请求方式" class="headerlink" title="1.3 指定请求方式"></a>1.3 指定请求方式</h5><h6 id="1-3-1-通过RequestMapping的method属性指定"><a href="#1-3-1-通过RequestMapping的method属性指定" class="headerlink" title="1.3.1 通过RequestMapping的method属性指定"></a>1.3.1 通过RequestMapping的method属性指定</h6><p>HTTP 协议定义了八种请求方式，在 SpringMVC 中封装到了下面这个枚举类： </p><pre><code class="java">public enum RequestMethod &#123;    GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE&#125;</code></pre><p>设置RequestMapping注解的method属性</p><pre><code class="java">//value属性表示匹配请求路径，method属性表示匹配请求方式@RequestMapping(value = &quot;/emp&quot;, method = RequestMethod.GET)</code></pre><h6 id="1-3-2-通过RequestMapping的进阶注解指定"><a href="#1-3-2-通过RequestMapping的进阶注解指定" class="headerlink" title="1.3.2 通过RequestMapping的进阶注解指定"></a>1.3.2 通过RequestMapping的进阶注解指定</h6><table><thead><tr><th>原版</th><th>进阶版</th></tr></thead><tbody><tr><td>@RequestMapping(value = “/emp”,  method = RequestMethod.GET)</td><td>@GetMapping(“/emp”)</td></tr><tr><td>@RequestMapping(value = “/emp”,  method = RequestMethod.POST)</td><td>@PostMapping(“/emp”)</td></tr><tr><td>@RequestMapping(value = “/emp”,  method = RequestMethod.PUT)</td><td>@PutMapping(“/emp”)</td></tr><tr><td>@RequestMapping(value = “/emp”,  method = RequestMethod.DELETE)</td><td>@DeleteMapping(“/emp”)</td></tr></tbody></table><p> 针对Http的八种请求方式都有专门的注解</p><p> 另外需要注意：进阶版的这几个注解是从 4.3 版本才开始有，低于 4.3 版本无法使用。 </p><h5 id="1-4-Ambiguous-mapping异常"><a href="#1-4-Ambiguous-mapping异常" class="headerlink" title="1.4 Ambiguous mapping异常"></a>1.4 Ambiguous mapping异常</h5><p>出现原因：多个 handler 方法映射了同一个地址，导致 SpringMVC 在接收到这个地址的请求时该找哪个 handler 方法处理。</p><blockquote><p>Caused by: java.lang.IllegalStateException: Ambiguous mapping. Cannot map ‘demo03MappingMethodHandler’ method  com.atguigu.mvc.handler.Demo03MappingMethodHandler#empPost() to { [/emp]}: <strong>There is already</strong> ‘demo03MappingMethodHandler’ bean method com.atguigu.mvc.handler.Demo03MappingMethodHandler#empGet() <strong>mapped</strong>.</p></blockquote><h4 id="2-RequestHeader注解-了解"><a href="#2-RequestHeader注解-了解" class="headerlink" title="2. RequestHeader注解(了解)"></a>2. RequestHeader注解(了解)</h4><h5 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a>2.1 作用</h5><p>通过这个注解获取请求消息头中的具体数据。 </p><h5 id="2-2-用法"><a href="#2-2-用法" class="headerlink" title="2.2 用法"></a>2.2 用法</h5><pre><code class="java">@RequestMapping(&quot;/getHeader&quot;)public String getHeaderValue(@RequestHeader(&quot;user-agent&quot;) String headerValue)&#123;    //目标:获取user-agent请求头的信息，并且赋值给headerValue    logger.debug(headerValue);    return &quot;target&quot;;&#125;</code></pre><h4 id="3-CookieValue注解-了解"><a href="#3-CookieValue注解-了解" class="headerlink" title="3. CookieValue注解(了解)"></a>3. CookieValue注解(了解)</h4><h5 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1 作用"></a>3.1 作用</h5><p>获取当前请求中的 Cookie 数据。 </p><h5 id="3-2-用法"><a href="#3-2-用法" class="headerlink" title="3.2 用法"></a>3.2 用法</h5><pre><code class="java">@RequestMapping(&quot;/getCookie&quot;)public String getCookieValue(@CookieValue(value = &quot;JSESSIONID&quot;,defaultValue = &quot;abc&quot;) String cookieValue)&#123;    //目标:获取浏览器中的名为&quot;JSESSIONID&quot;的cookie的值，赋值给CookieValue参数    logger.debug(cookieValue);    return &quot;target&quot;;&#125;</code></pre><h3 id="第四节-获取请求参数-重点"><a href="#第四节-获取请求参数-重点" class="headerlink" title="第四节 获取请求参数(重点)"></a>第四节 获取请求参数(重点)</h3><h4 id="1-根据一个参数名获取一个参数值"><a href="#1-根据一个参数名获取一个参数值" class="headerlink" title="1. 根据一个参数名获取一个参数值"></a>1. 根据一个参数名获取一个参数值</h4><h5 id="1-1-前端页面携带请求参数"><a href="#1-1-前端页面携带请求参数" class="headerlink" title="1.1 前端页面携带请求参数"></a>1.1 前端页面携带请求参数</h5><pre><code class="html">&lt;a th:href=&quot;@&#123;/param/one(userName=&#39;tom&#39;)&#125;&quot;&gt;一个名字一个值的情况&lt;/a&gt;&lt;br/&gt;</code></pre><h5 id="1-2-处理器中获取请求参数"><a href="#1-2-处理器中获取请求参数" class="headerlink" title="1.2 处理器中获取请求参数"></a>1.2 处理器中获取请求参数</h5><h6 id="1-2-1-最简写法"><a href="#1-2-1-最简写法" class="headerlink" title="1.2.1 最简写法"></a>1.2.1 最简写法</h6><pre><code class="java">@RequestMapping(&quot;/oneParameter&quot;)public String oneParameter(String username)&#123;    //最简单的方式获取单个请求参数:就是在handler方法中添加一个和请求参数名同名的参数，来接收请求参数    //其实这个地方String username此处省略了一个注解 @RequestParam    //@RequestParam(&quot;username&quot;)就是通过参数名获取请求参数    logger.debug(username);    return &quot;target&quot;;&#125;</code></pre><h6 id="1-2-2-使用RequestParam注解"><a href="#1-2-2-使用RequestParam注解" class="headerlink" title="1.2.2 使用RequestParam注解"></a>1.2.2 使用RequestParam注解</h6><pre><code class="java">@RequestMapping(&quot;/oneParameter&quot;)public String oneParameter(@RequestParam(&quot;username&quot;) String username)&#123;    //最简单的方式获取单个请求参数:就是在handler方法中添加一个和请求参数名同名的参数，来接收请求参数    //其实这个地方String username此处省略了一个注解 @RequestParam    //@RequestParam(&quot;username&quot;)就是通过参数名获取请求参数    logger.debug(username);    return &quot;target&quot;;&#125;</code></pre><h6 id="1-2-3-如果此时请求中没有携带username参数"><a href="#1-2-3-如果此时请求中没有携带username参数" class="headerlink" title="1.2.3 如果此时请求中没有携带username参数"></a>1.2.3 如果此时请求中没有携带username参数</h6><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_007.png"></p><p>页面信息说明：</p><ul><li>响应状态码：400（在 SpringMVC 环境下，400通常和数据注入相关）</li><li>说明信息：必需的 String 请求参数 ‘username’ 不存在</li></ul><p>原因可以参考 @RequestParam 注解的 required 属性：默认值为true，表示请求参数默认必须提供</p><pre><code class="java">/**     * Whether the parameter is required.     * &lt;p&gt;Defaults to &#123;@code true&#125;, leading to an exception being thrown     * if the parameter is missing in the request. Switch this to     * &#123;@code false&#125; if you prefer a &#123;@code null&#125; value if the parameter is     * not present in the request.     * &lt;p&gt;Alternatively, provide a &#123;@link #defaultValue&#125;, which implicitly     * sets this flag to &#123;@code false&#125;.     */boolean required() default true;</code></pre><p>我们可以通过将required 属性设置为 false 表示这个请求参数可有可无： </p><pre><code class="java">@RequestParam(value = &quot;userName&quot;, required = false)</code></pre><p>当然，我们也可以通过设置请求参数的默认值来解决上述<code>400</code>错误</p><pre><code class="java">@RequestParam(value = &quot;userName&quot;, defaultValue = &quot;missing&quot;)</code></pre><h4 id="2-根据一个参数名获取多个参数值"><a href="#2-根据一个参数名获取多个参数值" class="headerlink" title="2. 根据一个参数名获取多个参数值"></a>2. 根据一个参数名获取多个参数值</h4><h5 id="2-1-前端页面携带请求参数"><a href="#2-1-前端页面携带请求参数" class="headerlink" title="2.1 前端页面携带请求参数"></a>2.1 前端页面携带请求参数</h5><pre><code class="html">&lt;form th:action=&quot;@&#123;/param/multi&#125;&quot; method=&quot;post&quot;&gt;    请选择你最喜欢的球队：    &lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;Brazil&quot;/&gt;巴西    &lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;German&quot;/&gt;德国    &lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;French&quot;/&gt;法国    &lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;Holland&quot;/&gt;荷兰    &lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;Italian&quot;/&gt;意大利    &lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;China&quot;/&gt;中国    &lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;保存&quot;/&gt;&lt;/form&gt;</code></pre><h5 id="2-2-处理器中获取请求参数"><a href="#2-2-处理器中获取请求参数" class="headerlink" title="2.2 处理器中获取请求参数"></a>2.2 处理器中获取请求参数</h5><pre><code class="java">@RequestMapping(&quot;/multi&quot;)public String oneNameMultiValue(@RequestParam(&quot;team&quot;)List&lt;String&gt; teamList)&#123;    logger.debug(teamList.toString());    //要使用什么类型来接收参数    return &quot;target&quot;;&#125;</code></pre><h4 id="3-使用实体类封装请求参数"><a href="#3-使用实体类封装请求参数" class="headerlink" title="3. 使用实体类封装请求参数"></a>3. 使用实体类封装请求参数</h4><h5 id="3-1-前端页面携带请求参数"><a href="#3-1-前端页面携带请求参数" class="headerlink" title="3.1 前端页面携带请求参数"></a>3.1 前端页面携带请求参数</h5><pre><code class="html">&lt;form th:action=&quot;emp/save&quot; method=&quot;post&quot;&gt;    姓名：&lt;input type=&quot;text&quot; name=&quot;empName&quot;/&gt;&lt;br/&gt;    年龄：&lt;input type=&quot;text&quot; name=&quot;empAge&quot;/&gt;&lt;br/&gt;    工资：&lt;input type=&quot;text&quot; name=&quot;empSalary&quot;/&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;保存&quot;/&gt;&lt;/form&gt;</code></pre><h5 id="3-2-封装实体类"><a href="#3-2-封装实体类" class="headerlink" title="3.2 封装实体类"></a>3.2 封装实体类</h5><p>注意: 实体类的属性名要和请求参数名一致</p><pre><code class="java">@Data@AllArgsConstructor@NoArgsConstructorpublic class Employee &#123;    private String empName;    private Integer empAge;    private Double empSalary;&#125;</code></pre><h5 id="3-3-处理器中获取请求参数"><a href="#3-3-处理器中获取请求参数" class="headerlink" title="3.3 处理器中获取请求参数"></a>3.3 处理器中获取请求参数</h5><pre><code class="java">@RequestMapping(&quot;/pojo&quot;)public String parameterToPojo(Employee employee)&#123;    //获取请求参数封装到Employee对象中:只需要保证Employee类中的属性和请求参数名一致    logger.debug(employee.toString());    return &quot;target&quot;;&#125;</code></pre><h5 id="3-4-解决POST请求的中文字符乱码问题"><a href="#3-4-解决POST请求的中文字符乱码问题" class="headerlink" title="3.4 解决POST请求的中文字符乱码问题"></a>3.4 解决POST请求的中文字符乱码问题</h5><p>到 web.xml 中配置 CharacterEncodingFilter 即可：</p><pre><code class="xml">&lt;!-- 配置过滤器解决 POST 请求的字符乱码问题 --&gt;&lt;filter&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;!-- encoding参数指定要使用的字符集名称 --&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;        &lt;!-- 请求强制编码 --&gt;    &lt;init-param&gt;        &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt;        &lt;param-value&gt;true&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;!-- 响应强制编码 --&gt;    &lt;init-param&gt;        &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt;        &lt;param-value&gt;true&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><p>注1：在较低版本的 SpringMVC 中，forceRequestEncoding 属性、forceResponseEncoding 属性没有分开，它们是一个 forceEncoding 属性。这里需要注意一下。</p><p>注2：由于 CharacterEncodingFilter 是通过 request.setCharacterEncoding(encoding); 来设置请求字符集，所以在此操作前不能有任何的 request.getParameter() 操作。在设置字符集之前获取过请求参数，那么设置字符集的操作将无效。</p><h4 id="4-使用Map封装请求参数"><a href="#4-使用Map封装请求参数" class="headerlink" title="4. 使用Map封装请求参数"></a>4. 使用Map封装请求参数</h4><h5 id="4-1-前端页面表单"><a href="#4-1-前端页面表单" class="headerlink" title="4.1 前端页面表单"></a>4.1 前端页面表单</h5><pre><code class="html">&lt;form th:action=&quot;@&#123;/parameter/map&#125;&quot; method=&quot;post&quot;&gt;    姓名：&lt;input type=&quot;text&quot; name=&quot;empName&quot;/&gt;&lt;br/&gt;    年龄：&lt;input type=&quot;text&quot; name=&quot;empAge&quot;/&gt;&lt;br/&gt;    工资：&lt;input type=&quot;text&quot; name=&quot;empSalary&quot;/&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;保存&quot;/&gt;&lt;/form&gt;</code></pre><h5 id="4-2-handler方法接收参数"><a href="#4-2-handler方法接收参数" class="headerlink" title="4.2 handler方法接收参数"></a>4.2 handler方法接收参数</h5><pre><code class="java">@RequestMapping(&quot;/map&quot;)public String parameterToMap(@RequestParam Map map)&#123;    //获取请求参数，封装到Map中:请求参数名就是map的key，请求参数值就是map的value    logger.debug(map.toString());    return &quot;target&quot;;&#125;</code></pre><h4 id="5-实体类封装的数据包含级联属性-了解"><a href="#5-实体类封装的数据包含级联属性-了解" class="headerlink" title="5. 实体类封装的数据包含级联属性(了解"></a>5. 实体类封装的数据包含级联属性(了解</h4><h5 id="5-1-实体类"><a href="#5-1-实体类" class="headerlink" title="5.1 实体类"></a>5.1 实体类</h5><h6 id="Student"><a href="#Student" class="headerlink" title="Student"></a>Student</h6><pre><code class="java">public class Student &#123;    private String stuName;    private School school;    private List&lt;Subject&gt; subjectList;    private Subject[] subjectArray;    private List&lt;Teacher&gt; teacherList;    private Map&lt;String, Double&gt; scores;    ……</code></pre><h6 id="School"><a href="#School" class="headerlink" title="School"></a>School</h6><pre><code class="java">public class School &#123;        private String schoolName;    ……</code></pre><h6 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h6><pre><code class="java">public class Subject &#123;        private String subjectName;    ……</code></pre><h6 id="Teacher"><a href="#Teacher" class="headerlink" title="Teacher"></a>Teacher</h6><pre><code class="java">public class Teacher &#123;        private String teacherName;    ……</code></pre><h5 id="5-2-前端页面携带请求参数"><a href="#5-2-前端页面携带请求参数" class="headerlink" title="5.2 前端页面携带请求参数"></a>5.2 前端页面携带请求参数</h5><p>表单项中的 name 属性值必须严格按照级联对象的属性来设定： </p><pre><code class="html">&lt;!-- 提交数据的表单 --&gt;&lt;form th:action=&quot;@&#123;param/toNestEntity&#125;&quot; method=&quot;post&quot;&gt;    stuName：&lt;input type=&quot;text&quot; name=&quot;stuName&quot; value=&quot;tom&quot;/&gt;&lt;br/&gt;    school.schoolName:&lt;input type=&quot;text&quot; name=&quot;school.schoolName&quot; value=&quot;atguigu&quot;/&gt;&lt;br/&gt;    subjectList[0].subjectName:&lt;input type=&quot;text&quot; name=&quot;subjectList[0].subjectName&quot; value=&quot;java&quot;/&gt;&lt;br/&gt;    subjectList[1].subjectName:&lt;input type=&quot;text&quot; name=&quot;subjectList[1].subjectName&quot; value=&quot;php&quot;/&gt;&lt;br/&gt;    subjectList[2].subjectName:&lt;input type=&quot;text&quot; name=&quot;subjectList[2].subjectName&quot; value=&quot;javascript&quot;/&gt;&lt;br/&gt;    subjectList[3].subjectName:&lt;input type=&quot;text&quot; name=&quot;subjectList[3].subjectName&quot; value=&quot;css&quot;/&gt;&lt;br/&gt;    subjectList[4].subjectName:&lt;input type=&quot;text&quot; name=&quot;subjectList[4].subjectName&quot; value=&quot;vue&quot;/&gt;&lt;br/&gt;    subjectArray[0].subjectName:&lt;input type=&quot;text&quot; name=&quot;subjectArray[0].subjectName&quot; value=&quot;spring&quot;/&gt;&lt;br/&gt;    subjectArray[1].subjectName:&lt;input type=&quot;text&quot; name=&quot;subjectArray[1].subjectName&quot; value=&quot;SpringMVC&quot;/&gt;&lt;br/&gt;    subjectArray[2].subjectName:&lt;input type=&quot;text&quot; name=&quot;subjectArray[2].subjectName&quot; value=&quot;mybatis&quot;/&gt;&lt;br/&gt;    subjectArray[3].subjectName:&lt;input type=&quot;text&quot; name=&quot;subjectArray[3].subjectName&quot; value=&quot;maven&quot;/&gt;&lt;br/&gt;    subjectArray[4].subjectName:&lt;input type=&quot;text&quot; name=&quot;subjectArray[4].subjectName&quot; value=&quot;mysql&quot;/&gt;&lt;br/&gt;    teacherList[0].teacherName:&lt;input type=&quot;text&quot; name=&quot;teacherList[0].teacherName&quot; value=&quot;t_one&quot;/&gt;&lt;br/&gt;    teacherList[1].teacherName:&lt;input type=&quot;text&quot; name=&quot;teacherList[1].teacherName&quot; value=&quot;t_two&quot;/&gt;&lt;br/&gt;    teacherList[2].teacherName:&lt;input type=&quot;text&quot; name=&quot;teacherList[2].teacherName&quot; value=&quot;t_three&quot;/&gt;&lt;br/&gt;    teacherList[3].teacherName:&lt;input type=&quot;text&quot; name=&quot;teacherList[3].teacherName&quot; value=&quot;t_four&quot;/&gt;&lt;br/&gt;    teacherList[4].teacherName:&lt;input type=&quot;text&quot; name=&quot;teacherList[4].teacherName&quot; value=&quot;t_five&quot;/&gt;&lt;br/&gt;    scores[&#39;Chinese&#39;]：input type=&quot;text&quot; name=&quot;scores[&#39;Chinese&#39;]&quot; value=&quot;100&quot;/&gt;&lt;br/&gt;    scores[&#39;English&#39;]：&lt;input type=&quot;text&quot; name=&quot;scores[&#39;English&#39;]&quot; value=&quot;95&quot; /&gt;&lt;br/&gt;    scores[&#39;Mathematics&#39;]：&lt;input type=&quot;text&quot; name=&quot;scores[&#39;Mathematics&#39;]&quot; value=&quot;88&quot;/&gt;&lt;br/&gt;    scores[&#39;Chemistry&#39;]：&lt;input type=&quot;text&quot; name=&quot;scores[&#39;Chemistry&#39;]&quot; value=&quot;63&quot;/&gt;&lt;br/&gt;    scores[&#39;Biology&#39;]：&lt;input type=&quot;text&quot; name=&quot;scores[&#39;Biology&#39;]&quot; value=&quot;44&quot;/&gt;&lt;br/&gt;    &lt;input type=&quot;submit&quot; value=&quot;保存&quot;/&gt;&lt;/form&gt;</code></pre><h5 id="5-3-处理器中获取请求参数"><a href="#5-3-处理器中获取请求参数" class="headerlink" title="5.3 处理器中获取请求参数"></a>5.3 处理器中获取请求参数</h5><pre><code class="java">@RequestMapping(&quot;/param/toNestEntity&quot;)public String formToNestedEntity(        // SpringMVC 自己懂得注入级联属性，只要属性名和对应的getXxx()、setXxx()匹配即可        Student student) &#123;    logger.debug(student.toString());        return &quot;target&quot;;&#125;</code></pre><h3 id="第五节-访问静态资源-重点"><a href="#第五节-访问静态资源-重点" class="headerlink" title="第五节 访问静态资源(重点)"></a>第五节 访问静态资源(重点)</h3><h4 id="1-SpringMVC环境下的静态资源访问问题"><a href="#1-SpringMVC环境下的静态资源访问问题" class="headerlink" title="1. SpringMVC环境下的静态资源访问问题"></a>1. SpringMVC环境下的静态资源访问问题</h4><h5 id="1-1-问题描述"><a href="#1-1-问题描述" class="headerlink" title="1.1 问题描述"></a>1.1 问题描述</h5><p>在 Web 应用中加入图片资源：</p><p> <img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_009.png"></p><p>访问静态资源</p><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_010.png"></p><h5 id="1-2-分析原因"><a href="#1-2-分析原因" class="headerlink" title="1.2 分析原因"></a>1.2 分析原因</h5><ul><li>DispatcherServlet 的 url-pattern 配置的是“/”</li><li>url-pattern 配置“/”表示整个 Web 应用范围内所有请求都由 SpringMVC 来处理</li><li>对 SpringMVC 来说，必须有对应的 @RequestMapping 才能找到处理请求的方法</li><li>现在static/images/mm.jpg 请求没有对应的 @RequestMapping 所以返回 404</li></ul><h5 id="1-3-解决办法"><a href="#1-3-解决办法" class="headerlink" title="1.3 解决办法"></a>1.3 解决办法</h5><p>在 SpringMVC 配置文件中增加配置：</p><pre><code class="xml">&lt;!-- 加入这个配置，SpringMVC 就会在遇到没有 @RequestMapping 的请求时放它过去 --&gt;&lt;!-- 所谓放它过去就是让这个请求去找它原本要访问的资源 --&gt;&lt;mvc:default-servlet-handler/&gt;</code></pre><p>再次测试访问图片：</p><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_011.png"></p><p>新的问题：其他原本正常的请求访问不了了,进一步解决问题：再增加一个配置</p><pre><code class="xml">&lt;!-- 开启 SpringMVC 的注解驱动功能。这个配置也被称为 SpringMVC 的标配。 --&gt;&lt;!-- 标配：因为 SpringMVC 环境下非常多的功能都要求必须打开注解驱动才能正常工作。 --&gt;&lt;mvc:annotation-driven/&gt;</code></pre><h5 id="1-4-default-servlet-handler底层-了解"><a href="#1-4-default-servlet-handler底层-了解" class="headerlink" title="1.4 default-servlet-handler底层[了解]"></a>1.4 default-servlet-handler底层[了解]</h5><p>所在类：org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler</p><p>关键方法：handleRequest()方法</p><p>大体机制：SpringMVC 首先查找是否存在和当前请求对应的 @RequestMapping；如果没有，则调用handleRequest()方法转发到目标资源。</p><pre><code class="java">@Overridepublic void handleRequest(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException &#123;        Assert.state(this.servletContext != null, &quot;No ServletContext set&quot;);    RequestDispatcher rd = this.servletContext.getNamedDispatcher(this.defaultServletName);    if (rd == null) &#123;        throw new IllegalStateException(&quot;A RequestDispatcher could not be located for the default servlet &#39;&quot; +        this.defaultServletName + &quot;&#39;&quot;);    &#125;        // 这里执行请求转发操作    rd.forward(request, response);&#125;</code></pre><h3 id="第六节-页面跳转控制"><a href="#第六节-页面跳转控制" class="headerlink" title="第六节 页面跳转控制"></a>第六节 页面跳转控制</h3><h4 id="1-访问Thymeleaf前后缀控制范围内的页面"><a href="#1-访问Thymeleaf前后缀控制范围内的页面" class="headerlink" title="1. 访问Thymeleaf前后缀控制范围内的页面"></a>1. 访问Thymeleaf前后缀控制范围内的页面</h4><p>访问Thymeleaf前后缀控制范围之内的页面，直接<code>return</code>逻辑视图即可，但是访问前后缀控制范围之外的页面，则需要使用重定向或者请求转发</p><h4 id="2-访问Thymeleaf前后缀控制范围外的页面-了解"><a href="#2-访问Thymeleaf前后缀控制范围外的页面-了解" class="headerlink" title="2. 访问Thymeleaf前后缀控制范围外的页面(了解)"></a>2. 访问Thymeleaf前后缀控制范围外的页面(了解)</h4><h5 id="2-1-创建范围之外的页面"><a href="#2-1-创建范围之外的页面" class="headerlink" title="2.1 创建范围之外的页面"></a>2.1 创建范围之外的页面</h5><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_008.png"></p><pre><code class="html">&lt;body&gt;        &lt;h1&gt;范围之外页面&lt;/h1&gt;    &lt;/body&gt;</code></pre><h5 id="2-2-在-SpringMVC-配置文件加入配置"><a href="#2-2-在-SpringMVC-配置文件加入配置" class="headerlink" title="2.2 在 SpringMVC 配置文件加入配置"></a>2.2 在 SpringMVC 配置文件加入配置</h5><p>下面配置是访问静态资源所需配置(如果没有它的话，访问静态资源会被DispatcherServlet所拦截)： </p><pre><code class="xml">&lt;mvc:annotation-driven/&gt;&lt;mvc:default-servlet-handler/&gt;</code></pre><h5 id="2-3-使用指令进行跳转-了解"><a href="#2-3-使用指令进行跳转-了解" class="headerlink" title="2.3 使用指令进行跳转(了解)"></a>2.3 使用指令进行跳转(了解)</h5><h6 id="2-3-1-请求转发的指令"><a href="#2-3-1-请求转发的指令" class="headerlink" title="2.3.1 请求转发的指令"></a>2.3.1 请求转发的指令</h6><pre><code class="java">@RequestMapping(&quot;/forwardCommand&quot;)public String forwardCommand()&#123;    //使用转发指令:在handler方法中，访问Thymeleaf前后缀控制范围外的页面    //&quot;forward:要转发到的资源路径&quot;,相当于使用的是请求转发跳转    //请求转发的绝对路径是:在uri的基础上省略&quot;/项目名&quot;    return &quot;forward:/outter.html&quot;;&#125;</code></pre><h6 id="2-3-2-重定向的指令"><a href="#2-3-2-重定向的指令" class="headerlink" title="2.3.2 重定向的指令"></a>2.3.2 重定向的指令</h6><pre><code class="java">@RequestMapping(&quot;/redirectCommand&quot;)public String redirectCommand()&#123;    //使用重定向指令:在handler方法中，访问Thymeleaf前后缀控制范围外的页面    //&quot;redirect:要转发到的资源路径&quot;,相当于使用的是请求转发跳转    //重定向的绝对路径:就是uri   &quot;/项目名/资源路径&quot;    //因为SpringMVC框架在接收到redirect指令之后，会自动给访问路径加上&quot;/项目名&quot;    return &quot;redirect:/outter.html&quot;;&#125;</code></pre><h4 id="3-mvc-view-controller访问页面-重点"><a href="#3-mvc-view-controller访问页面-重点" class="headerlink" title="3. mvc:view-controller访问页面(重点)"></a>3. mvc:view-controller访问页面(重点)</h4><h5 id="3-1-场景描述"><a href="#3-1-场景描述" class="headerlink" title="3.1 场景描述"></a>3.1 场景描述</h5><p>在一个 handler 方法中，仅仅只是完成 @RequestMapping 映射，将请求转发到目标视图，除此之外没有任何其他代码。此时可以使用 SpringMVC 配置文件中的配置代替这样的 handler 方法。 </p><h5 id="3-2-具体操作"><a href="#3-2-具体操作" class="headerlink" title="3.2 具体操作"></a>3.2 具体操作</h5><h6 id="3-2-1-访问Thymeleaf前后缀控制范围内的页面"><a href="#3-2-1-访问Thymeleaf前后缀控制范围内的页面" class="headerlink" title="3.2.1 访问Thymeleaf前后缀控制范围内的页面"></a>3.2.1 访问Thymeleaf前后缀控制范围内的页面</h6><p>在 SpringMVC 配置文件中使用 mvc:view-controller 配置： </p><pre><code class="xml">&lt;mvc:view-controller path=&quot;/index.html&quot; view-name=&quot;portal&quot;/&gt;</code></pre><p>此时浏览器路径”index.html”可以访问到Thymeleaf前后缀控制范围内的portal.html页面</p><h6 id="3-2-2-访问Thymeleaf前后缀控制范围外的页面"><a href="#3-2-2-访问Thymeleaf前后缀控制范围外的页面" class="headerlink" title="3.2.2 访问Thymeleaf前后缀控制范围外的页面"></a>3.2.2 访问Thymeleaf前后缀控制范围外的页面</h6><p>在 SpringMVC 配置文件中使用 mvc:view-controller 配置：</p><pre><code class="xml">&lt;mvc:view-controller path=&quot;/test/redirect/command&quot; view-name=&quot;redirect:/outter.html&quot;/&gt;</code></pre><p>此时就相当于代替了之前的重定向访问的那个handler方法</p><h5 id="3-3-遇到的问题"><a href="#3-3-遇到的问题" class="headerlink" title="3.3 遇到的问题"></a>3.3 遇到的问题</h5><p>加入 mvc:view-controller 配置后，其他正常 @RequestMapping 将失效。此时还是需要加入 mvc:annotation-driven 来解决。 </p><h4 id="4-三个配置影响访问效果探索-了解"><a href="#4-三个配置影响访问效果探索-了解" class="headerlink" title="4. 三个配置影响访问效果探索(了解)"></a>4. 三个配置影响访问效果探索(了解)</h4><p>通过前面的学习，我们发现无论是添加了<code>default-servlet-handler</code>还是<code>view-controller</code>,我们都必须添加<code>annotation-driven</code>标签。所以<code>annotation-driven</code>标签是SpringMVC必须添加的</p><p>接下来我们从源码角度分析这三个配置:</p><h5 id="4-1-相关组件：HandlerMapping"><a href="#4-1-相关组件：HandlerMapping" class="headerlink" title="4.1 相关组件：HandlerMapping"></a>4.1 相关组件：HandlerMapping</h5><p>见名知意，HandlerMapping 封装的数据包含了请求地址和 handler 方法之间的映射关系。所以请求访问是否能生效关键要看 HandlerMapping 在 IOC 容器中加载的情况。为了看到这一点，我们可以在 DispatcherServlet 中找到 doDispatch() 方法设置断点。之所以选择这个方法，是因为每一个由 SpringMVC 处理的请求都会经过这里，便于操作。 </p><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_014.png"></p><h5 id="4-2-按三种标签的配置情况进行分析"><a href="#4-2-按三种标签的配置情况进行分析" class="headerlink" title="4.2 按三种标签的配置情况进行分析"></a>4.2 按三种标签的配置情况进行分析</h5><h6 id="4-2-1-三个标签都没有配置的情况"><a href="#4-2-1-三个标签都没有配置的情况" class="headerlink" title="4.2.1 三个标签都没有配置的情况"></a>4.2.1 三个标签都没有配置的情况</h6><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_015.png"></p><p>我们看到 SpringMVC 加载了三个 HandlerMapping：</p><blockquote><p>org.springframework.web.servlet.handler.<strong>BeanNameUrlHandlerMapping</strong></p><p>org.springframework.web.servlet.mvc.method.annotation.<strong>RequestMappingHandlerMapping</strong></p><p>org.springframework.web.servlet.function.support.<strong>RouterFunctionMapping</strong></p></blockquote><p>其中 RequestMappingHandlerMapping 封装了 @RequestMapping 相关请求，有它在 @RequestMapping 相关请求就能访问到。</p><p>这里顺带一提，在较低版本的 SpringMVC 此处要加载的是：</p><blockquote><p>org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</p></blockquote><p>其中 DefaultAnnotationHandlerMapping 封装了 @RequestMapping 相关请求，有它在 @RequestMapping 相关请求就能访问到。</p><h6 id="4-2-2-配置了-mvc-view-controller-或-mvc-default-servlet-handler-的情况"><a href="#4-2-2-配置了-mvc-view-controller-或-mvc-default-servlet-handler-的情况" class="headerlink" title="4.2.2  配置了 mvc:view-controller 或 mvc:default-servlet-handler 的情况"></a>4.2.2  配置了 mvc:view-controller 或 mvc:default-servlet-handler 的情况</h6><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_016.png"></p><p>我们看到 SpringMVC 加载了两个 HandlerMapping：</p><blockquote><p>org.springframework.web.servlet.handler.<strong>SimpleUrlHandlerMapping</strong></p><p>org.springframework.web.servlet.handler.<strong>BeanNameUrlHandlerMapping</strong></p></blockquote><p>此时没有了RequestMappingHandlerMapping，所以无法根据@RequestMapping的映射来调用handler方法了</p><p>较低版本的 SpringMVC 在这里的情况一样。</p><h6 id="4-2-3-三个标签全部配置了的情况"><a href="#4-2-3-三个标签全部配置了的情况" class="headerlink" title="4.2.3 三个标签全部配置了的情况"></a>4.2.3 三个标签全部配置了的情况</h6><p>配置全部 mvc:view-controller、mvc:default-servlet-handler、mvc:annotation-driven 三个标签。 </p><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_017.png"></p><p>我们看到 SpringMVC 加载了略有不同的三个 HandlerMapping：</p><blockquote><p>org.springframework.web.servlet.mvc.method.annotation.<strong>RequestMappingHandlerMapping</strong></p><p>org.springframework.web.servlet.handler.<strong>SimpleUrlHandlerMapping</strong></p><p>org.springframework.web.servlet.handler.<strong>BeanNameUrlHandlerMapping</strong></p></blockquote><p>此时RequestMappingHandlerMapping 封装了 @RequestMapping 相关请求，有它在 @RequestMapping 相关请求就能访问到。</p><p>较低版本的 SpringMVC 在这里的情况还是一样。</p><h2 id="第二章-SpringMVC使用域对象"><a href="#第二章-SpringMVC使用域对象" class="headerlink" title="第二章 SpringMVC使用域对象"></a>第二章 SpringMVC使用域对象</h2><h3 id="第一节-请求域对象"><a href="#第一节-请求域对象" class="headerlink" title="第一节 请求域对象"></a>第一节 请求域对象</h3><h4 id="1-将数据存入请求域对象"><a href="#1-将数据存入请求域对象" class="headerlink" title="1. 将数据存入请求域对象"></a>1. 将数据存入请求域对象</h4><h5 id="1-1-使用原生的Servlet的API操作"><a href="#1-1-使用原生的Servlet的API操作" class="headerlink" title="1.1 使用原生的Servlet的API操作"></a>1.1 使用原生的Servlet的API操作</h5><pre><code class="java">@RequestMapping(&quot;/testAttrOriginalRequest&quot;)public String testAttrOriginalRequest(HttpServletRequest request)&#123;    //目标:将数据存储到请求域对象，然后跳转到target页面    //方式一:使用原始的request来完成    request.setAttribute(&quot;username&quot;,&quot;aobama&quot;);    return &quot;target&quot;;&#125;</code></pre><h5 id="1-2-使用-Model-类型的形参操作"><a href="#1-2-使用-Model-类型的形参操作" class="headerlink" title="1.2 使用 Model 类型的形参操作"></a>1.2 使用 Model 类型的形参操作</h5><pre><code class="java">@RequestMapping(&quot;/testAttrRequestModel&quot;)public String testAttrRequestModel(Model model)&#123;    //目标:目标:将数据存储到请求域对象，然后跳转到target页面    //方式二:使用Model对象往请求域中存储值    model.addAttribute(&quot;username&quot;,&quot;aolafu&quot;);    return &quot;target&quot;;&#125;</code></pre><h5 id="1-3-使用-ModelMap-类型的形参"><a href="#1-3-使用-ModelMap-类型的形参" class="headerlink" title="1.3 使用 ModelMap 类型的形参"></a>1.3 使用 ModelMap 类型的形参</h5><pre><code class="java">@RequestMapping(&quot;/attr/request/model/map&quot;)public String testAttrRequestModelMap(            // 在形参位置声明ModelMap类型变量，用于存储模型数据        ModelMap modelMap) &#123;        // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域    // 存入请求域这个动作也被称为暴露到请求域    modelMap.addAttribute(&quot;requestScopeMessageModelMap&quot;,&quot;i am very happy[model map]&quot;);        return &quot;target&quot;;&#125;</code></pre><h5 id="1-4-使用-Map-类型的形参"><a href="#1-4-使用-Map-类型的形参" class="headerlink" title="1.4 使用 Map 类型的形参"></a>1.4 使用 Map 类型的形参</h5><pre><code class="java">@RequestMapping(&quot;/attr/request/map&quot;)public String testAttrRequestMap(            // 在形参位置声明Map类型变量，用于存储模型数据        Map&lt;String, Object&gt; map) &#123;        // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域    // 存入请求域这个动作也被称为暴露到请求域    map.put(&quot;requestScopeMessageMap&quot;, &quot;i am very happy[map]&quot;);        return &quot;target&quot;;&#125;</code></pre><h5 id="1-5-使用-ModelAndView-对象"><a href="#1-5-使用-ModelAndView-对象" class="headerlink" title="1.5 使用 ModelAndView 对象"></a>1.5 使用 ModelAndView 对象</h5><pre><code class="java">@RequestMapping(&quot;/attr/request/mav&quot;)public ModelAndView testAttrByModelAndView() &#123;        // 1.创建ModelAndView对象    ModelAndView modelAndView = new ModelAndView();        // 2.存入模型数据    modelAndView.addObject(&quot;requestScopeMessageMAV&quot;, &quot;i am very happy[mav]&quot;);        // 3.设置视图名称    modelAndView.setViewName(&quot;target&quot;);        return modelAndView;&#125;</code></pre><h4 id="2-模型的本质"><a href="#2-模型的本质" class="headerlink" title="2. 模型的本质"></a>2. 模型的本质</h4><h5 id="2-1-BindingAwareModelMap"><a href="#2-1-BindingAwareModelMap" class="headerlink" title="2.1 BindingAwareModelMap"></a>2.1 BindingAwareModelMap</h5><p>SpringMVC 传入的 Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的。 </p><h5 id="2-2-体系结构"><a href="#2-2-体系结构" class="headerlink" title="2.2 体系结构"></a>2.2 体系结构</h5><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_012.png"></p><h4 id="3-框架底层将模型存入请求域的原理"><a href="#3-框架底层将模型存入请求域的原理" class="headerlink" title="3. 框架底层将模型存入请求域的原理"></a>3. 框架底层将模型存入请求域的原理</h4><h5 id="3-1-源码位置"><a href="#3-1-源码位置" class="headerlink" title="3.1 源码位置"></a>3.1 源码位置</h5><p>所在类：org.thymeleaf.context.WebEngineContext</p><p>所在方法：setVariable()</p><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_013.png"></p><h3 id="第二节-会话域对象"><a href="#第二节-会话域对象" class="headerlink" title="第二节 会话域对象"></a>第二节 会话域对象</h3><p>使用会话域最简单直接的办法就是使用原生的 HttpSession 对象 </p><pre><code class="java">@RequestMapping(&quot;/attrSession&quot;)public String attrSession(HttpSession httpSession)&#123;    //目标:往会话域中存储数据    httpSession.setAttribute(&quot;address&quot;,&quot;召唤师峡谷&quot;);    return &quot;target&quot;;&#125;</code></pre><h3 id="第三节-应用域"><a href="#第三节-应用域" class="headerlink" title="第三节 应用域"></a>第三节 应用域</h3><p>应用域同样是使用IOC注入的方式来操作： </p><pre><code class="java">@Autowiredprivate ServletContext servletContext;@RequestMapping(&quot;/attr/application&quot;)public String attrApplication() &#123;        servletContext.setAttribute(&quot;appScopeMsg&quot;, &quot;i am hungry...&quot;);        return &quot;target&quot;;&#125;</code></pre><h2 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h2><h3 id="第一节-案例准备工作"><a href="#第一节-案例准备工作" class="headerlink" title="第一节 案例准备工作"></a>第一节 案例准备工作</h3><h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h4><pre><code class="xml">&lt;dependencies&gt;    &lt;!-- SpringMVC --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 日志 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;        &lt;version&gt;1.2.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- ServletAPI --&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;        &lt;version&gt;3.1.0&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- Spring5和Thymeleaf整合包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;        &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;        &lt;version&gt;3.0.12.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;        &lt;version&gt;5.7.0&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--引入LomBok的依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;version&gt;1.18.8&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- MySQL驱动 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 数据源 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.0.31&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h4 id="2-数据建模"><a href="#2-数据建模" class="headerlink" title="2 数据建模"></a>2 数据建模</h4><h5 id="2-1-物理建模"><a href="#2-1-物理建模" class="headerlink" title="2.1 物理建模"></a>2.1 物理建模</h5><pre><code class="mysql">CREATE TABLE t_movie(    movie_id INT PRIMARY KEY AUTO_INCREMENT,    movie_name VARCHAR(50),    movie_price DOUBLE);INSERT INTO t_movie(movie_name,movie_price) VALUES (&quot;肖申克救赎&quot;,10.0),(&quot;泰坦尼克号&quot;,20.0),(&quot;审死官&quot;,30.0),(&quot;大话西游之大圣娶亲&quot;,40.0),(&quot;大话西游之仙履奇缘&quot;,50.0),(&quot;功夫&quot;,60.0)</code></pre><h5 id="2-2-逻辑建模"><a href="#2-2-逻辑建模" class="headerlink" title="2.2 逻辑建模"></a>2.2 逻辑建模</h5><pre><code class="java">@Data@AllArgsConstructor@NoArgsConstructorpublic class Movie &#123;    private Integer movieId;    private String movieName;    private Double moviePrice;&#125;</code></pre><h4 id="3-创建Dao"><a href="#3-创建Dao" class="headerlink" title="3. 创建Dao"></a>3. 创建Dao</h4><h5 id="3-1-接口"><a href="#3-1-接口" class="headerlink" title="3.1 接口"></a>3.1 接口</h5><pre><code class="java">package com.atguigu.dao;import com.atguigu.pojo.Movie;import java.util.List;/** * 包名:com.atguigu.dao * * @author Leevi * 日期2021-09-06  10:01 */public interface MovieDao &#123;    /**     * 查询所有     * @return     */    List&lt;Movie&gt; getAll();    /**     * 根据id查询     * @param movieId     * @return     */    Movie getMovieById(String movieId);    /**     * 添加Movie     * @param movie     */    void saveMovie(Movie movie);    /**     * 修改Movie     * @param movie     */    void updateMovie(Movie movie);    /**     * 根据id删除     * @param movieId     */    void removeMovieById(String movieId);&#125;</code></pre><h5 id="3-2-实现类"><a href="#3-2-实现类" class="headerlink" title="3.2 实现类"></a>3.2 实现类</h5><pre><code class="java">package com.atguigu.dao.impl;import com.atguigu.dao.MovieDao;import com.atguigu.pojo.Movie;import java.util.List;/** * 包名:com.atguigu.dao.impl * * @author Leevi * 日期2021-09-06  10:03 */public class MovieDaoImpl implements MovieDao &#123;    @Override    public List&lt;Movie&gt; getAll() &#123;        return null;    &#125;    @Override    public Movie getMovieById(String movieId) &#123;        return null;    &#125;    @Override    public void saveMovie(Movie movie) &#123;    &#125;    @Override    public void updateMovie(Movie movie) &#123;    &#125;    @Override    public void removeMovieById(String movieId) &#123;    &#125;&#125;</code></pre><h4 id="4-创建Service"><a href="#4-创建Service" class="headerlink" title="4 创建Service"></a>4 创建Service</h4><h5 id="4-1-接口"><a href="#4-1-接口" class="headerlink" title="4.1 接口"></a>4.1 接口</h5><pre><code class="java">package com.atguigu.service;import com.atguigu.pojo.Movie;import java.util.List;/** * 包名:com.atguigu.service * * @author Leevi * 日期2021-09-06  10:03 */public interface MovieService &#123;    /**     * 查询所有     * @return     */    List&lt;Movie&gt; getAll();    /**     * 根据id查询     * @param movieId     * @return     */    Movie getMovieById(String movieId);    /**     * 添加Movie     * @param movie     */    void saveMovie(Movie movie);    /**     * 修改Movie     * @param movie     */    void updateMovie(Movie movie);    /**     * 根据id删除     * @param movieId     */    void removeMovieById(String movieId);&#125;</code></pre><h5 id="4-2-实现类"><a href="#4-2-实现类" class="headerlink" title="4.2 实现类"></a>4.2 实现类</h5><pre><code class="java">package com.atguigu.dao.impl;import com.atguigu.dao.MovieDao;import com.atguigu.pojo.Movie;import java.util.List;public class MovieDaoImpl implements MovieDao &#123;    @Override    public List&lt;Movie&gt; getAll() &#123;        return null;    &#125;    @Override    public Movie getMovieById(String movieId) &#123;        return null;    &#125;    @Override    public void saveMovie(Movie movie) &#123;    &#125;    @Override    public void updateMovie(Movie movie) &#123;    &#125;    @Override    public void removeMovieById(String movieId) &#123;    &#125;&#125;</code></pre><h3 id="第二节-环境搭建"><a href="#第二节-环境搭建" class="headerlink" title="第二节 环境搭建"></a>第二节 环境搭建</h3><h4 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1 配置文件"></a>1 配置文件</h4><h5 id="1-1-web-xml"><a href="#1-1-web-xml" class="headerlink" title="1.1 web.xml"></a>1.1 web.xml</h5><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;         version=&quot;2.5&quot;&gt;    &lt;!--DispatcherServlet--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;!--CharacterEncodingFilter--&gt;    &lt;!-- 配置过滤器解决 POST 请求的字符乱码问题 --&gt;    &lt;filter&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;!-- encoding参数指定要使用的字符集名称 --&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;!-- 请求强制编码 --&gt;        &lt;init-param&gt;            &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt;            &lt;param-value&gt;true&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;!-- 响应强制编码 --&gt;        &lt;init-param&gt;            &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt;            &lt;param-value&gt;true&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;</code></pre><h5 id="1-2-logback-xml"><a href="#1-2-logback-xml" class="headerlink" title="1.2 logback.xml"></a>1.2 logback.xml</h5><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;true&quot;&gt;    &lt;!-- 指定日志输出的位置 --&gt;    &lt;appender name=&quot;STDOUT&quot;              class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;encoder&gt;            &lt;!-- 日志输出的格式 --&gt;            &lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;            &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;        &lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;    &lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;    &lt;root level=&quot;INFO&quot;&gt;        &lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;    &lt;/root&gt;        &lt;!-- 根据特殊需求指定局部日志级别 --&gt;    &lt;logger name=&quot;org.springframework.web.servlet.DispatcherServlet&quot; level=&quot;DEBUG&quot; /&gt;    &lt;/configuration&gt;</code></pre><h5 id="1-3-SpringMVC-配置文件springmvc-xml"><a href="#1-3-SpringMVC-配置文件springmvc-xml" class="headerlink" title="1.3 SpringMVC 配置文件springmvc.xml"></a>1.3 SpringMVC 配置文件springmvc.xml</h5><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/context                           https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!--1.包扫描--&gt;    &lt;context:component-scan base-package=&quot;com.atguigu&quot;/&gt;    &lt;!--2. Thymeleaf解析器的配置--&gt;    &lt;!-- Thymeleaf视图解析器 --&gt;    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt;        &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt;        &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt;        &lt;property name=&quot;templateEngine&quot;&gt;            &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt;                &lt;property name=&quot;templateResolver&quot;&gt;                    &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt;                        &lt;!-- 视图前缀 --&gt;                        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt;                        &lt;!-- 视图后缀 --&gt;                        &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt;                        &lt;!--模板类型--&gt;                        &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt;                        &lt;!--模板的字符编码--&gt;                        &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt;                    &lt;/bean&gt;                &lt;/property&gt;            &lt;/bean&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!--3. 加载MVC注解驱动--&gt;    &lt;mvc:annotation-driven /&gt;    &lt;!--4. 静态资源处理--&gt;    &lt;mvc:default-servlet-handler/&gt;&lt;/beans&gt;</code></pre><h3 id="第三节-持久层代码"><a href="#第三节-持久层代码" class="headerlink" title="第三节 持久层代码"></a>第三节 持久层代码</h3><h4 id="1-数据源配置文件-jdbc-properties"><a href="#1-数据源配置文件-jdbc-properties" class="headerlink" title="1. 数据源配置文件:jdbc.properties"></a>1. 数据源配置文件:jdbc.properties</h4><pre><code class="properties">jdbc.username=rootjdbc.password=123456jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/springmvc-test</code></pre><h4 id="2-配置数据源-在springmvc-xml中"><a href="#2-配置数据源-在springmvc-xml中" class="headerlink" title="2. 配置数据源:在springmvc.xml中"></a>2. 配置数据源:在springmvc.xml中</h4><pre><code class="xml">&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;&lt;!--5. 对数据源进行IOC--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;&lt;/bean&gt;</code></pre><h4 id="3-配置JdbcTemplate-在springmvc-xml中"><a href="#3-配置JdbcTemplate-在springmvc-xml中" class="headerlink" title="3. 配置JdbcTemplate:在springmvc.xml中"></a>3. 配置JdbcTemplate:在springmvc.xml中</h4><pre><code class="xml">&lt;!--6. 对JdbcTemplate进行IOC--&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;</code></pre><h4 id="4-配置持久层的实现类"><a href="#4-配置持久层的实现类" class="headerlink" title="4. 配置持久层的实现类"></a>4. 配置持久层的实现类</h4><p>对持久层的实现类进行IOC配置，以及注入JdbcTemplate对象</p><pre><code class="java">package com.atguigu.dao.impl;import com.atguigu.dao.MovieDao;import com.atguigu.pojo.Movie;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.util.List;/** * 包名:com.atguigu.dao.impl * * @author Leevi * 日期2021-09-06  10:03 */@Repositorypublic class MovieDaoImpl implements MovieDao &#123;    @Autowired    private JdbcTemplate jdbcTemplate;    @Override    public List&lt;Movie&gt; getAll() &#123;        return null;    &#125;    @Override    public Movie getMovieById(String movieId) &#123;        return null;    &#125;    @Override    public void saveMovie(Movie movie) &#123;    &#125;    @Override    public void updateMovie(Movie movie) &#123;    &#125;    @Override    public void removeMovieById(String movieId) &#123;    &#125;&#125;</code></pre><h4 id="5-编写测试持久层的各个方法"><a href="#5-编写测试持久层的各个方法" class="headerlink" title="5. 编写测试持久层的各个方法"></a>5. 编写测试持久层的各个方法</h4><h5 id="5-1-持久层的各个方法实现"><a href="#5-1-持久层的各个方法实现" class="headerlink" title="5.1 持久层的各个方法实现"></a>5.1 持久层的各个方法实现</h5><pre><code class="java">package com.atguigu.dao.impl;import com.atguigu.dao.MovieDao;import com.atguigu.pojo.Movie;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.util.List;/** * 包名:com.atguigu.dao.impl * * @author Leevi * 日期2021-09-06  10:03 */@Repositorypublic class MovieDaoImpl implements MovieDao &#123;    @Autowired    private JdbcTemplate jdbcTemplate;    @Override    public List&lt;Movie&gt; getAll() &#123;        String sql = &quot;select movie_id movieId, movie_name movieName,movie_price moviePrice from t_movie&quot;;        return jdbcTemplate.query(sql,new BeanPropertyRowMapper&lt;&gt;(Movie.class));    &#125;    @Override    public Movie getMovieById(String movieId) &#123;        String sql = &quot;select movie_id movieId, movie_name movieName,movie_price moviePrice from t_movie where movie_id=?&quot;;        return jdbcTemplate.queryForObject(sql,new BeanPropertyRowMapper&lt;&gt;(Movie.class),movieId);    &#125;    @Override    public void saveMovie(Movie movie) &#123;        String sql = &quot;insert into t_movie(movie_name,movie_price) values (?,?)&quot;;        jdbcTemplate.update(sql,movie.getMovieName(),movie.getMoviePrice());    &#125;    @Override    public void updateMovie(Movie movie) &#123;        String sql = &quot;update t_movie set movie_name=?,movie_price=? where movie_id=?&quot;;        jdbcTemplate.update(sql,movie.getMovieName(),movie.getMoviePrice(),movie.getMovieId());    &#125;    @Override    public void removeMovieById(String movieId) &#123;        String sql = &quot;delete from t_movie where movie_id=?&quot;;        jdbcTemplate.update(sql,movieId);    &#125;&#125;</code></pre><h5 id="5-2-持久层方法测试"><a href="#5-2-持久层方法测试" class="headerlink" title="5.2 持久层方法测试"></a>5.2 持久层方法测试</h5><pre><code class="java">package com.atguigu;import com.atguigu.dao.MovieDao;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * 包名:com.atguigu * * @author Leevi * 日期2021-09-06  10:22 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:springmvc.xml&quot;)public class TestDao &#123;    @Autowired    private MovieDao movieDao;    @Test    public void testGetAll()&#123;        System.out.println(movieDao.getAll());    &#125;&#125;</code></pre><h3 id="第四节-业务层的代码"><a href="#第四节-业务层的代码" class="headerlink" title="第四节 业务层的代码"></a>第四节 业务层的代码</h3><pre><code class="java">package com.atguigu.service.impl;import com.atguigu.dao.MovieDao;import com.atguigu.pojo.Movie;import com.atguigu.service.MovieService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * 包名:com.atguigu.service.impl * * @author Leevi * 日期2021-09-06  10:04 */@Servicepublic class MovieServiceImpl implements MovieService &#123;    @Autowired    private MovieDao movieDao;    @Override    public List&lt;Movie&gt; getAll() &#123;        return movieDao.getAll();    &#125;    @Override    public Movie getMovieById(String movieId) &#123;        return movieDao.getMovieById(movieId);    &#125;    @Override    public void saveMovie(Movie movie) &#123;        movieDao.saveMovie(movie);    &#125;    @Override    public void updateMovie(Movie movie) &#123;        movieDao.updateMovie(movie);    &#125;    @Override    public void removeMovieById(String movieId) &#123;        movieDao.removeMovieById(movieId);    &#125;&#125;</code></pre><h3 id="第五节-实现功能"><a href="#第五节-实现功能" class="headerlink" title="第五节 实现功能"></a>第五节 实现功能</h3><h4 id="1-显示首页"><a href="#1-显示首页" class="headerlink" title="1. 显示首页"></a>1. 显示首页</h4><h5 id="1-1-案例流程"><a href="#1-1-案例流程" class="headerlink" title="1.1 案例流程"></a>1.1 案例流程</h5><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_018.png"></p><h5 id="1-2-具体实现"><a href="#1-2-具体实现" class="headerlink" title="1.2 具体实现"></a>1.2 具体实现</h5><h6 id="1-2-1-配置-view-controller"><a href="#1-2-1-配置-view-controller" class="headerlink" title="1.2.1 配置 view-controller"></a>1.2.1 配置 view-controller</h6><pre><code class="xml">&lt;!--7. 使用view-controller访问首页--&gt;&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;portal&quot;/&gt;&lt;mvc:view-controller path=&quot;/index.html&quot; view-name=&quot;portal&quot;/&gt;</code></pre><h6 id="1-2-2-前端页面"><a href="#1-2-2-前端页面" class="headerlink" title="1.2.2 前端页面"></a>1.2.2 前端页面</h6><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_019.png"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;text-align: center&quot;&gt;    &lt;a th:href=&quot;@&#123;/movie/showList&#125;&quot;&gt;显示电影列表&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="2-在首页点击超链接显示全部数据"><a href="#2-在首页点击超链接显示全部数据" class="headerlink" title="2. 在首页点击超链接显示全部数据"></a>2. 在首页点击超链接显示全部数据</h4><h5 id="2-1-案例流程"><a href="#2-1-案例流程" class="headerlink" title="2.1 案例流程"></a>2.1 案例流程</h5><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_020.png"></p><h5 id="2-2-具体实现"><a href="#2-2-具体实现" class="headerlink" title="2.2 具体实现"></a>2.2 具体实现</h5><h6 id="2-2-1-处理器类和处理器方法"><a href="#2-2-1-处理器类和处理器方法" class="headerlink" title="2.2.1 处理器类和处理器方法"></a>2.2.1 处理器类和处理器方法</h6><pre><code class="java">package com.atguigu.handler;import com.atguigu.pojo.Movie;import com.atguigu.service.MovieService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;/** * 包名:com.atguigu.handler * * @author Leevi * 日期2021-09-06  10:31 */@Controller@RequestMapping(&quot;/movie&quot;)public class MovieHandler &#123;    @Autowired    private MovieService movieService;    @RequestMapping(&quot;/showList&quot;)    public String showList(Model model)&#123;        //1. 调用业务层的方法查询所有的movie        List&lt;Movie&gt; movieList = movieService.getAll();        //2. 将查询到的所有movie存储到请求域        model.addAttribute(&quot;movieList&quot;,movieList);        //3. 解析Thymeleaf模板显示所有movie        return &quot;list&quot;;    &#125;&#125;</code></pre><h6 id="2-2-2-前端页面"><a href="#2-2-2-前端页面" class="headerlink" title="2.2.2 前端页面"></a>2.2.2 前端页面</h6><ol><li>样式部分</li></ol><pre><code class="html">&lt;style type=&quot;text/css&quot;&gt;    table &#123;        border-collapse: collapse;        margin: 0px auto 0px auto;    &#125;    table th,td &#123;        border: 1px solid black;        text-align: center;    &#125;&lt;/style&gt;</code></pre><ol start="2"><li>数据展示部分</li></ol><pre><code class="html">&lt;table&gt;    &lt;thead&gt;        &lt;tr&gt;            &lt;th&gt;电影ID&lt;/th&gt;            &lt;th&gt;电影名称&lt;/th&gt;            &lt;th&gt;电影票价格&lt;/th&gt;            &lt;th&gt;删除&lt;/th&gt;            &lt;th&gt;更新&lt;/th&gt;        &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody th:if=&quot;$&#123;#lists.isEmpty(movieList)&#125;&quot;&gt;        &lt;tr&gt;            &lt;td colspan=&quot;5&quot;&gt;抱歉！没有查询到数据！&lt;/td&gt;        &lt;/tr&gt;    &lt;/tbody&gt;    &lt;tbody th:unless=&quot;$&#123;#lists.isEmpty(movieList)&#125;&quot;&gt;        &lt;tr th:each=&quot;movie : $&#123;movieList&#125;&quot;&gt;            &lt;td th:text=&quot;$&#123;movie.movieId&#125;&quot;&gt;电影ID&lt;/td&gt;            &lt;td th:text=&quot;$&#123;movie.movieName&#125;&quot;&gt;电影名称&lt;/td&gt;            &lt;td th:text=&quot;$&#123;movie.moviePrice&#125;&quot;&gt;电影票价格&lt;/td&gt;            &lt;td&gt;删除&lt;/td&gt;            &lt;td&gt;更新&lt;/td&gt;        &lt;/tr&gt;    &lt;/tbody&gt;    &lt;tfoot&gt;        &lt;tr&gt;            &lt;td colspan=&quot;5&quot;&gt;添加&lt;/td&gt;        &lt;/tr&gt;    &lt;/tfoot&gt;&lt;/table&gt;</code></pre><h4 id="3-删除一条数据"><a href="#3-删除一条数据" class="headerlink" title="3. 删除一条数据"></a>3. 删除一条数据</h4><h5 id="3-1-案例流程"><a href="#3-1-案例流程" class="headerlink" title="3.1 案例流程"></a>3.1 案例流程</h5><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_021.png"></p><h5 id="3-2-具体实现"><a href="#3-2-具体实现" class="headerlink" title="3.2 具体实现"></a>3.2 具体实现</h5><h6 id="3-2-1-修改数据展示时候的删除数据的超链接"><a href="#3-2-1-修改数据展示时候的删除数据的超链接" class="headerlink" title="3.2.1 修改数据展示时候的删除数据的超链接"></a>3.2.1 修改数据展示时候的删除数据的超链接</h6><pre><code class="html">&lt;a th:href=&quot;@&#123;/movie/removeMovie(movieId=$&#123;movie.movieId&#125;)&#125;&quot;&gt;删除&lt;/a&gt;</code></pre><h6 id="3-2-2-handler-方法"><a href="#3-2-2-handler-方法" class="headerlink" title="3.2.2 handler 方法"></a>3.2.2 handler 方法</h6><pre><code class="java">@RequestMapping(&quot;/removeMovie&quot;)public String removeMovie(@RequestParam(&quot;movieId&quot;) String movieId)&#123;    //调用业务层的方法根据id删除movie    movieService.removeMovieById(movieId);    //重新查询所有    return &quot;redirect:/movie/showList&quot;;&#125;</code></pre><h4 id="4-跳转到添加页面"><a href="#4-跳转到添加页面" class="headerlink" title="4. 跳转到添加页面"></a>4. 跳转到添加页面</h4><h5 id="4-1-案例流程"><a href="#4-1-案例流程" class="headerlink" title="4.1  案例流程"></a>4.1  案例流程</h5><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_022.png"></p><h5 id="4-2-具体实现"><a href="#4-2-具体实现" class="headerlink" title="4.2 具体实现"></a>4.2 具体实现</h5><h6 id="4-2-1-修改页面上添加数据的超链接"><a href="#4-2-1-修改页面上添加数据的超链接" class="headerlink" title="4.2.1 修改页面上添加数据的超链接"></a>4.2.1 修改页面上添加数据的超链接</h6><p>在<code>tfoot</code>标签的td中加入超链接标签 </p><pre><code class="html">&lt;td colspan=&quot;5&quot;&gt;&lt;a th:href=&quot;@&#123;/add.html&#125;&quot;&gt;添加&lt;/a&gt;&lt;/td&gt;</code></pre><h6 id="4-2-2-配置view-controller"><a href="#4-2-2-配置view-controller" class="headerlink" title="4.2.2 配置view-controller"></a>4.2.2 配置view-controller</h6><pre><code class="xml">&lt;!--8. 使用view-controller访问添加页面--&gt;&lt;mvc:view-controller path=&quot;/add.html&quot; view-name=&quot;add&quot;/&gt;</code></pre><h6 id="4-2-3-movie-add-html页面的表单"><a href="#4-2-3-movie-add-html页面的表单" class="headerlink" title="4.2.3 movie-add.html页面的表单"></a>4.2.3 movie-add.html页面的表单</h6><pre><code class="html">&lt;form th:action=&quot;@&#123;/movie/saveMovie&#125;&quot; method=&quot;post&quot;&gt;    电影名称：&lt;input type=&quot;text&quot; name=&quot;movieName&quot; /&gt;&lt;br/&gt;    电影票价格：&lt;input type=&quot;text&quot; name=&quot;moviePrice&quot; /&gt;&lt;br/&gt;    &lt;button type=&quot;submit&quot;&gt;保存&lt;/button&gt;&lt;/form&gt;</code></pre><h4 id="5-执行添加数据"><a href="#5-执行添加数据" class="headerlink" title="5. 执行添加数据"></a>5. 执行添加数据</h4><h5 id="5-1-案例流程"><a href="#5-1-案例流程" class="headerlink" title="5.1 案例流程"></a>5.1 案例流程</h5><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_023.png"></p><h5 id="5-2-具体实现"><a href="#5-2-具体实现" class="headerlink" title="5.2 具体实现"></a>5.2 具体实现</h5><h6 id="5-2-1-handler方法"><a href="#5-2-1-handler方法" class="headerlink" title="5.2.1 handler方法"></a>5.2.1 handler方法</h6><pre><code class="java">@RequestMapping(&quot;/saveMovie&quot;)public String addMovie(Movie movie)&#123;    //调用业务层的方法添加Movie    movieService.saveMovie(movie);    //重新查询所有    return &quot;redirect:/movie/showList&quot;;&#125;</code></pre><h4 id="6-跳转到更新表单回显数据"><a href="#6-跳转到更新表单回显数据" class="headerlink" title="6. 跳转到更新表单回显数据"></a>6. 跳转到更新表单回显数据</h4><h5 id="6-1-案例流程"><a href="#6-1-案例流程" class="headerlink" title="6.1 案例流程"></a>6.1 案例流程</h5><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_021.png"></p><h5 id="6-2-具体实现"><a href="#6-2-具体实现" class="headerlink" title="6.2 具体实现"></a>6.2 具体实现</h5><h6 id="6-2-1-修改页面更新数据的超链接"><a href="#6-2-1-修改页面更新数据的超链接" class="headerlink" title="6.2.1 修改页面更新数据的超链接"></a>6.2.1 修改页面更新数据的超链接</h6><pre><code class="html">&lt;a th:href=&quot;@&#123;/edit/movie/page(movieId=$&#123;movie.movieId&#125;)&#125;&quot;&gt;更新&lt;/a&gt;</code></pre><h6 id="6-2-2-handler方法"><a href="#6-2-2-handler方法" class="headerlink" title="6.2.2 handler方法"></a>6.2.2 handler方法</h6><pre><code class="java">@RequestMapping(&quot;/edit/movie/page&quot;)public String editMoviePage(            // 获取请求参数        @RequestParam(&quot;movieId&quot;) String movieId,                Model model) &#123;        // 1.根据id查询movie对象    Movie movie = movieService.getMovieById(movieId);            // 2.将movie对象存入模型    model.addAttribute(&quot;movie&quot;, movie);        // 3.返回逻辑视图    return &quot;movie-edit&quot;;&#125;</code></pre><h6 id="6-2-3-准备表单页面并回显"><a href="#6-2-3-准备表单页面并回显" class="headerlink" title="6.2.3 准备表单页面并回显"></a>6.2.3 准备表单页面并回显</h6><pre><code class="html">&lt;form th:action=&quot;@&#123;/update/movie&#125;&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;hidden&quot; name=&quot;movieId&quot; th:value=&quot;$&#123;movie.movieId&#125;&quot; /&gt;        电影名称：&lt;input type=&quot;text&quot; name=&quot;movieName&quot; th:value=&quot;$&#123;movie.movieName&#125;&quot; /&gt;&lt;br/&gt;    电影票价格：&lt;input type=&quot;text&quot; name=&quot;moviePrice&quot; th:value=&quot;$&#123;movie.moviePrice&#125;&quot; /&gt;&lt;br/&gt;        &lt;button type=&quot;submit&quot;&gt;更新&lt;/button&gt;    &lt;/form&gt;</code></pre><h4 id="7-执行更新"><a href="#7-执行更新" class="headerlink" title="7. 执行更新"></a>7. 执行更新</h4><h5 id="7-1-案例流程"><a href="#7-1-案例流程" class="headerlink" title="7.1 案例流程"></a>7.1 案例流程</h5><p><img src="http://www.slx.blue/2021/12/10/springMVC-01/tu_025.png"></p><h5 id="7-2-具体实现"><a href="#7-2-具体实现" class="headerlink" title="7.2 具体实现"></a>7.2 具体实现</h5><h6 id="7-2-1-handler方法"><a href="#7-2-1-handler方法" class="headerlink" title="7.2.1 handler方法"></a>7.2.1 handler方法</h6><pre><code class="java">@RequestMapping(&quot;/update/movie&quot;)public String updateMovie(Movie movie) &#123;        movieService.updateMovie(movie);        return &quot;redirect:/show/list&quot;;&#125;</code></pre><h3 id="第六节-案例环境总结"><a href="#第六节-案例环境总结" class="headerlink" title="第六节 案例环境总结"></a>第六节 案例环境总结</h3><h4 id="1-Spring和SpringMVC的环境"><a href="#1-Spring和SpringMVC的环境" class="headerlink" title="1. Spring和SpringMVC的环境"></a>1. Spring和SpringMVC的环境</h4><ol><li>依赖</li><li>web.xml中的配置:servlet、filter</li><li>springmvc配置文件:<ol><li>包扫描:为了解析组件注解(IOC和依赖注入的主键)</li><li>配置Thymeleaf的模板解析器:为了解析Thymeleaf模板</li><li>加载MVC注解驱动:为了能够找到Handler方法处理请求</li><li>处理静态资源</li><li><code>view-controller</code>:访问页面</li></ol></li><li>注解: <ol><li>IOC和依赖注入的注解: Controller、Service、Repository、AutoWired</li><li>SpringMVC的注解: RequestMapping(请求映射)、RequestParam(获取请求参数)</li></ol></li><li>日志</li></ol><h4 id="2-持久层环境"><a href="#2-持久层环境" class="headerlink" title="2. 持久层环境"></a>2. 持久层环境</h4><ol><li>依赖</li><li>springmvc配置文件中配置持久层:<ol><li>数据源</li><li>JdbcTemplate</li></ol></li><li>持久层实现类的方法中执行各个SQL语句</li></ol><h4 id="3-测试环境"><a href="#3-测试环境" class="headerlink" title="3. 测试环境"></a>3. 测试环境</h4><ol><li>依赖</li><li>Spring整合Junit</li><li>测试:需要测试业务层和持久层的代码</li></ol><h3 id="第七节-功能总结"><a href="#第七节-功能总结" class="headerlink" title="第七节 功能总结"></a>第七节 功能总结</h3><h4 id="1-单纯跳转页面的功能"><a href="#1-单纯跳转页面的功能" class="headerlink" title="1. 单纯跳转页面的功能"></a>1. 单纯跳转页面的功能</h4><p>例如:访问首页、访问add.html添加页面，使用<code>view-controller</code>标签实现</p><h4 id="2-查询功能"><a href="#2-查询功能" class="headerlink" title="2. 查询功能"></a>2. 查询功能</h4><p>例如:查询电影列表、更新前的数据回显。它们的具体步骤:</p><ol><li>需不需要带参数:就要看有没有查询条件</li><li>获取参数:</li><li>调用业务层的方法进行查询，获取到查询的数据</li><li>将查询到的数据存储到请求域</li><li>返回逻辑视图</li><li>在Thymeleaf页面获取请求域的数据，并展示</li></ol><h4 id="3-增删改功能"><a href="#3-增删改功能" class="headerlink" title="3. 增删改功能"></a>3. 增删改功能</h4><p>例如:添加电影、删除电影、更新电影。它们的具体步骤:</p><ol><li>肯定需要带参数:Thymeleaf的路径携带参数、以及表单携带参数</li><li>参数乱码:配置过滤器解决</li><li>获取参数:单个参数、POJO封装参数</li><li>调用业务层的方法进行增删改</li><li>重新查询所有: 使用<code>redirect</code>指令重定向访问<code>查询所有电影</code>的功能</li></ol>]]></content>
      
      
      <categories>
          
          <category> springMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-中介者模式</title>
      <link href="/2021/12/09/java-mediator/"/>
      <url>/2021/12/09/java-mediator/</url>
      
        <content type="html"><![CDATA[<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>传统案例</p><p>智能家居项目，智能家庭包括各种设备，闹钟，咖啡机，电视机，窗帘等</p><p>主人要看电视时，各个设备可以完成看电视的准备工作，比如流程为：闹铃响起，咖啡机开始做咖啡，窗帘自动落下，电视开始播放。</p><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>中介者模式(Mediator Pattern)，    用一个中介者对象来封装一系列的交互对象，中介者使各个对象不需要显式的相互作用，从而使其耦合松散，而且可以独立的改变他们之间的交互</li><li>中介者模式属于行为型模式，使代码易于维护</li><li>比如MVC模式，C(Controller控制器)是M(Model模型）和（View视图）的中介者，在前后端交互时气到了中间人的作用。</li></ol><p>原理类图</p><p><img src="http://www.slx.blue/2021/12/09/java-mediator/mediator01.png" alt="mediator"></p><p>类图说明</p><ol><li>Mediator就是抽象中介者，定义了同事对象到中介者对象的接口</li><li>Colleague是抽象同事类</li><li><code>ConcreteMediator</code> 具体的中介者对象，它需要知道所有的具体的同事类，即以一个集合来管理(<code>HashMap</code>)，并接受某个同事对象消息，完成相应的任务</li><li><code>ConcreteColleague</code> 具体的同事类，会有很多，每个同事只知道自己的行为，而不了解其他的行为(方法)，但是他们都依赖中介者对象。</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>实现类图：</p><p><img src="http://www.slx.blue/2021/12/09/java-mediator/mediator02.png" alt="mediator02"></p><p>代码：</p><pre><code class="java">//中介者抽象类public abstract class Mediator &#123;    //将给中介者对象，加入到集合中    public abstract void Register(String colleagueName, Colleague colleague);    //接收消息, 具体的同事对象发出    public abstract void GetMessage(int stateChange, String colleagueName);    public abstract void SendMessage();&#125;</code></pre><pre><code class="java">//同事抽象类public abstract class Colleague &#123;    private Mediator mediator;    public String name;    public Colleague(Mediator mediator, String name) &#123;        this.mediator = mediator;        this.name = name;    &#125;    public Mediator GetMediator() &#123;        return this.mediator;    &#125;    public abstract void SendMessage(int stateChange);&#125;</code></pre><pre><code class="java">//具体的中介者类public class ConcreteMediator extends Mediator &#123;    //集合，放入所有的同事对象    private HashMap&lt;String, Colleague&gt; colleagueMap;    private HashMap&lt;String, String&gt; interMap;    public ConcreteMediator() &#123;        colleagueMap = new HashMap&lt;String, Colleague&gt;();        interMap = new HashMap&lt;String, String&gt;();    &#125;    @Override    public void Register(String colleagueName, Colleague colleague) &#123;        colleagueMap.put(colleagueName, colleague);        if (colleague instanceof Alarm) &#123;            interMap.put(&quot;Alarm&quot;, colleagueName);        &#125; else if (colleague instanceof CoffeeMachine) &#123;            interMap.put(&quot;CoffeeMachine&quot;, colleagueName);        &#125; else if (colleague instanceof TV) &#123;            interMap.put(&quot;TV&quot;, colleagueName);        &#125; else if (colleague instanceof Curtains) &#123;            interMap.put(&quot;Curtains&quot;, colleagueName);        &#125;    &#125;    //具体中介者的核心方法    //1. 根据得到消息，完成对应任务    //2. 中介者在这个方法，协调各个具体的同事对象，完成任务    @Override    public void GetMessage(int stateChange, String colleagueName) &#123;        //处理闹钟发出的消息        if (colleagueMap.get(colleagueName) instanceof Alarm) &#123;            if (stateChange == 0) &#123;                ((CoffeeMachine) (colleagueMap.get(interMap                        .get(&quot;CoffeeMachine&quot;)))).StartCoffee();                ((TV) (colleagueMap.get(interMap.get(&quot;TV&quot;)))).StartTv();            &#125; else if (stateChange == 1) &#123;                ((TV) (colleagueMap.get(interMap.get(&quot;TV&quot;)))).StopTv();            &#125;        &#125; else if (colleagueMap.get(colleagueName) instanceof CoffeeMachine) &#123;            ((Curtains) (colleagueMap.get(interMap.get(&quot;Curtains&quot;))))                    .UpCurtains();        &#125; else if (colleagueMap.get(colleagueName) instanceof TV) &#123;//如果TV发现消息        &#125; else if (colleagueMap.get(colleagueName) instanceof Curtains) &#123;            //如果是以窗帘发出的消息，这里处理...        &#125;    &#125;    @Override    public void SendMessage() &#123;    &#125;&#125;</code></pre><pre><code class="java">//同事类//具体的同事类public class Alarm extends Colleague &#123;    //构造器    public Alarm(Mediator mediator, String name) &#123;        super(mediator, name);        //在创建Alarm 同事对象时，将自己放入到ConcreteMediator 对象中[集合]        mediator.Register(name, this);    &#125;    public void SendAlarm(int stateChange) &#123;        SendMessage(stateChange);    &#125;    @Override    public void SendMessage(int stateChange) &#123;        //调用的中介者对象的getMessage        this.GetMediator().GetMessage(stateChange, this.name);    &#125;&#125;//咖啡机public class CoffeeMachine extends Colleague &#123;    public CoffeeMachine(Mediator mediator, String name) &#123;        super(mediator, name);        mediator.Register(name, this);    &#125;    @Override    public void SendMessage(int stateChange) &#123;        this.GetMediator().GetMessage(stateChange, this.name);    &#125;    public void StartCoffee() &#123;        System.out.println(&quot;It&#39;s time to startcoffee!&quot;);    &#125;    public void FinishCoffee() &#123;        System.out.println(&quot;After 5 minutes!&quot;);        System.out.println(&quot;Coffee is ok!&quot;);        SendMessage(0);    &#125;&#125;//窗帘public class Curtains extends Colleague &#123;    public Curtains(Mediator mediator, String name) &#123;        super(mediator, name);        mediator.Register(name, this);    &#125;    @Override    public void SendMessage(int stateChange) &#123;        this.GetMediator().GetMessage(stateChange, this.name);    &#125;    public void UpCurtains() &#123;        System.out.println(&quot;I am holding Up Curtains!&quot;);    &#125;&#125;//TVpublic class TV extends Colleague &#123;    public TV(Mediator mediator, String name) &#123;        super(mediator, name);        mediator.Register(name, this);    &#125;    @Override    public void SendMessage(int stateChange) &#123;        this.GetMediator().GetMessage(stateChange, this.name);    &#125;    public void StartTv() &#123;        System.out.println(&quot;It&#39;s time to StartTv!&quot;);    &#125;    public void StopTv() &#123;        System.out.println(&quot;StopTv!&quot;);    &#125;&#125;</code></pre><pre><code class="java">//Clientpublic class ClientTest &#123;    public static void main(String[] args) &#123;        //创建一个中介者对象        Mediator mediator = new ConcreteMediator();                //创建Alarm 并且加入到  ConcreteMediator 对象的HashMap        Alarm alarm = new Alarm(mediator, &quot;alarm&quot;);                //创建了CoffeeMachine 对象，并  且加入到  ConcreteMediator 对象的HashMap        CoffeeMachine coffeeMachine = new CoffeeMachine(mediator, &quot;coffeeMachine&quot;);                //创建 Curtains , 并  且加入到  ConcreteMediator 对象的HashMap        Curtains curtains = new Curtains(mediator, &quot;curtains&quot;);        TV tV = new TV(mediator, &quot;TV&quot;);                //让闹钟发出消息        alarm.SendAlarm(0);        coffeeMachine.FinishCoffee();        alarm.SendAlarm(1);    &#125;&#125;</code></pre><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><blockquote><p><code>MVC</code>模式中 View 和 Controller 的关系就有点像 中介者模式 </p><p>View想要访问另一个View 就通过Controller调用各种Model ，条件判断 ，最终返回另一个View</p></blockquote><h4 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ol><li>多个类相互耦合，会形成网状结构，使用终结者模式将网状结构分离为星形结构，进行了解耦</li><li>减少了类间依赖，降低了耦合，符合了迪米特法则</li><li> 中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响</li><li>如果设计不当，中介者对象本身变得过于复杂，这点在实际使用的时候要注意，代码要谨慎写。</li></ol>]]></content>
      
      
      <categories>
          
          <category> designMode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-构建者模式</title>
      <link href="/2021/12/08/java-builder/"/>
      <url>/2021/12/08/java-builder/</url>
      
        <content type="html"><![CDATA[<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><ol><li>需求：需要建房子 这一过程为打桩 砌墙 封顶</li><li>房子有各种各种的 比如普通房 高楼 别墅 各种房子的过程虽然一样 但是要求不要相同</li><li>编写程序完成需求</li></ol><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><pre><code class="java">public abstract class AbstractHouse &#123;  //抽象房子类    public abstract void buildBasic();// 打地基    public abstract void buildWalls(); //砌墙    public abstract void roofed();//封顶    public void build()&#123; //造房子        buildBasic();        buildWalls();        roofed();    &#125;&#125;//普通房子类public class CommonHouse extends AbstractHouse &#123;    @Override    public void buildBasic() &#123;        System.out.println(&quot;给普通房子打地基&quot;);    &#125;    @Override    public void buildWalls() &#123;        System.out.println(&quot;给普通房子砌墙&quot;);    &#125;    @Override    public void roofed() &#123;        System.out.println(&quot;给普通房子封顶&quot;);    &#125;&#125;public class Client &#123;    public static void main(String[] args) &#123;        CommonHouse commonHouse = new CommonHouse();        commonHouse.build();    &#125;&#125;</code></pre><p><img src="http://www.slx.blue/2021/12/08/java-builder/TraditionalBuilder.jpg" alt="TraditionalBuilder"></p><ol><li><p>有点是比较好理解，简单易操作</p></li><li><p>设计的程序结构过于简单，没有设计缓存层对象，程序的扩展和维护不好,也就是说 这种设计方案把产品（房子）和创建产品的过程（建房子build方法）封装在一起 ，耦合性增强了</p></li><li><p>解决方案：将<strong>产品</strong>和<strong>产品建造过程</strong>解耦 =&gt; 建造者模式</p></li></ol><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>建造者模式(Builder Pattern)又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别） 使这个抽象过程的不同方法可以构造出不同表现(属性)的对象。</li><li>建造者模式是一步一步创建一个复杂的对象 ，他允许用户指定复杂的类型就可以构建他们，用户不需要知道具体构建细节。</li></ol><h4 id="建造者模式的四个角色"><a href="#建造者模式的四个角色" class="headerlink" title="建造者模式的四个角色"></a>建造者模式的四个角色</h4><ol><li>Product(产品角色) ：一个具体的产品对象</li><li>Builder(抽象建造者)：创建一个Product对象的各个部件的接口/抽象类</li><li><code>ConcreteBuilder</code>(具体建造者)实现接口，构建和装配各个部件</li><li>Director(指挥者)：构建一个Builder接口的对象，它主要是用于创建一个复杂的对象。主要有两个作用，一是：隔离客户与对象产生的过程，二是：复杂控制产品对象的生产过程</li></ol><p>产品：</p><pre><code class="java">//产品public class House &#123;//对应产品    private String base;    private String wall;    private String roofed;//对应getset方法&#125;</code></pre><p>抽象的建造者Builder:</p><pre><code class="java">public abstract class HouseBuilder &#123;    protected House house = new House(); //组合一个产品    //将建造的流程写好,抽象方法    public abstract void buildBasic();    public abstract void buildWalls();    public abstract void roofed();    //建造房子 建好后将房子返回    public House BuildHouse()&#123;        return house;    &#125;&#125;</code></pre><p>指挥者Director</p><pre><code class="java">//指挥者 这里去指定制作流程 返回房子public class HouseDirector &#123;    HouseBuilder houseBuilder = null;    //1.构造器传入  依赖    public HouseDirector(HouseBuilder houseBuilder) &#123;        this.houseBuilder = houseBuilder;    &#125;    //2.通过set方法传入 聚合    public void setHouseBuilder(HouseBuilder houseBuilder) &#123;        this.houseBuilder = houseBuilder;    &#125;    //如何处理建房流程，交给指挥者    public House constructorHouse()&#123;        houseBuilder.buildBasic();        houseBuilder.buildWalls();        houseBuilder.roofed();        return houseBuilder.BuildHouse();    &#125;&#125;</code></pre><p>两个产品类：</p><pre><code class="java">//普通房子public class CommonHouse extends HouseBuilder&#123;    @Override    public void buildBasic() &#123;        System.out.println(&quot;普通房子打地基五米&quot;);    &#125;    @Override    public void buildWalls() &#123;        System.out.println(&quot;普通房子砌墙10cm&quot;);    &#125;    @Override    public void roofed() &#123;        System.out.println(&quot;普通房子封顶&quot;);    &#125;&#125;//高楼public class HighBuilding extends HouseBuilder&#123;    @Override    public void buildBasic() &#123;        System.out.println(&quot;高楼打地基50&quot;);    &#125;    @Override    public void buildWalls() &#123;        System.out.println(&quot;高楼砌墙20cm&quot;);    &#125;    @Override    public void roofed() &#123;        System.out.println(&quot;高楼透明屋顶&quot;);    &#125;&#125;</code></pre><p>实现：</p><pre><code class="java">public class Client &#123;    public static void main(String[] args) &#123;        //盖普通房子        CommonHouse commonHouse = new CommonHouse();        //准备创建房子的指挥者        HouseDirector houseDirector = new HouseDirector(commonHouse);        //完成盖房子，返回产品（房子）        House house = houseDirector.constructorHouse();        //盖高楼        HighBuilding highBuilding = new HighBuilding();        houseDirector.setHouseBuilder(highBuilding);        House house1 = houseDirector.constructorHouse();    &#125;&#125;</code></pre><p><img src="http://www.slx.blue/2021/12/08/java-builder/improveBuilder.jpg" alt="improveBuilder"></p><p><code>JDK</code>中用到的建造者模式 <code>java.lang.StringBuilder</code></p><ul><li><code>Appendable</code>接口定义了多个append方法（抽象方法） ， 即<code>Appendable</code>为建造者，定义了抽象方法</li><li><code>AbstractStringBuilder</code>已经是建造者，只是不能实例化</li><li><code>StringBuilder</code>即充当了指挥者角色，同时同时充当了具体的建造者。建造方法的实现是由<code>AbstractStringBuilder</code>完成，而<code>StringBuilder</code>继承了<code>AbstractStringBuilder</code></li></ul><p><strong>建造者模式的注意事项和细节</strong></p><ol><li><p>客户端（使用程序）不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p></li><li><p>建造者模式所创建的产品一般具有较多相同的共同点，其组成部分相似，如果产品之间的差异性很大，则不是和使用建造者模式，因此其使用范围收到一定的限制。</p></li><li><p>如果产品内部变化复杂，可能会导致需要定义很多具体建造者来实现这种变化，导致系统变得庞大，因此要考虑是否适合选择建造者模式。</p></li><li><p>每一个具体的建造者都相对独立，而与其他的具体建造者无关，因此可以很方便的替换具体建造者或者增加新的具体建造者，用户使用不同的建造者即可得到不同的产品对象。</p></li><li><p>可以更加精细的控制产品的建造过程，将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建流程。</p></li><li><p>增加新的具体创建者无需修改原油类库的代码，指挥者针对抽象建造者类变成，系统扩展方便，符合开闭原则。</p><blockquote><p><strong>抽象工厂模式和建造者模式</strong></p></blockquote><p>抽象工厂模式实现对产品家族的创建，一个产品家族是一系列产品，具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产。而建造者模式则是按照指定的蓝图构建产品，它的主要目的是通过组装零配件而生产一个新的产品。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> designMode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-原型模式</title>
      <link href="/2021/12/08/java-prototype/"/>
      <url>/2021/12/08/java-prototype/</url>
      
        <content type="html"><![CDATA[<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ul><li>现有一只羊，姓名为tom，年龄为1：颜色为白色，请编写程序创建和tom羊属性完全相同的10只羊</li></ul><pre><code class="java">//传统方式public class Sheep &#123;    private String name;    private int age;    private String color;    //生成构造和getset方法以及toString等等...&#125; public static void main(String[] args) &#123;     Sheep sheep = new Sheep(&quot;tom&quot;,1,&quot;白色&quot;);     //克隆十次...     new Sheep(sheep.getName(),sheep.getAge(),sheep.getColor()); &#125;</code></pre><p>传统方式的优缺点</p><ol><li>有点是比较好理解，简单易操作</li><li>在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂，效率较低</li><li>总是需要重新初始化对象，而不是动态的获得对象运行时的状态，不够灵活</li></ol><p>思路：<code>java</code>中Object类是所有类的父类，Object提供了一个clone方法，可以将一个<code>java</code>对象复制一份，但是需要实现clone的<code>java</code>类需要实现一个接口<code>Clonealbe</code>，该接口表示该类能够复制且具有复制的能力=&gt;原型模式</p><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象</li><li>原型模式是一种创建型设计模式，允许一个对象在创建另外一个可定制的对象，无需知道如何创建的细节</li><li>工作的原理：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝他们来实施创建，即对象.clone() </li><li>形象理解：猴子拔出猴毛变成其他猴子</li></ol><p>改进：</p><pre><code class="java">public class Sheep implements Cloneable&#123;    private String name;    private int age;    private String color;     //生成构造和getset方法以及toString等等...    //克隆该实例 使用默认的clone方法来完成    @Override    protected Object clone() throws CloneNotSupportedException &#123;        Sheep sheep = null;        Sheep clone = (Sheep) super.clone();        return clone;    &#125;&#125;public class Client &#123;    public static void main(String[] args)  &#123;        Sheep sheep = new Sheep(&quot;tom&quot;,1,&quot;包塞&quot;);        try &#123;            //克隆十次            Sheep clone1 = (Sheep) sheep.clone();            Sheep clone2 = (Sheep) sheep.clone();            //....        &#125; catch (CloneNotSupportedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><blockquote><p>原型模式在Spring框架中源码分析</p></blockquote><pre><code class="java"> public void testImport()&#123;     Object bean1 = applicationContext.getBean(xxx);          Object bean2 = applicationContext.getBean(xxx);       //如果是scope = prototype 多例 就用到了原型模式     //getbean每次都是通过clone生成的对象  &#125;</code></pre><p>原型模式完成对象的创建，如果被克隆的对象中有对象属性，那么克隆的时候并不会被克隆</p><h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p>浅拷贝：</p><ol><li>对于数据类型是基本类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性复制一份给新的对象</li><li>对于数据类型是应用数据类型的成员变量，比如成员变量是某个数组，某个类的对象等，那么浅拷贝会进行引用传递，也就是只将该成员变量的引用值(内存地址)复制一份给新的对象。实际上两个对象都指向同一个实例，所以这种情况下 一个对象中修改该成员变量会影响到另一个对象的该成员变量值</li><li>比如默认开启的对象克隆就是浅拷贝</li><li><code> Sheep clone2 = (Sheep) sheep.clone();</code></li></ol><p>深拷贝：</p><ol><li>复制对象的<strong>所有</strong>基本数据类型的成员变量值 </li><li>为所有应用数据类型的成员变量<strong>申请存储空间</strong>，并复制每个应用数据类型成员变量所引用的对象，直到该对象可达的所有对象，<strong>也就是说，对象进行深拷贝要对整个对象(包括引用对象)进行拷贝</strong></li><li>深拷贝实现方式1：<strong>重写clone</strong>方法来实现深拷贝</li><li>深拷贝实现方式2：通过<strong>序列化</strong>实现深拷贝  </li></ol><h4 id="小案例"><a href="#小案例" class="headerlink" title="小案例"></a>小案例</h4><pre><code class="java">//克隆引用对象public class DeepCloneTarget implements Serializable,Cloneable &#123;    private static final long serialVersionUID = 1L;    private String cloneName;    private String cloneClass;    public DeepCloneTarget(String cloneName, String cloneClass) &#123;        this.cloneName = cloneName;        this.cloneClass = cloneClass;    &#125;    //因为该类的属性都是string 所以直接用默认clone方式即可    @Override    protected Object clone() throws CloneNotSupportedException &#123;        return super.clone();    &#125;&#125;</code></pre><pre><code class="java">//要克隆的对象 实现了两种克隆方式public class DeepProtoType implements Serializable,Cloneable &#123;    public String name;//String 属性    public DeepCloneTarget deepCloneTarget;//引用类型 //属性是对象 默认克隆会浅拷贝    //深拷贝-1 使用重写clone方法    @Override    protected Object clone() throws CloneNotSupportedException &#123;        Object deep = null;        //这里完成对基本数据类型(属性)和字符串的clone        deep = super.clone();        //对引用类型的属性进行单独处理        DeepProtoType deepProtoType = (DeepProtoType) deep;        deepProtoType.deepCloneTarget = (DeepCloneTarget) deepCloneTarget.clone();        return deepProtoType;    &#125;    //深拷贝2 使用对象的序列化实现(推荐)    public Object deepClone()&#123;        //创建流对象        ByteArrayOutputStream bos = null;        ObjectOutputStream oos = null;        ByteArrayInputStream bis = null;        ObjectInputStream ois = null;        try &#123;            bos = new ByteArrayOutputStream();            oos = new ObjectOutputStream(bos);            oos.writeObject(this); //当前这个对象以对象流的方式输出 序列化            //再反序列化 读出来 相当于存了值 成功克隆了一个新的对象            bis = new ByteArrayInputStream(bos.toByteArray());            ois = new ObjectInputStream(bis);            DeepProtoType copy = (DeepProtoType) ois.readObject();            return copy;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return null;        &#125;finally &#123;            try &#123;                bos.close();                oos.close();                bis.close();                ois.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><pre><code class="java">//测试public class Client &#123;    public static void main(String[] args) throws CloneNotSupportedException &#123;        DeepProtoType dp = new DeepProtoType();        dp.name = &quot;小水牛&quot;;        dp.deepCloneTarget = new DeepCloneTarget(&quot;大水牛&quot;, &quot;敲能喝&quot;);        //方式一 完成深拷贝       /*        DeepProtoType clone = (DeepProtoType) dp.clone();        System.out.println(dp.hashCode());//460141958        System.out.println(clone.hashCode());//1163157884       */       //方式二 完成深拷贝        DeepProtoType p = (DeepProtoType) dp.deepClone();        System.out.println(&quot;克隆原型：&quot;+dp.name + &quot;--&quot; + dp.deepCloneTarget.hashCode());        //克隆原型：小水牛--325040804        System.out.println(&quot;克隆的对象&quot;+p.name + &quot;--&quot; + p.deepCloneTarget.hashCode());        //克隆的对象小水牛--2065951873    &#125;&#125;//推荐使用的是通过序列化实现深拷贝，这样无论原型如何修改都不会影响克隆 因为直接通过流来反序列化创建</code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率</li><li>不用重新初始化对象，而是动态的获得对象运行时的状态</li><li>如果原型对象发生变化（增加或减少属性），其他克隆对象也会发生相应的变化，无需修改代码</li><li>在实现深克隆的时候 可能需要比较复杂的代码</li><li>缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但是对已有的类来说进行改造的时候 需要修改它的源代码，违背了<code>OCP</code>（开闭原则）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> designMode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-观察者模式</title>
      <link href="/2021/12/08/java-observer/"/>
      <url>/2021/12/08/java-observer/</url>
      
        <content type="html"><![CDATA[<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p> 天气预报需求：</p><ol><li>气象站可以将每天测量到的温度，湿度，气压等一公告的形式发布出去，比如发布到自己的网站或者第三方</li><li>设计开放性API 便于其他第三方接入气象站获取数据</li><li>每次更新的时候 就要实时通知其他的第三方更新。</li></ol><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>观察者模式，对象之间多对一依赖的一种设计方案</li></ol><p><img src="http://www.slx.blue/2021/12/08/java-observer/observe01.png" alt="observe01"></p><h4 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h4><pre><code class="java">//观察者接口，有观察者来实现public interface Observer &#123;    public void update(float temperature, float pressure, float humidity);&#125;</code></pre><pre><code class="java">//接口, 让WeatherData 来实现public interface Subject &#123;    public void registerObserver(Observer o);    public void removeObserver(Observer o);    public void notifyObservers();&#125;</code></pre><pre><code class="java">/** * 相当于气象站本身，包含了一个第三方的集合，可以增加和移除第三方接口，并且能够实时通知第三方更新 * 类是核心 * 1. 包含最新的天气情况信息  * 2. 含有 观察者集合，使用ArrayList管理 * 3. 当数据有更新时，就主动的调用   ArrayList, 通知所有的（接入方）就看到最新的信息 * @author Administrator * */public class WeatherData implements Subject &#123;    //温度 气压 湿度    private float temperatrue;    private float pressure;    private float humidity;    //观察者集合    private ArrayList&lt;Observer&gt; observers;        //加入新的第三方    public WeatherData() &#123;        observers = new ArrayList&lt;Observer&gt;();    &#125;    public float getTemperature() &#123;        return temperatrue;    &#125;    public float getPressure() &#123;        return pressure;    &#125;    public float getHumidity() &#123;        return humidity;    &#125;    public void dataChange() &#123;        //调用 接入方的 update        notifyObservers(); //通知所有观察者更新    &#125;    //当数据有更新时，就调用 setData    public void setData(float temperature, float pressure, float humidity) &#123;        this.temperatrue = temperature;        this.pressure = pressure;        this.humidity = humidity;        //调用dataChange， 将最新的信息 推送给 接入方 currentConditions        dataChange();    &#125;    //注册一个观察者    @Override    public void registerObserver(Observer o) &#123;        observers.add(o);    &#125;    //移除一个观察者    @Override    public void removeObserver(Observer o) &#123;        if(observers.contains(o)) &#123;            observers.remove(o);        &#125;    &#125;    //遍历所有的观察者，并通知更新    @Override    public void notifyObservers() &#123;        for(int i = 0; i &lt; observers.size(); i++) &#123;            observers.get(i).update(this.temperatrue, this.pressure, this.humidity);        &#125;    &#125;&#125;</code></pre><pre><code class="java">//第三方网站 实现观察者接口 实现update方法public class CurrentConditions implements Observer &#123;    // 温度，气压，湿度    private float temperature;    private float pressure;    private float humidity;    // 更新 天气情况，是由 WeatherData 来调用，我使用推送模式    public void update(float temperature, float pressure, float humidity) &#123;        this.temperature = temperature;        this.pressure = pressure;        this.humidity = humidity;        display();    &#125;    // 显示    public void display() &#123;        System.out.println(&quot;***Today mTemperature: &quot; + temperature + &quot;***&quot;);        System.out.println(&quot;***Today mPressure: &quot; + pressure + &quot;***&quot;);        System.out.println(&quot;***Today mHumidity: &quot; + humidity + &quot;***&quot;);    &#125;&#125;//新的第三方 只需要实现Observe接口的update方法，就能够拿到数据对自己进行处理</code></pre><pre><code class="java">public class Client &#123;//客户端    public static void main(String[] args) &#123;        //创建一个WeatherData        WeatherData weatherData = new WeatherData();                //创建观察者        CurrentConditions currentConditions = new CurrentConditions();        BaiduSite baiduSite = new BaiduSite();                //注册到weatherData        weatherData.registerObserver(currentConditions);        weatherData.registerObserver(baiduSite);                //测试        System.out.println(&quot;通知各个注册的观察者, 看看信息&quot;);        weatherData.setData(10f, 100f, 30.3f);                        weatherData.removeObserver(currentConditions);        //测试        System.out.println();        System.out.println(&quot;通知各个注册的观察者, 看看信息&quot;);        weatherData.setData(10f, 100f, 30.3f);    &#125;&#125;</code></pre><h4 id="观察者模式的好处"><a href="#观察者模式的好处" class="headerlink" title="观察者模式的好处"></a>观察者模式的好处</h4><ul><li>观察者模式设计后，会以集合的方式来管理用户(Observer)，包括注册，移除和通知。</li><li>这样，我们增加观察者(可以理解为一个新的公告板) 就不需要去修改核心类<code>WeatherData</code>，不会修改代码，遵守了<code>OPC</code>原则。</li></ul><p>源码分析</p><blockquote><p>JDK中的Observable类就使用了观察者模式</p><p>Spring事件驱动模型就是观察者模式的一个经典应用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> designMode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-day04-transaction</title>
      <link href="/2021/12/08/spring-day04-Transactiona/"/>
      <url>/2021/12/08/spring-day04-Transactiona/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-day04"><a href="#spring-day04" class="headerlink" title="spring-day04"></a>spring-day04</h1><h2 id="第一章-声明式事务"><a href="#第一章-声明式事务" class="headerlink" title="第一章 声明式事务"></a>第一章 声明式事务</h2><h3 id="第一节-JDBCTemplate"><a href="#第一节-JDBCTemplate" class="headerlink" title="第一节 JDBCTemplate"></a>第一节 JDBCTemplate</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><p>为了在特定领域帮助我们简化代码，Spring 封装了很多 『Template』形式的模板类。例如：RedisTemplate、RestTemplate 等等，包括我们今天要学习的 JDBCTemplate。 </p><h4 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h4><h5 id="2-1-加入依赖"><a href="#2-1-加入依赖" class="headerlink" title="2.1 加入依赖"></a>2.1 加入依赖</h5><pre><code class="xml">&lt;dependencies&gt;    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Spring 持久化层支持jar包 --&gt;    &lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个jar包 --&gt;    &lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Spring 测试相关 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- junit测试 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- MySQL驱动 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 数据源 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.0.31&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--引入LomBok的依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;version&gt;1.18.8&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h5 id="2-2-数据源的属性文件jdbc-properties"><a href="#2-2-数据源的属性文件jdbc-properties" class="headerlink" title="2.2 数据源的属性文件jdbc.properties"></a>2.2 数据源的属性文件jdbc.properties</h5><pre><code class="properties">atguigu.url=jdbc:mysql://localhost:3306/mybatis-exampleatguigu.driver=com.mysql.jdbc.Driveratguigu.username=rootatguigu.password=123456</code></pre><h5 id="2-3-Spring-配置文件"><a href="#2-3-Spring-配置文件" class="headerlink" title="2.3 Spring 配置文件"></a>2.3 Spring 配置文件</h5><h6 id="2-3-1-配置数据源"><a href="#2-3-1-配置数据源" class="headerlink" title="2.3.1 配置数据源"></a>2.3.1 配置数据源</h6><pre><code class="xml">&lt;!--引入jdbc.properties属性文件--&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;&lt;!--配置数据源--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;$&#123;atguigu.username&#125;&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;$&#123;atguigu.password&#125;&quot;/&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;atguigu.driver&#125;&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;$&#123;atguigu.url&#125;&quot;/&gt;&lt;/bean&gt;</code></pre><h6 id="2-3-2-配置-JDBCTemplate"><a href="#2-3-2-配置-JDBCTemplate" class="headerlink" title="2.3.2 配置 JDBCTemplate"></a>2.3.2 配置 JDBCTemplate</h6><pre><code class="xml">&lt;!--对JdbcTemplate进行IOC--&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;    &lt;!--注入数据源对象--&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;</code></pre><h5 id="2-4-在测试类装配-JdbcTemplate"><a href="#2-4-在测试类装配-JdbcTemplate" class="headerlink" title="2.4 在测试类装配 JdbcTemplate"></a>2.4 在测试类装配 JdbcTemplate</h5><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:spring-application.xml&quot;)public class TestJdbcTemplate &#123;    @Autowired    private JdbcTemplate jdbcTemplate;&#125;    </code></pre><h5 id="2-5-JDBCTemplate的基本用法"><a href="#2-5-JDBCTemplate的基本用法" class="headerlink" title="2.5 JDBCTemplate的基本用法"></a>2.5 JDBCTemplate的基本用法</h5><h6 id="2-5-1-增删改操作"><a href="#2-5-1-增删改操作" class="headerlink" title="2.5.1 增删改操作"></a>2.5.1 增删改操作</h6><pre><code class="java">@Testpublic void testInsert()&#123;    String sql = &quot;insert into t_emp (emp_name,emp_salary) values (?,?)&quot;;    jdbcTemplate.update(sql,&quot;aobama&quot;,3000d);&#125;@Testpublic void testUpdate()&#123;    String sql = &quot;update t_emp set emp_name=?,emp_salary=? where emp_id=?&quot;;    jdbcTemplate.update(sql,&quot;aolafu&quot;,6000d,1);&#125;</code></pre><h6 id="2-5-2-查询：返回单个简单类型"><a href="#2-5-2-查询：返回单个简单类型" class="headerlink" title="2.5.2 查询：返回单个简单类型"></a>2.5.2 查询：返回单个简单类型</h6><pre><code class="java">@Testpublic void testSelectCount()&#123;    //查询员工的个数    String sql = &quot;select count(emp_id) from t_emp&quot;;    Long count = jdbcTemplate.queryForObject(sql, Long.class);    System.out.println(count);&#125;</code></pre><h6 id="2-5-3-查询：返回实体类类型"><a href="#2-5-3-查询：返回实体类类型" class="headerlink" title="2.5.3 查询：返回实体类类型"></a>2.5.3 查询：返回实体类类型</h6><ol><li>封装实体类类型</li></ol><pre><code class="java">package com.atguigu.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Employee &#123;    private Integer empId;    private String empName;    private Double empSalary;&#125;</code></pre><ol start="2"><li>借助 RowMapper 完成查询</li></ol><pre><code class="java">@Testpublic void testSelectOnRowToBean()&#123;    //查询某个员工信息封装到Employee对象中    String sql = &quot;select emp_id empId,emp_name empName, emp_salary empSalary from t_emp where emp_id=?&quot;;    Employee employee = jdbcTemplate.queryForObject(sql,new BeanPropertyRowMapper&lt;&gt;(Employee.class),1);    System.out.println(employee);&#125;@Testpublic void testSelectRowsToBeanList()&#123;    //查询多个员工信息，封装到List&lt;Employee&gt;中    String sql = &quot;select emp_id empId,emp_name empName, emp_salary empSalary from t_emp&quot;;    List&lt;Employee&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Employee.class));    System.out.println(list);&#125;</code></pre><h3 id="第二节-声明式事务的概述"><a href="#第二节-声明式事务的概述" class="headerlink" title="第二节 声明式事务的概述"></a>第二节 声明式事务的概述</h3><h4 id="1-编程式事务"><a href="#1-编程式事务" class="headerlink" title="1. 编程式事务"></a>1. 编程式事务</h4><p>事务功能的相关操作全部通过自己编写代码来实现： </p><pre><code class="java">Connection conn = ...;    try &#123;        // 开启事务：关闭事务的自动提交    conn.setAutoCommit(false);    // 核心操作        // 提交事务    conn.commit();    &#125;catch(Exception e)&#123;        // 回滚事务    conn.rollBack();    &#125;finally&#123;    //将连接的autoCommit还原成true    conn.setAutoCommit(true);    // 释放数据库连接    conn.close();&#125;</code></pre><p>编程式的实现方式存在缺陷：</p><ul><li>细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。</li><li>代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。</li></ul><h4 id="2-声明式事务"><a href="#2-声明式事务" class="headerlink" title="2. 声明式事务"></a>2. 声明式事务</h4><p>既然事务控制的代码有规律可循，代码的结构基本是确定的，所以框架就可以将固定模式的代码抽取出来，进行相关的封装。</p><p>封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。</p><ul><li>好处1：提高开发效率</li><li>好处2：消除了冗余的代码</li><li>好处3：框架会综合考虑相关领域中在实际开发环境下有可能遇到的各种问题，进行了健壮性、性能等各个方面的优化</li></ul><p>所以，我们可以总结下面两个概念：</p><ul><li><strong>编程式</strong>：<strong>自己写代码</strong>实现功能</li><li><strong>声明式</strong>：通过<strong>配置</strong>让<strong>框架</strong>实现功能</li></ul><h4 id="3-事务管理器"><a href="#3-事务管理器" class="headerlink" title="3. 事务管理器"></a>3. 事务管理器</h4><p>Spring中的声明式事务是通过事务管理器来进行事务管理的，所以在Spring中定义了事务管理器的顶级接口，针对各种不同的持久层框架，又定义了不同的事务管理器类来进行事务管理</p><h5 id="3-1-顶级接口"><a href="#3-1-顶级接口" class="headerlink" title="3.1 顶级接口"></a>3.1 顶级接口</h5><h6 id="3-1-1-Spring-5-2以前"><a href="#3-1-1-Spring-5-2以前" class="headerlink" title="3.1.1 Spring 5.2以前"></a>3.1.1 Spring 5.2以前</h6><pre><code class="java">public interface PlatformTransactionManager &#123;    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;    void commit(TransactionStatus status) throws TransactionException;    void rollback(TransactionStatus status) throws TransactionException;&#125;</code></pre><h6 id="3-1-2-从-Spring-5-2开始"><a href="#3-1-2-从-Spring-5-2开始" class="headerlink" title="3.1.2 从 Spring 5.2开始"></a>3.1.2 从 Spring 5.2开始</h6><p>PlatformTransactionManager 接口本身没有变化，它继承了 TransactionManager </p><pre><code class="java">public interface TransactionManager &#123;    &#125;</code></pre><blockquote><p>TransactionManager接口中什么都没有，但是它还是有存在的意义——定义一个技术体系。</p></blockquote><h5 id="3-2-事务管理器的体系结构"><a href="#3-2-事务管理器的体系结构" class="headerlink" title="3.2 事务管理器的体系结构"></a>3.2 事务管理器的体系结构</h5><p><img src="http://www.slx.blue/2021/12/08/spring-day04-Transactiona/tu_021.png"></p><p>我们现在要使用的事务管理器是org.springframework.jdbc.datasource.<strong>DataSourceTransactionManager</strong>，将来整合 Mybatis 用的也是这个类。</p><p>DataSourceTransactionManager类中的主要方法：</p><ul><li>doBegin()：开启事务</li><li>doSuspend()：挂起事务(暂停事务)</li><li>doResume()：恢复挂起的事务</li><li>doCommit()：提交事务</li><li>doRollback()：回滚事务</li></ul><blockquote><p>如果持久层使用Hibernate框架的话，则需要使用HibernateTransactionManager</p></blockquote><h3 id="第三节-基于注解的声明式事务"><a href="#第三节-基于注解的声明式事务" class="headerlink" title="第三节 基于注解的声明式事务"></a>第三节 基于注解的声明式事务</h3><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h4><h5 id="1-1-引入依赖"><a href="#1-1-引入依赖" class="headerlink" title="1.1 引入依赖"></a>1.1 引入依赖</h5><pre><code class="xml">&lt;dependencies&gt;    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Spring 持久化层支持jar包 --&gt;    &lt;!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个jar包 --&gt;    &lt;!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Spring 测试相关 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- junit测试 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- MySQL驱动 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 数据源 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.0.31&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--引入LomBok的依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;version&gt;1.18.8&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h5 id="1-2-数据源的属性文件"><a href="#1-2-数据源的属性文件" class="headerlink" title="1.2 数据源的属性文件"></a>1.2 数据源的属性文件</h5><pre><code class="properties">atguigu.url=jdbc:mysql://localhost:3306/mybatis-exampleatguigu.driver=com.mysql.jdbc.Driveratguigu.username=rootatguigu.password=123456</code></pre><h5 id="1-3-Spring-配置文件"><a href="#1-3-Spring-配置文件" class="headerlink" title="1.3 Spring 配置文件"></a>1.3 Spring 配置文件</h5><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/context                           https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!--包扫描--&gt;    &lt;context:component-scan base-package=&quot;com.atguigu&quot;/&gt;    &lt;!--引入jdbc.properties属性文件--&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;    &lt;!--配置数据源--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;        &lt;property name=&quot;username&quot; value=&quot;$&#123;atguigu.username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;atguigu.password&#125;&quot;/&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;atguigu.driver&#125;&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;$&#123;atguigu.url&#125;&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置JdbcTemplate的IOC--&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h5 id="1-4-数据建模"><a href="#1-4-数据建模" class="headerlink" title="1.4 数据建模"></a>1.4 数据建模</h5><h6 id="1-4-1-物理建模"><a href="#1-4-1-物理建模" class="headerlink" title="1.4.1 物理建模"></a>1.4.1 物理建模</h6><pre><code class="mysql">CREATE TABLE t_account(    account_id INT PRIMARY KEY AUTO_INCREMENT,    account_name VARCHAR(20),    money DOUBLE);INSERT INTO t_account VALUES (NULL,&#39;zs&#39;,1000);INSERT INTO t_account VALUES (NULL,&#39;ls&#39;,1000);</code></pre><h6 id="1-4-2-逻辑建模"><a href="#1-4-2-逻辑建模" class="headerlink" title="1.4.2 逻辑建模"></a>1.4.2 逻辑建模</h6><pre><code class="java">@Data@AllArgsConstructor@NoArgsConstructorpublic class Account &#123;    private Integer accountId;    private String accountName;    private Double money;&#125;</code></pre><h5 id="1-5-创建持久层组件"><a href="#1-5-创建持久层组件" class="headerlink" title="1.5 创建持久层组件"></a>1.5 创建持久层组件</h5><h6 id="1-5-1-AccountDao接口"><a href="#1-5-1-AccountDao接口" class="headerlink" title="1.5.1 AccountDao接口"></a>1.5.1 AccountDao接口</h6><pre><code class="java">package com.atguigu.dao;public interface AccountDao &#123;    /**     * 根据账户的id修改账户的金额     * @param accountId     * @param money     */    void updateAccountMoney(Integer accountId,Double money);&#125;</code></pre><h6 id="1-5-2-AccountDaoImpl实现类"><a href="#1-5-2-AccountDaoImpl实现类" class="headerlink" title="1.5.2 AccountDaoImpl实现类"></a>1.5.2 AccountDaoImpl实现类</h6><pre><code class="java">package com.atguigu.dao.impl;import com.atguigu.dao.AccountDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;@Repositorypublic class AccountDaoImpl implements AccountDao &#123;    @Autowired    private JdbcTemplate jdbcTemplate;    @Override    public void updateAccountMoney(Integer accountId, Double money) &#123;        String sql = &quot;update t_account set money=money+? where account_id=?&quot;;        jdbcTemplate.update(sql,money,accountId);    &#125;&#125;</code></pre><h5 id="1-6-创建业务层组件"><a href="#1-6-创建业务层组件" class="headerlink" title="1.6 创建业务层组件"></a>1.6 创建业务层组件</h5><h6 id="1-6-1-AccountService接口"><a href="#1-6-1-AccountService接口" class="headerlink" title="1.6.1 AccountService接口"></a>1.6.1 AccountService接口</h6><pre><code class="java">package com.atguigu.service;public interface AccountService &#123;    /**     * 转账方法     * @param fromId 转出账户的id     * @param toId 转入账户的id     * @param money 转账金额     */    void transfer(Integer fromId,Integer toId,Double money);&#125;</code></pre><h6 id="1-6-2-AccountServiceImpl实现类"><a href="#1-6-2-AccountServiceImpl实现类" class="headerlink" title="1.6.2 AccountServiceImpl实现类"></a>1.6.2 AccountServiceImpl实现类</h6><pre><code class="java">package com.atguigu.service.impl;import com.atguigu.dao.AccountDao;import com.atguigu.service.AccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class AccountServiceImpl implements AccountService &#123;    @Autowired    private AccountDao accountDao;    @Override    public void transfer(Integer fromId, Integer toId, Double money) &#123;        //1. 转出账户扣款        accountDao.updateAccountMoney(fromId,-money);        int num = 10/0;        //2. 转入账户收款        accountDao.updateAccountMoney(toId,money);    &#125;&#125;</code></pre><h5 id="1-7-测试类"><a href="#1-7-测试类" class="headerlink" title="1.7 测试类"></a>1.7 测试类</h5><pre><code class="java">package com.atguigu;import com.atguigu.service.AccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:spring-application.xml&quot;)public class TestTransaction &#123;    @Autowired    private AccountService accountService;    @Test    public void testTransfer()&#123;        accountService.transfer(1,2,500d);    &#125;&#125;</code></pre><h4 id="2-进行基于注解的声明式事务的配置"><a href="#2-进行基于注解的声明式事务的配置" class="headerlink" title="2. 进行基于注解的声明式事务的配置"></a>2. 进行基于注解的声明式事务的配置</h4><h5 id="2-1-配置事务管理器"><a href="#2-1-配置事务管理器" class="headerlink" title="2.1 配置事务管理器"></a>2.1 配置事务管理器</h5><p>在spring的配置文件中配置事务管理器对象</p><pre><code class="xml">&lt;!--对事务管理者做IOC配置--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;!--注入数据源--&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;</code></pre><h5 id="2-2-开启基于注解的声明式事务功能"><a href="#2-2-开启基于注解的声明式事务功能" class="headerlink" title="2.2 开启基于注解的声明式事务功能"></a>2.2 开启基于注解的声明式事务功能</h5><p>在spring的配置文件中开启基于注解的声明式事务功能</p><pre><code class="xml">&lt;!--        要开启注解方式声明式事务的支持        transaction-manager属性:表示使用哪个事务管理器对象来管理事务                               如果你的事务管理器的id是transactionManager的话，可以省略该属性--&gt;&lt;tx:annotation-driven/&gt;</code></pre><p>注意：导入名称空间时有好几个重复的，我们需要的是 <strong>tx 结尾</strong>的那个。 </p><p><img src="http://www.slx.blue/2021/12/08/spring-day04-Transactiona/tu_022.png"></p><h5 id="2-3-在需要事务的方法上使用注解"><a href="#2-3-在需要事务的方法上使用注解" class="headerlink" title="2.3 在需要事务的方法上使用注解"></a>2.3 在需要事务的方法上使用注解</h5><pre><code class="java">@Transactional@Overridepublic void transfer(Integer fromId, Integer toId, Double money) &#123;    //1. 转出账户扣款    accountDao.updateAccountMoney(fromId,-money);    int num = 10/0;    //2. 转入账户收款    accountDao.updateAccountMoney(toId,money);&#125;</code></pre><h5 id="2-4-执行测试"><a href="#2-4-执行测试" class="headerlink" title="2.4 执行测试"></a>2.4 执行测试</h5><pre><code class="java">package com.atguigu;import com.atguigu.service.AccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:spring-application.xml&quot;)public class TestTransaction &#123;    @Autowired    private AccountService accountService;    @Test    public void testTransfer()&#123;        accountService.transfer(1,2,500d);    &#125;&#125;</code></pre><h4 id="3-从日志内容角度查看事务效果"><a href="#3-从日志内容角度查看事务效果" class="headerlink" title="3. 从日志内容角度查看事务效果"></a>3. 从日志内容角度查看事务效果</h4><h5 id="3-1-加入依赖"><a href="#3-1-加入依赖" class="headerlink" title="3.1 加入依赖"></a>3.1 加入依赖</h5><pre><code class="xml">&lt;!-- 加入日志 --&gt;&lt;dependency&gt;    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;    &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><h5 id="3-2-加入logback的配置文件"><a href="#3-2-加入logback的配置文件" class="headerlink" title="3.2 加入logback的配置文件"></a>3.2 加入logback的配置文件</h5><p>文件名：logback.xml </p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;true&quot;&gt;    &lt;!-- 指定日志输出的位置 --&gt;    &lt;appender name=&quot;STDOUT&quot;              class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;encoder&gt;            &lt;!-- 日志输出的格式 --&gt;            &lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;            &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;     &lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;    &lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;    &lt;root level=&quot;INFO&quot;&gt;        &lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;    &lt;/root&gt;     &lt;!-- 根据特殊需求指定局部日志级别 --&gt;    &lt;logger name=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot; level=&quot;DEBUG&quot;/&gt;    &lt;logger name=&quot;org.springframework.jdbc.core.JdbcTemplate&quot; level=&quot;DEBUG&quot; /&gt; &lt;/configuration&gt;</code></pre><h5 id="3-3-观察日志打印"><a href="#3-3-观察日志打印" class="headerlink" title="3.3 观察日志打印"></a>3.3 观察日志打印</h5><p><img src="http://www.slx.blue/2021/12/08/spring-day04-Transactiona/tu_031.png"></p><h4 id="4-debug查看事务管理器中的关键方法"><a href="#4-debug查看事务管理器中的关键方法" class="headerlink" title="4. debug查看事务管理器中的关键方法"></a>4. debug查看事务管理器中的关键方法</h4><p>需要查看的类：org.springframework.jdbc.datasource.DataSourceTransactionManager </p><h5 id="4-1-开启事务的方法"><a href="#4-1-开启事务的方法" class="headerlink" title="4.1 开启事务的方法"></a>4.1 开启事务的方法</h5><p><img src="http://www.slx.blue/2021/12/08/spring-day04-Transactiona/tu_023.png"></p><p><img src="http://www.slx.blue/2021/12/08/spring-day04-Transactiona/tu_024.png"></p><h5 id="4-2-提交事务的方法"><a href="#4-2-提交事务的方法" class="headerlink" title="4.2 提交事务的方法"></a>4.2 提交事务的方法</h5><p><img src="http://www.slx.blue/2021/12/08/spring-day04-Transactiona/tu_025.png"></p><h5 id="4-3-回滚事务的方法"><a href="#4-3-回滚事务的方法" class="headerlink" title="4.3 回滚事务的方法"></a>4.3 回滚事务的方法</h5><p><img src="http://www.slx.blue/2021/12/08/spring-day04-Transactiona/tu_026.png"></p><h3 id="第四节-事务属性"><a href="#第四节-事务属性" class="headerlink" title="第四节 事务属性"></a>第四节 事务属性</h3><h4 id="1-只读属性"><a href="#1-只读属性" class="headerlink" title="1. 只读属性"></a>1. 只读属性</h4><h5 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h5><p>对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。但是如果你的方法中执行写操作，那么就会报错</p><h5 id="1-2-设置方式"><a href="#1-2-设置方式" class="headerlink" title="1.2 设置方式"></a>1.2 设置方式</h5><pre><code class="java">@Transactional(read-only=true)@Overridepublic void transfer(Integer fromId, Integer toId, Double money) &#123;    //1. 转出账户扣款    accountDao.updateAccountMoney(fromId,-money);    //int num = 10/0;    //2. 转入账户收款    accountDao.updateAccountMoney(toId,money);&#125;</code></pre><h5 id="1-3-如果在设置了只读的事务中进行写操作"><a href="#1-3-如果在设置了只读的事务中进行写操作" class="headerlink" title="1.3 如果在设置了只读的事务中进行写操作"></a>1.3 如果在设置了只读的事务中进行写操作</h5><p>会抛出下面异常：</p><blockquote><p>Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed</p></blockquote><h5 id="1-4-如果将-Transactional注解放在类上"><a href="#1-4-如果将-Transactional注解放在类上" class="headerlink" title="1.4  如果将@Transactional注解放在类上"></a>1.4  如果将@Transactional注解放在类上</h5><h6 id="1-4-1-生效原则"><a href="#1-4-1-生效原则" class="headerlink" title="1.4.1 生效原则"></a>1.4.1 生效原则</h6><p>如果一个类中每一个方法上都使用了@Transactional注解，那么就可以将@Transactional注解提取到类上。反过来说：@Transactional注解在类级别标记，会影响到类中的每一个方法。同时，类级别标记的@Transactional注解中设置的事务属性也会延续影响到方法执行时的事务属性。除非在方法上又设置了@Transactional注解。</p><p>对一个方法来说，离它最近的@Transactional注解中的事务属性设置生效。</p><h6 id="1-4-2-用法举例"><a href="#1-4-2-用法举例" class="headerlink" title="1.4.2 用法举例"></a>1.4.2 用法举例</h6><p>在类级别@Transactional注解中设置只读，这样类中所有的查询方法都不需要设置@Transactional注解了。因为对查询操作来说</p><p>，其他属性通常不需要设置，所以使用公共设置即可。</p><p>然后在这个基础上，对增删改方法设置@Transactional注解 readOnly 属性为 false。</p><pre><code class="java">package com.atguigu.service.impl;import com.atguigu.dao.AccountDao;import com.atguigu.service.AccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;/** * read-only属性表示事务是否只读:默认值是false， 如果设置为true那么当前事务中只能做数据库的读操作，不能做写操作 *          该属性的作用:可以对只读的数据库操作做一些优化 */@Transactional(readOnly = true)@Servicepublic class AccountServiceImpl implements AccountService &#123;    @Autowired    private AccountDao accountDao;    @Transactional(readOnly = false)    @Override    public void transfer(Integer fromId, Integer toId, Double money) &#123;        //1. 转出账户扣款        accountDao.updateAccountMoney(fromId,-money);        //int num = 10/0;        //2. 转入账户收款        accountDao.updateAccountMoney(toId,money);    &#125;&#125;</code></pre><blockquote><p>PS：Spring 环境下很多场合都有类似设定，一个注解如果标记了类的每一个方法那么通常就可以提取到类级别。但是，如果不是类中的所有方法都需要用到事务，则绝不允许将@Transaction注解放在类上</p></blockquote><h4 id="2-超时属性"><a href="#2-超时属性" class="headerlink" title="2. 超时属性"></a>2. 超时属性</h4><h5 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h5><p>事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。</p><p>此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。</p><p>概括来说就是一句话：超时回滚，释放资源。</p><h5 id="2-2-设置方式"><a href="#2-2-设置方式" class="headerlink" title="2.2 设置方式"></a>2.2 设置方式</h5><pre><code class="java">@Transactional(readOnly = false, timeout = 3)public void updateTwice(        // 修改员工姓名的一组参数        Integer empId4EditName, String newName,        // 修改员工工资的一组参数        Integer empId4EditSalary, Double newSalary        ) &#123;    // 为了测试事务是否生效，执行两个数据库操作，看它们是否会在某一个失败时一起回滚    empDao.updateEmpNameById(empId4EditName, newName);    empDao.updateEmpSalaryById(empId4EditSalary, newSalary);&#125;</code></pre><h5 id="2-3-模拟超时"><a href="#2-3-模拟超时" class="headerlink" title="2.3 模拟超时"></a>2.3 模拟超时</h5><pre><code class="java">public void updateEmpSalaryById(Integer empId, Double salary) &#123;    try &#123;        TimeUnit.SECONDS.sleep(5);    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;    // 为了看到操作失败后的效果人为将 SQL 语句破坏    String sql = &quot;update t_emp set emp_salary=? where emp_id=?&quot;;    jdbcTemplate.update(sql, salary, empId);&#125;</code></pre><blockquote><p>PS：注意：sleep操作如果放在执行 SQL 语句后面那就不起作用。</p></blockquote><h5 id="2-4-执行效果"><a href="#2-4-执行效果" class="headerlink" title="2.4  执行效果"></a>2.4  执行效果</h5><p>执行过程中日志和抛出异常的情况：</p><blockquote><p>[16:25:41.706] [DEBUG] [main] [org.springframework.jdbc.datasource.DataSourceTransactionManager] [Initiating transaction rollback] [16:25:41.706] [DEBUG] [main] [org.springframework.jdbc.datasource.DataSourceTransactionManager] [Rolling back JDBC transaction on Connection [com.mysql.jdbc.JDBC4Connection@53b7f657]] [16:25:41.709] [DEBUG] [main] [org.springframework.jdbc.datasource.DataSourceTransactionManager] [Releasing JDBC Connection [com.mysql.jdbc.JDBC4Connection@53b7f657] after transaction]</p><p>org.springframework.transaction.<strong>TransactionTimedOutException</strong>: Transaction timed out: deadline was Fri Jun 04 16:25:39 CST 2021</p></blockquote><h4 id="3-回滚和不回滚的异常属性"><a href="#3-回滚和不回滚的异常属性" class="headerlink" title="3. 回滚和不回滚的异常属性"></a>3. 回滚和不回滚的异常属性</h4><h5 id="3-1-默认情况"><a href="#3-1-默认情况" class="headerlink" title="3.1 默认情况"></a>3.1 默认情况</h5><p>默认只针对运行时异常回滚，编译时异常不回滚。情景模拟代码如下： </p><pre><code class="java">@Transactional@Overridepublic void transfer(Integer fromId, Integer toId, Double money) throws ClassNotFoundException&#123;    //1. 转出账户扣款    accountDao.updateAccountMoney(fromId,-money);    //什么是运行时异常:不需要在编译时处理的异常    //什么是编译时异常:需要在编译时就进行处理的异常    //默认情况是遇到运行时异常才回滚:    Class.forName(&quot;com.mysql.jdbc.Driveraaaaaa&quot;);    int num = 10/0;    //2. 转入账户收款    accountDao.updateAccountMoney(toId,money);&#125;</code></pre><h5 id="3-2-设置回滚的异常"><a href="#3-2-设置回滚的异常" class="headerlink" title="3.2 设置回滚的异常"></a>3.2 设置回滚的异常</h5><ul><li>rollbackFor属性：需要设置一个Class类型的对象</li><li>rollbackForClassName属性：需要设置一个字符串类型的全类名</li></ul><pre><code class="java">@Transactional(rollbackFor = Exception.class)</code></pre><h5 id="3-3-设置不回滚的异常"><a href="#3-3-设置不回滚的异常" class="headerlink" title="3.3 设置不回滚的异常"></a>3.3 设置不回滚的异常</h5><p>在默认设置和已有设置的基础上，再指定一个异常类型，碰到它不回滚。 </p><pre><code class="java">@Transactional(    noRollbackFor = FileNotFoundException.class)</code></pre><h5 id="3-4-如果回滚和不回滚异常同时设置"><a href="#3-4-如果回滚和不回滚异常同时设置" class="headerlink" title="3.4 如果回滚和不回滚异常同时设置"></a>3.4 如果回滚和不回滚异常同时设置</h5><h6 id="3-4-1-当两者范围不同"><a href="#3-4-1-当两者范围不同" class="headerlink" title="3.4.1 当两者范围不同"></a>3.4.1 当两者范围不同</h6><p>不管是哪个设置范围大，都是在大范围内在排除小范围的设定。例如：</p><ul><li>rollbackFor = Exception.class</li><li>noRollbackFor = FileNotFoundException.class</li></ul><p>意思是除了 FileNotFoundException 之外，其他所有 Exception 范围的异常都回滚；但是碰到 FileNotFoundException 不回滚。</p><h6 id="3-4-2-当两者范围相同-傻子才会这样去设置"><a href="#3-4-2-当两者范围相同-傻子才会这样去设置" class="headerlink" title="3.4.2 当两者范围相同(傻子才会这样去设置)"></a>3.4.2 当两者范围相同(傻子才会这样去设置)</h6><ul><li>noRollbackFor = FileNotFoundException.class</li><li>rollbackFor = FileNotFoundException.class</li></ul><p>此时 Spring 采纳了 rollbackFor 属性的设定：遇到 FileNotFoundException 异常会回滚。</p><h4 id="4-事务隔离级别属性"><a href="#4-事务隔离级别属性" class="headerlink" title="4. 事务隔离级别属性"></a>4. 事务隔离级别属性</h4><h5 id="4-1-回顾事务的隔离级别"><a href="#4-1-回顾事务的隔离级别" class="headerlink" title="4.1 回顾事务的隔离级别"></a>4.1 回顾事务的隔离级别</h5><table><thead><tr><th><strong>级别</strong></th><th><strong>名字</strong></th><th><strong>隔离级别</strong></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th><th><strong>数据库默认隔离级别</strong></th></tr></thead><tbody><tr><td><strong>1</strong></td><td>读未提交</td><td>read uncommitted</td><td>是</td><td>是</td><td>是</td><td>一般不使用</td></tr><tr><td><strong>2</strong></td><td>读已提交</td><td>read committed</td><td>否</td><td>是</td><td>是</td><td>Oracle</td></tr><tr><td><strong>3</strong></td><td>可重复读</td><td>repeatable read</td><td>否</td><td>否</td><td>是</td><td>MySQL</td></tr><tr><td><strong>4</strong></td><td>串行化</td><td>serializable</td><td>否</td><td>否</td><td>否</td><td>最高的隔离级别</td></tr></tbody></table><h5 id="4-2-设置方式"><a href="#4-2-设置方式" class="headerlink" title="4.2 设置方式"></a>4.2 设置方式</h5><p>在 @Transactional 注解中使用 isolation 属性设置事务的隔离级别。 取值使用 org.springframework.transaction.annotation.Isolation 枚举类提供的数值。 </p><pre><code class="java">@Transactional(isolation = Isolation.READ_UNCOMMITTED)</code></pre><p>我们一般不需要去设置事务的隔离级别，绝大多数情况下使用默认的隔离级别就行</p><h4 id="5-事务传播行为属性"><a href="#5-事务传播行为属性" class="headerlink" title="5. 事务传播行为属性"></a>5. 事务传播行为属性</h4><h5 id="5-1-事务传播行为要研究的问题"><a href="#5-1-事务传播行为要研究的问题" class="headerlink" title="5.1 事务传播行为要研究的问题"></a>5.1 事务传播行为要研究的问题</h5><p>事务的传播行为要研究的是是当两个方法嵌套执行的时候，外层方法的事务能否传播到内层方法以及怎么传播到外层方法</p><h5 id="5-2-propagation属性"><a href="#5-2-propagation属性" class="headerlink" title="5.2 propagation属性"></a>5.2 propagation属性</h5><h6 id="5-2-1-默认值"><a href="#5-2-1-默认值" class="headerlink" title="5.2.1 默认值"></a>5.2.1 默认值</h6><p>@Transactional 注解通过 propagation 属性设置事务的传播行为。它的默认值是：</p><pre><code class="java">Propagation propagation() default Propagation.REQUIRED;</code></pre><h6 id="5-2-2-可选值说明"><a href="#5-2-2-可选值说明" class="headerlink" title="5.2.2 可选值说明"></a>5.2.2 可选值说明</h6><p>propagation 属性的可选值由 org.springframework.transaction.annotation.Propagation 枚举类提供：</p><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>REQUIRED 默认值</td><td>当前方法必须工作在事务中 如果当前线程上有已经开启的事务可用，那么就在这个事务中运行 如果当前线程上没有已经开启的事务，那么就自己开启新事务，在新事务中运行 所以当前方法有可能和其他方法共用事务 在共用事务的情况下：当前方法会因为其他方法回滚而受连累</td></tr><tr><td><strong>REQUIRES_NEW</strong> 建议使用</td><td>当前方法必须工作在事务中 不管当前线程上是否有已经开启的事务，都要开启新事务 在新事务中运行 不会和其他方法共用事务，避免被其他方法连累。如果外层已经有事务，就先将它挂起，内层方法新建实物，内层方法新建实物执行完之后再恢复外层事务</td></tr><tr><td>SUPPORTS(支持)</td><td>如果外层方法有事务，内层方法则会参与进外层事务一起执行，如果外层方法没有事务，那么内层方法则是以非事务方式运行</td></tr><tr><td>NOT_SUPPORTED</td><td>如果外层方法有事务，则先将外层方法事务挂起，内层以非事务方法执行。执行完之后再恢复外层事务(不支持事务)</td></tr><tr><td>MANDATORY(强制性的)</td><td>如果外层方法有事务，内层方法则会参与外层事务一起执行，如果外层方法没有事务，则抛出异常，强制从外层方法必须有事务</td></tr><tr><td>NEVER</td><td>只能以非事务方式运行，如果外层方法有事务 直接抛出异常</td></tr><tr><td>NESTED</td><td>新建一个嵌套事务，在嵌套事务中执行，设置了一个回滚点。有点类似REQUIRED</td></tr></tbody></table><h5 id="5-3-测试事务的传播行为"><a href="#5-3-测试事务的传播行为" class="headerlink" title="5.3 测试事务的传播行为"></a>5.3 测试事务的传播行为</h5><h6 id="5-3-1-在业务层中声明两个内层方法"><a href="#5-3-1-在业务层中声明两个内层方法" class="headerlink" title="5.3.1 在业务层中声明两个内层方法"></a>5.3.1 在业务层中声明两个内层方法</h6><pre><code class="java">@Transactional(propagation = Propagation.REQUIRED)@Overridepublic void updateAccountNameInner(Integer accountId, String accountName)&#123;    accountDao.updateAccountName(accountId,accountName);    int num = 10/0;&#125;@Transactional(propagation = Propagation.REQUIRED)@Overridepublic void updateAccountMoney(Integer accountId, Double money)&#123;    accountDao.updateAccountMoney(accountId,money);&#125;</code></pre><h6 id="5-3-2-创建TopService"><a href="#5-3-2-创建TopService" class="headerlink" title="5.3.2 创建TopService"></a>5.3.2 创建TopService</h6><pre><code class="java">package com.atguigu.service.impl;import com.atguigu.service.AccountService;import com.atguigu.service.TopService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Servicepublic class TopServiceImpl implements TopService &#123;    @Autowired    private AccountService accountService;    @Transactional    @Override    public void topTxMethod() &#123;        accountService.updateAccountMoney(1,2000d);        accountService.updateAccountNameInner(1,&quot;hello&quot;);    &#125;&#125;</code></pre><h6 id="5-3-3-junit测试方法"><a href="#5-3-3-junit测试方法" class="headerlink" title="5.3.3 junit测试方法"></a>5.3.3 junit测试方法</h6><pre><code class="java">package com.atguigu;import com.atguigu.service.AccountService;import com.atguigu.service.TopService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:spring-application.xml&quot;)public class TestTransaction &#123;    @Autowired    private AccountService accountService;    @Autowired    private TopService topService;    @Test    public void testPropagation()&#123;        topService.topTxMethod();    &#125;&#125;</code></pre><h6 id="5-3-4-测试-REQUIRED-模式"><a href="#5-3-4-测试-REQUIRED-模式" class="headerlink" title="5.3.4 测试 REQUIRED 模式"></a>5.3.4 测试 REQUIRED 模式</h6><p><img src="http://www.slx.blue/2021/12/08/spring-day04-Transactiona/tu_027.png"></p><p>效果：内层方法A、内层方法B所做的修改都没有生效，总事务回滚了。 </p><h6 id="5-3-5-测试-REQUIRES-NEW-模式"><a href="#5-3-5-测试-REQUIRES-NEW-模式" class="headerlink" title="5.3.5 测试 REQUIRES_NEW 模式"></a>5.3.5 测试 REQUIRES_NEW 模式</h6><p>修改 EmpService 中内层方法</p><pre><code class="java">@Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)public void updateEmpNameInner(Integer empId, String empName) &#123;        empDao.updateEmpNameById(empId, empName);&#125;    @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)public void updateEmpSalaryInner(Integer empId, Double empSalary) &#123;        empDao.updateEmpSalaryById(empId, empSalary);&#125;</code></pre><p><img src="http://www.slx.blue/2021/12/08/spring-day04-Transactiona/tu_028.png"></p><p>效果：内层方法A的修改生效了、内层方法B所做的修改都没有生效，总事务回滚了。</p><h6 id="5-3-6-实际开发情景"><a href="#5-3-6-实际开发情景" class="headerlink" title="5.3.6 实际开发情景"></a>5.3.6 实际开发情景</h6><p>Service方法应用了通知</p><p><img src="http://www.slx.blue/2021/12/08/spring-day04-Transactiona/tu_029.png"></p><p>过滤器或拦截器等类似组件</p><p><img src="http://www.slx.blue/2021/12/08/spring-day04-Transactiona/tu_030.png"></p><p>我们在事务传播行为这里，使用 REQUIRES_NEW 属性，也可以说是让不同事务方法从事务的使用上<strong>解耦合</strong>，不要互相影响。 </p><h3 id="第五节-基于XML配置声明式事务-了解"><a href="#第五节-基于XML配置声明式事务-了解" class="headerlink" title="第五节 基于XML配置声明式事务(了解)"></a>第五节 基于XML配置声明式事务(了解)</h3><h4 id="1-加入依赖"><a href="#1-加入依赖" class="headerlink" title="1. 加入依赖"></a>1. 加入依赖</h4><p>相比于基于注解的声明式事务，基于 XML 的声明式事务需要一个额外的依赖： </p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;    &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="2-迁移代码"><a href="#2-迁移代码" class="headerlink" title="2. 迁移代码"></a>2. 迁移代码</h4><p>将上一个基于注解的 module 中的代码转移到新module。去掉 @Transactional 注解。 </p><h4 id="3-修改-Spring-配置文件"><a href="#3-修改-Spring-配置文件" class="headerlink" title="3. 修改 Spring 配置文件"></a>3. 修改 Spring 配置文件</h4><p>去掉 tx:annotation-driven 标签，然后加入下面的配置： </p><pre><code class="xml">&lt;!--        使用配置文件方式配置声明式事务:        配置文件方式进行声明式事务的配置是写在&lt;tx:advice&gt;标签中，        该标签的transaction-manager表示使用哪个事务管理器对象来进行事务管理，默认的事务管理器的id是transactionManager    --&gt;&lt;tx:advice id=&quot;adv1&quot;&gt;    &lt;!--            tx:attributes表示声明各个方法上使用的事务的属性        --&gt;    &lt;tx:attributes&gt;        &lt;!--                tx:method表示要使用事务的方法，name属性表示方法名，其它属性表示事务的属性            --&gt;        &lt;tx:method name=&quot;transfer&quot; rollback-for=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--真正配置事务作用在哪些方法上，要通过aop配置--&gt;&lt;aop:config&gt;    &lt;!--配置切入点:表示描述哪些方法要使用事务--&gt;    &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(public void com.atguigu.service.impl.AccountServiceImpl.transfer(Integer,Integer,Double))&quot;/&gt;    &lt;!--指定事务作用于切入点--&gt;    &lt;aop:advisor advice-ref=&quot;adv1&quot; pointcut-ref=&quot;pt1&quot;/&gt;&lt;/aop:config&gt;</code></pre><h4 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h4><p>即使需要事务功能的目标方法已经被切入点表达式涵盖到了，但是如果没有给它配置事务属性，那么这个方法就还是没有事务。所以事务属性必须配置。 </p><h2 id="第三章-Spring5的新特性"><a href="#第三章-Spring5的新特性" class="headerlink" title="第三章 Spring5的新特性"></a>第三章 Spring5的新特性</h2><h3 id="第一节-JSR305标准相关注解"><a href="#第一节-JSR305标准相关注解" class="headerlink" title="第一节 JSR305标准相关注解"></a>第一节 JSR305标准相关注解</h3><h4 id="1-JSR的概述"><a href="#1-JSR的概述" class="headerlink" title="1. JSR的概述"></a>1. JSR的概述</h4><h5 id="1-1-JCP"><a href="#1-1-JCP" class="headerlink" title="1.1 JCP"></a>1.1 JCP</h5><p>JCP（Java Community Process) 是一个由SUN公司发起的，开放的国际组织。主要由Java开发者以及被授权者组成，负责Java技术规范维护，Java技术发展和更新。</p><p>JCP官网地址：<a href="https://jcp.org/en/home/index">https://jcp.org/en/home/index</a></p><h5 id="1-2-JSR"><a href="#1-2-JSR" class="headerlink" title="1.2 JSR"></a>1.2 JSR</h5><p>JSR 的全称是：Java Specification Request，意思是 Java 规范提案。谁向谁提案呢？任何人都可以向 JCP (Java Community Process) 提出新增一个标准化技术规范的正式请求。JSR已成为Java界的一个重要标准。登录<a href="https://jcp.org/en/home/index"> JCP 官网</a>可以查看<a href="https://jcp.org/en/jsr/all">所有 JSR 标准</a>。 </p><h4 id="2-JSR-305的规范"><a href="#2-JSR-305的规范" class="headerlink" title="2. JSR 305的规范"></a>2. JSR 305的规范</h4><p>JSR 305: Annotations for Software Defect Detection</p><p>This JSR will work to develop standard annotations (such as @NonNull) that can be applied to Java programs to assist tools that detect software defects.</p><p>主要功能：使用注解（例如@NonNull等等）协助开发者侦测软件缺陷。</p><p>Spring 从 5.0 版本开始支持了 JSR 305 规范中涉及到的相关注解。</p><pre><code class="java">package org.springframework.lang;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import javax.annotation.Nonnull;import javax.annotation.meta.TypeQualifierNickname;/** * A common Spring annotation to declare that annotated elements cannot be &#123;@code null&#125;. * * &lt;p&gt;Leverages JSR-305 meta-annotations to indicate nullability in Java to common * tools with JSR-305 support and used by Kotlin to infer nullability of Spring API. * * &lt;p&gt;Should be used at parameter, return value, and field level. Method overrides should * repeat parent &#123;@code @NonNull&#125; annotations unless they behave differently. * * &lt;p&gt;Use &#123;@code @NonNullApi&#125; (scope = parameters + return values) and/or &#123;@code @NonNullFields&#125; * (scope = fields) to set the default behavior to non-nullable in order to avoid annotating * your whole codebase with &#123;@code @NonNull&#125;. * * @author Sebastien Deleuze * @author Juergen Hoeller * @since 5.0 * @see NonNullApi * @see NonNullFields * @see Nullable */@Target(&#123;ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Nonnull@TypeQualifierNicknamepublic @interface NonNull &#123;&#125;</code></pre><h4 id="3-相关注解"><a href="#3-相关注解" class="headerlink" title="3. 相关注解"></a>3. 相关注解</h4><table><thead><tr><th>注解名称</th><th>含义</th><th>可标记位置</th></tr></thead><tbody><tr><td>@Nullable</td><td>可以为空</td><td>@Target({ElementType.<strong>METHOD</strong>, ElementType.<strong>PARAMETER</strong>, ElementType.<strong>FIELD</strong>})</td></tr><tr><td>@NonNull</td><td>不应为空</td><td>@Target({ElementType.<strong>METHOD</strong>, ElementType.<strong>PARAMETER</strong>, ElementType.<strong>FIELD</strong>})</td></tr><tr><td>@NonNullFields</td><td>在特定包下的字段不应为空</td><td>@Target(ElementType.<strong>PACKAGE</strong>) @TypeQualifierDefault(ElementType.<strong>FIELD</strong>)</td></tr><tr><td>@NonNullApi</td><td>参数和方法返回值不应为空</td><td>@Target(ElementType.<strong>PACKAGE</strong>) @TypeQualifierDefault({ElementType.<strong>METHOD</strong>, ElementType.<strong>PARAMETER</strong>})</td></tr></tbody></table><h3 id="第二节-整合junit5"><a href="#第二节-整合junit5" class="headerlink" title="第二节 整合junit5"></a>第二节 整合junit5</h3><h4 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1. 导入依赖"></a>1. 导入依赖</h4><p>在原有环境基础上增加如下依赖： </p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;    &lt;version&gt;5.7.0&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="2-创建测试类"><a href="#2-创建测试类" class="headerlink" title="2. 创建测试类"></a>2. 创建测试类</h4><ul><li>@ExtendWith(SpringExtension.class) 表示使用 Spring 提供的扩展功能。</li><li>@ContextConfiguration(value = {“classpath:spring-context.xml”}) 还是用来指定 Spring 配置文件位置，和整合 junit4 一样。</li></ul><pre><code class="java">package com.atguigu;import com.atguigu.config.AtguiguSpringConfiguration;import com.atguigu.service.AccountService;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit.jupiter.SpringExtension;@ExtendWith(SpringExtension.class)@ContextConfiguration(classes = AtguiguSpringConfiguration.class)public class TestTransaction &#123;    @Autowired    private AccountService accountService;    @Test    public void testTransfer() throws ClassNotFoundException &#123;        accountService.transfer(1,2,500d);    &#125;&#125;</code></pre><h4 id="3-使用复合注解"><a href="#3-使用复合注解" class="headerlink" title="3. 使用复合注解"></a>3. 使用复合注解</h4><p>@SpringJUnitConfig 注解综合了前面两个注解的功能，此时指定 Spring 配置文件位置即可。但是注意此时需要使用 locations 属性，不是 value 属性了。 </p><pre><code class="java">package com.atguigu;import com.atguigu.config.AtguiguSpringConfiguration;import com.atguigu.service.AccountService;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;@SpringJUnitConfig(AtguiguSpringConfiguration.class)public class TestTransaction &#123;    @Autowired    private AccountService accountService;    @Test    public void testTransfer() throws ClassNotFoundException &#123;        accountService.transfer(1,2,500d);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java设计模式-迭代器模式</title>
      <link href="/2021/12/08/java-iterator/"/>
      <url>/2021/12/08/java-iterator/</url>
      
        <content type="html"><![CDATA[<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>传统模式案例：一个学校有多个学院，每个学院下面又有各种专业，但是每个学院可能存储的数据不一样，可能是集合，可能是数组，可能是map等等等，如何做到用一个统一的接口遍历全部对象， 而不暴露内部细节，简化用户的使用。</p><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍:"></a>基本介绍:</h4><ol><li>迭代器模式(Iterator Pattern) 是常用的设计模式 ，属于行为型模式</li><li>如果我们的集合元素是用不同的方式实现的，有数组，还有<code>java</code>的集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种便利方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。</li><li>迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示。即：不暴露其内部结构。</li></ol><p>用例图：</p><p><img src="http://www.slx.blue/2021/12/08/java-iterator/iterator01.png" alt="iterator01"></p><p>类图说明：</p><ul><li>Iterator ： 迭代器接口，是系统提供，含义 <code>hasNext</code>， next  ， remove)</li><li><code>ConcreateIterator</code>：具体的迭代器类，管理迭代。</li><li>Aggregate ：一个统一的聚合接口，将 客户端 和 具体聚合 解耦。</li><li><code>ConcreateAggreage</code>：具体的聚合 持有对象集合，并提供方法返回一个迭代器</li><li>Client：通过Iterator和Aggregate 依赖子类</li></ul><blockquote><p>编写一个学校院系结构，在一个页面中展示出学校院系组成，一个学校有多个学院，一个学院有多个系</p></blockquote><h4 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h4><pre><code class="java">//College接口public interface College &#123;    //名字    public String getName();        //增加系的方法    public void addDepartment(String name, String desc);        //返回一个迭代器,遍历    public Iterator  createIterator();&#125;</code></pre><pre><code class="java">//用来存储数据的统一模型public class Department &#123;    private String name;    private String desc;    public Department(String name, String desc) &#123;        this.name = name;        this.desc = desc;    &#125;    public String getName() &#123;return name;&#125;    public void setName(String name) &#123;this.name = name;&#125;    public String getDesc() &#123;return desc;&#125;    public void setDesc(String desc) &#123;this.desc = desc;&#125;    &#125;</code></pre><pre><code class="java">//计算机学院具体类public class ComputerCollege implements College &#123;    //模拟每个学院存储数据的方式集合不一样    Department[] departments;    int numOfDepartment = 0 ;// 保存当前数组的对象个数    //初始化数据    public ComputerCollege() &#123;        departments = new Department[5];        addDepartment(&quot;Java专业&quot;, &quot; Java专业 &quot;);        addDepartment(&quot;PHP专业&quot;, &quot; PHP专业 &quot;);        addDepartment(&quot;大数据专业&quot;, &quot; 大数据专业 &quot;);            &#125;        @Override    public String getName() &#123;        return &quot;计算机学院&quot;;    &#125;    @Override    public void addDepartment(String name, String desc) &#123;        Department department = new Department(name, desc);        departments[numOfDepartment] = department;        numOfDepartment += 1;    &#125;    @Override    public Iterator createIterator() &#123;        return new ComputerCollegeIterator(departments);    &#125;&#125;</code></pre><pre><code class="java">//计算机学院迭代器public class ComputerCollegeIterator implements Iterator &#123;    //不同的迭代器实现不同的遍历方法    //这里我们需要Department 是以怎样的方式存放=&gt;数组    Department[] departments;    int position = 0; //遍历的位置        public ComputerCollegeIterator(Department[] departments) &#123;        this.departments = departments;    &#125;    //判断是否还有下一个元素    @Override    public boolean hasNext() &#123;        if(position &gt;= departments.length || departments[position] == null) &#123;            return false;        &#125;else &#123;                    return true;        &#125;    &#125;    @Override    public Object next() &#123;        Department department = departments[position];        position += 1;        return department;    &#125;        //删除的方法，默认空实现    public void remove() &#123;            &#125;&#125;</code></pre><pre><code class="java">//信息工程学院具体实现类public class InfoCollege implements College &#123;    //模拟每个学院存储数据的方式集合不一样    List&lt;Department&gt; departmentList;        //初始化数据    public InfoCollege() &#123;        departmentList = new ArrayList&lt;Department&gt;();        addDepartment(&quot;信息安全专业&quot;, &quot; 信息安全专业 &quot;);        addDepartment(&quot;网络安全专业&quot;, &quot; 网络安全专业 &quot;);        addDepartment(&quot;服务器安全专业&quot;, &quot; 服务器安全专业 &quot;);    &#125;        @Override    public String getName() &#123;        return &quot;信息工程学院&quot;;    &#125;    @Override    public void addDepartment(String name, String desc) &#123;        Department department = new Department(name, desc);        departmentList.add(department);    &#125;    @Override    public Iterator createIterator() &#123;        return new InfoCollegeIterator(departmentList);    &#125;&#125;</code></pre><pre><code class="java">//信息工程学院迭代器public class InfoCollegeIterator implements Iterator &#123;    //不同的迭代器实现不同的遍历方法        List&lt;Department&gt; departmentList; // 信息工程学院是以List方式存放系    int index = -1;//索引        public InfoCollegeIterator(List&lt;Department&gt; departmentList) &#123;        this.departmentList = departmentList;    &#125;    //判断list中还有没有下一个元素    @Override    public boolean hasNext() &#123;        if(index &gt;= departmentList.size() - 1) &#123;            return false;        &#125; else &#123;            index += 1;            return true;        &#125;    &#125;    @Override    public Object next() &#123;        return departmentList.get(index);    &#125;        //空实现remove    public void remove() &#123;            &#125;&#125;</code></pre><pre><code class="java">//统一实现打印遍历迭代public class OutPutImpl &#123;        //学院集合     private List&lt;College&gt; collegeList;    //有参构造实现聚合    public OutPutImpl(List&lt;College&gt; collegeList) &#123;        this.collegeList = collegeList;    &#125;    //遍历所有学院,然后调用printDepartment 输出各个学院的系    public void printCollege() &#123;        //从collegeList 取出所有学院, Java 中的 List 已经实现Iterator        Iterator&lt;College&gt; iterator = collegeList.iterator();                while(iterator.hasNext()) &#123;            //取出一个学院            College college = iterator.next();            System.out.println(&quot;=== &quot;+college.getName() +&quot;===== &quot; );            //取出学院的迭代器执行迭代方法            printDepartment(college.createIterator()); //得到对应迭代器        &#125;    &#125;    //输出 学院输出 系    public void printDepartment(Iterator iterator) &#123;        while(iterator.hasNext()) &#123;            Department d = (Department)iterator.next();            System.out.println(d.getName());        &#125;    &#125;&#125;</code></pre><pre><code class="java">//客户端方法public class Client &#123;    public static void main(String[] args) &#123;        //创建学校(学院集合)        List&lt;College&gt; collegeList = new ArrayList&lt;College&gt;();        //创建计算机学院和大数据学院        ComputerCollege computerCollege = new ComputerCollege();        InfoCollege infoCollege = new InfoCollege();        //添加计算机学院和大数据学院        collegeList.add(computerCollege);        collegeList.add(infoCollege);        //统一放到打印实现类实现迭代器遍历        OutPutImpl outPutImpl = new OutPutImpl(collegeList);        outPutImpl.printCollege();    &#125;&#125;</code></pre><h4 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h4><blockquote><p><code>JDK</code>中的<code>ArrayList</code>集合中就使用到了迭代器模式</p><p>List就是聚合接口 <code>ArrayList</code>就是聚合接口实现类 并且实现了一个特有的迭代器 Iteraror</p></blockquote><p><img src="http://www.slx.blue/2021/12/08/java-iterator/iterator02.png" alt="List"></p><h4 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ol><li>优点<ul><li>提供了一个统一的方法遍历对象，客户不再考虑聚合的类型，使用一种方法就可以遍历对象了。</li><li>隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成</li><li>提供了一种设计思想，就是一个类应该只有一个引起变化的原因(单一职责原则)。在聚合类中，我们吧迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到集合对象。而如果便利方式改变的话，只影响到了迭代器。</li><li>当腰展示一组相似对象，或者遍历一组相同对象同时使用，适合使用迭代器模式</li></ul></li><li>缺点<ul><li>每个聚合对象都要一个迭代器，会生成多个迭代器不好管理类</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> designMode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-day03-AOP</title>
      <link href="/2021/12/07/spring-day03-AOP/"/>
      <url>/2021/12/07/spring-day03-AOP/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-day03"><a href="#spring-day03" class="headerlink" title="spring-day03"></a>spring-day03</h1><h2 id="第一章-AOP面向切面编程"><a href="#第一章-AOP面向切面编程" class="headerlink" title="第一章 AOP面向切面编程"></a>第一章 AOP面向切面编程</h2><h3 id="第一节-AOP的概述"><a href="#第一节-AOP的概述" class="headerlink" title="第一节 AOP的概述"></a>第一节 AOP的概述</h3><h4 id="1-为什么需要AOP"><a href="#1-为什么需要AOP" class="headerlink" title="1. 为什么需要AOP"></a>1. 为什么需要AOP</h4><h5 id="1-1-情景设定"><a href="#1-1-情景设定" class="headerlink" title="1.1 情景设定"></a>1.1 情景设定</h5><h6 id="1-1-1-声明一个计算器接口"><a href="#1-1-1-声明一个计算器接口" class="headerlink" title="1.1.1 声明一个计算器接口"></a>1.1.1 声明一个计算器接口</h6><pre><code class="java">public interface Calculator &#123;        int add(int i, int j);        int sub(int i, int j);        int mul(int i, int j);        int div(int i, int j);    &#125;</code></pre><h6 id="1-1-2-给接口声明一个纯净版实现类"><a href="#1-1-2-给接口声明一个纯净版实现类" class="headerlink" title="1.1.2 给接口声明一个纯净版实现类"></a>1.1.2 给接口声明一个纯净版实现类</h6><p><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_001.png"></p><pre><code class="java">package com.atguigu.proxy.imp;    import com.atguigu.proxy.api.Calculator;    public class CalculatorPureImpl implements Calculator &#123;        @Override    public int add(int i, int j) &#123;                int result = i + j;                return result;    &#125;        @Override    public int sub(int i, int j) &#123;            int result = i - j;            return result;    &#125;        @Override    public int mul(int i, int j) &#123;            int result = i * j;            return result;    &#125;        @Override    public int div(int i, int j) &#123;            int result = i / j;            return result;    &#125;&#125;</code></pre><h6 id="1-1-3-需求"><a href="#1-1-3-需求" class="headerlink" title="1.1.3 需求"></a>1.1.3 需求</h6><p>在计算器的每个方法执行前后加入日志打印:</p><p><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_002.png"></p><h6 id="1-1-4-实现方案探讨"><a href="#1-1-4-实现方案探讨" class="headerlink" title="1.1.4 实现方案探讨"></a>1.1.4 实现方案探讨</h6><p>方案一: 在每个方法的前后都加上日志打印的代码</p><p>方案二: 创建一个工具类，将日志打印的代码写在工具类中，然后在每个方法的前后直接调用工具类中的方法打印日志</p><p>方案三: 创建一个父类，在父类的方法中打印日志，子类重写父类的方法(对目前功能不适用)</p><p><strong>方案四: 动态代理</strong></p><p><strong>方案五: AOP</strong></p><h4 id="2-代理模式"><a href="#2-代理模式" class="headerlink" title="2. 代理模式"></a>2. 代理模式</h4><h5 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h5><p>二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类<strong>间接</strong>调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——<strong>解耦</strong>。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。 </p><p>未经过代理的情况:</p><p><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_003.png"></p><p>使用了代理模式的情况:</p><p><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_004.png"></p><h5 id="2-2-相关术语"><a href="#2-2-相关术语" class="headerlink" title="2.2 相关术语"></a>2.2 相关术语</h5><ol><li>代理: 又称之为代理者，用于将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法 </li><li>目标: 又称之为被代理者，用于执行核心逻辑，并且将代理者的非核心逻辑代码<strong>套用</strong>在目标类、对象、方法上</li></ol><h5 id="2-3-静态代理"><a href="#2-3-静态代理" class="headerlink" title="2.3 静态代理"></a>2.3 静态代理</h5><h6 id="2-3-1-创建静态代理类："><a href="#2-3-1-创建静态代理类：" class="headerlink" title="2.3.1 创建静态代理类："></a>2.3.1 创建静态代理类：</h6><pre><code class="java">public class CalculatorStaticProxy implements Calculator &#123;    // 将被代理的目标对象声明为成员变量    private Calculator target;    public CalculatorStaticProxy(Calculator target) &#123;        this.target = target;    &#125;    @Override    public int add(int i, int j) &#123;        // 附加功能由代理类中的代理方法来实现        System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);        // 通过目标对象来实现核心业务逻辑        int addResult = target.add(i, j);        System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + addResult);        return addResult;    &#125;    ……</code></pre><h6 id="2-3-2-问题思考"><a href="#2-3-2-问题思考" class="headerlink" title="2.3.2 问题思考"></a>2.3.2 问题思考</h6><p>静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。</p><p>提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。</p><h5 id="2-4-动态代理"><a href="#2-4-动态代理" class="headerlink" title="2.4 动态代理"></a>2.4 动态代理</h5><p><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_005.png"></p><h6 id="2-4-1-创建生产代理对象的工厂类"><a href="#2-4-1-创建生产代理对象的工厂类" class="headerlink" title="2.4.1 创建生产代理对象的工厂类"></a>2.4.1 创建生产代理对象的工厂类</h6><p>JDK本身就支持动态代理，这是反射技术的一部分。下面我们还是创建一个代理类（生产代理对象的工厂类）： </p><pre><code class="java">package com.atguigu.factory;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class LogDynamicProxyFactory&lt;T&gt; &#123;    private T target;    public LogDynamicProxyFactory(T target) &#123;        this.target = target;    &#125;    /**     * 创建动态代理对象     * @return     */    public T getProxy()&#123;        //使用JDK的动态代理技术        //1. 获取被代理者的字节码对象        Class&lt;?&gt; clazz = target.getClass();        //2. 使用JDK中的Proxy.newProxyInstance(classLoader, interfaces, new InvocationHandler()方法创建动态代理对象        // 该方法的返回值就是动态代理对象        //2.1 类加载器对象        ClassLoader classLoader = clazz.getClassLoader();        //2.2 需要代理的接口:如果明确要代理什么接口，那么就可以直接写new Class[]&#123;要代理的接口.class&#125;        //如果不明确要代理什么接口，那么就获取被代理者实现的所有接口: 被代理者的字节码对象.getInterfaces();        Class&lt;?&gt;[] interfaces = clazz.getInterfaces();        //2.3 InvocationHandler接口的对象: 使用匿名内部类        T t = (T) Proxy.newProxyInstance(classLoader, interfaces, new InvocationHandler() &#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                //invoke()方法:该方法会在代理对象调用任意方法的时候执行                //所以我们就在这个方法中编写代理逻辑                //参数一:proxy对象表示代理对象本身                //参数二:method表示代理对象所调用的方法本身                //参数三:args表示代理对像所调用的方法中传入的参数                //编写代理逻辑:我的想法是在执行被代理对象的add()、sub()、mul()、div()这四个方法的前后添加日志打印                //判断方法：是否是这四个方法                String proxyMethodName = method.getName();                //如果是: 则添加前后日志打印                if (proxyMethodName.equals(&quot;add&quot;) || proxyMethodName.equals(&quot;sub&quot;) || proxyMethodName.equals(&quot;mul&quot;) || proxyMethodName.equals(&quot;div&quot;)) &#123;                    //核心逻辑之前打印日志                    System.out.println(&quot;[日志] &quot;+proxyMethodName+&quot;方法开始了，参数是：&quot; + args[0] + &quot;,&quot; + args[1]);                    //执行被代理者的当前方法                    Object result = method.invoke(target, args);                    //核心逻辑之后打印日志                    System.out.println(&quot;[日志] &quot;+proxyMethodName+&quot; 方法结束了，结果是：&quot; + result);                    //返回执行结果                    return result;                &#125;                //如果不是: 就按照被代理者原本的方法执行                return method.invoke(target,args);            &#125;        &#125;);        return t;    &#125;&#125;</code></pre><h6 id="2-4-2-测试"><a href="#2-4-2-测试" class="headerlink" title="2.4.2 测试"></a>2.4.2 测试</h6><pre><code class="java">@Testpublic void testDynamicProxy()&#123;    //创建被代理者    Calculator calculator = new CalculatorPureImpl();    //1. 创建动态代理工厂类的对象    LogDynamicProxyFactory&lt;Calculator&gt; proxyFactory = new LogDynamicProxyFactory&lt;Calculator&gt;(calculator);    //2. 使用工厂对象创建动态代理对象    Calculator calculatorProxy = proxyFactory.getProxy();    //3. 使用代理对象调用方法    System.out.println(calculatorProxy.sub(3, 4));&#125;</code></pre><h4 id="3-AOP的相关概念"><a href="#3-AOP的相关概念" class="headerlink" title="3. AOP的相关概念"></a>3. AOP的相关概念</h4><h5 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h5><p>AOP：Aspect Oriented Programming面向切面编程 </p><h5 id="3-2-作用"><a href="#3-2-作用" class="headerlink" title="3.2 作用"></a>3.2 作用</h5><ol><li>简化代码：把方法中固定位置的重复的代码<strong>抽取</strong>出来，让被抽取的方法更专注于自己的核心功能，提高内聚性。</li><li>代码增强：把抽取出来的特定的功能封装到切面类中，看哪里有需要，就往上套，被<strong>套用</strong>了切面逻辑的方法就被切面给增强了。</li></ol><h5 id="3-3-AOP的核心思路"><a href="#3-3-AOP的核心思路" class="headerlink" title="3.3 AOP的核心思路"></a>3.3 AOP的核心思路</h5><p><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_006.png"></p><h5 id="3-4-AOP的相关术语"><a href="#3-4-AOP的相关术语" class="headerlink" title="3.4 AOP的相关术语"></a>3.4 AOP的相关术语</h5><h6 id="3-4-1-横切关注点"><a href="#3-4-1-横切关注点" class="headerlink" title="3.4.1 横切关注点"></a>3.4.1 横切关注点</h6><p>横切关注点是从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。</p><p>这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。</p><p><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_007.png"></p><h6 id="3-4-2-通知"><a href="#3-4-2-通知" class="headerlink" title="3.4.2 通知"></a>3.4.2 通知</h6><p>每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。</p><ul><li>前置通知：在被代理的目标方法<strong>前</strong>执行</li><li>返回通知：在被代理的目标方法<strong>成功结束</strong>后执行（<strong>寿终正寝</strong>）</li><li>异常通知：在被代理的目标方法<strong>异常结束</strong>后执行（<strong>死于非命</strong>）</li><li>后置通知：在被代理的目标方法<strong>最终结束</strong>后执行（<strong>盖棺定论</strong>）</li><li>环绕通知：使用try…catch…finally结构围绕<strong>整个</strong>被代理的目标方法，包括上面四种通知对应的所有位置</li></ul><p><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_008.png"></p><h6 id="3-4-3-切面"><a href="#3-4-3-切面" class="headerlink" title="3.4.3 切面"></a>3.4.3 切面</h6><p>封装通知方法的类。 </p><p><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_009.png"></p><h6 id="3-4-4-目标"><a href="#3-4-4-目标" class="headerlink" title="3.4.4 目标"></a>3.4.4 目标</h6><p>被代理的目标对象。 </p><h6 id="3-4-5-代理"><a href="#3-4-5-代理" class="headerlink" title="3.4.5 代理"></a>3.4.5 代理</h6><p>向目标对象应用通知之后创建的代理对象。</p><h6 id="3-4-6-连接点"><a href="#3-4-6-连接点" class="headerlink" title="3.4.6 连接点"></a>3.4.6 连接点</h6><p>这也是一个纯逻辑概念，不是语法定义的。</p><p>把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。连接点其实就是各个方法中可以被增强或修改的点</p><p><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_010.png"></p><h6 id="3-4-7-切入点"><a href="#3-4-7-切入点" class="headerlink" title="3.4.7 切入点"></a>3.4.7 切入点</h6><p>每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物（从逻辑上来说）。而切入点指的则是方法中真正要去配置增强或者配置修改的地方</p><h3 id="第二节-基于注解方式配置AOP"><a href="#第二节-基于注解方式配置AOP" class="headerlink" title="第二节 基于注解方式配置AOP"></a>第二节 基于注解方式配置AOP</h3><h4 id="1-基于注解的AOP用到的技术"><a href="#1-基于注解的AOP用到的技术" class="headerlink" title="1. 基于注解的AOP用到的技术"></a>1. 基于注解的AOP用到的技术</h4><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_011.png" style="zoom:80%;"><ul><li>动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求<strong>代理对象和目标对象实现同样的接口</strong>。</li><li>cglib：通过<strong>继承被代理的目标类</strong>实现代理，所以不需要目标类实现接口。</li><li>AspectJ：本质上是静态代理，<strong>将代理逻辑“织入”被代理的目标类编译得到的字节码文件</strong>，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。</li></ul><h4 id="2-实现基于注解的AOP"><a href="#2-实现基于注解的AOP" class="headerlink" title="2. 实现基于注解的AOP"></a>2. 实现基于注解的AOP</h4><h5 id="2-1-加入依赖"><a href="#2-1-加入依赖" class="headerlink" title="2.1 加入依赖"></a>2.1 加入依赖</h5><p>在IOC所需依赖基础上再加入下面依赖即可： </p><pre><code class="xml">&lt;dependencies&gt;    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- junit测试 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--spring整合Junit--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h5 id="2-2-准备被代理的目标资源"><a href="#2-2-准备被代理的目标资源" class="headerlink" title="2.2 准备被代理的目标资源"></a>2.2 准备被代理的目标资源</h5><h6 id="2-2-1-接口"><a href="#2-2-1-接口" class="headerlink" title="2.2.1 接口"></a>2.2.1 接口</h6><pre><code class="java">public interface Calculator &#123;        int add(int i, int j);        int sub(int i, int j);        int mul(int i, int j);        int div(int i, int j);    &#125;</code></pre><h6 id="2-2-2-接口的实现类"><a href="#2-2-2-接口的实现类" class="headerlink" title="2.2.2 接口的实现类"></a>2.2.2 接口的实现类</h6><p>在Spring环境下工作，所有的一切都必须放在IOC容器中。现在接口的实现类是AOP要代理的目标类，所以它也必须放入IOC容器。 </p><pre><code class="java">package com.atguigu.component;import org.springframework.stereotype.Component;@Componentpublic class CalculatorPureImpl implements Calculator &#123;    @Override    public int add(int i, int j) &#123;        int result = i + j;        //int num = 10 / 0;        return result;    &#125;    @Override    public int sub(int i, int j) &#123;        int result = i - j;        return result;    &#125;    @Override    public int mul(int i, int j) &#123;        int result = i * j;        return result;    &#125;    @Override    public int div(int i, int j) &#123;        int result = i / j;        return result;    &#125;&#125;</code></pre><h6 id="2-2-3-创建切面类"><a href="#2-2-3-创建切面类" class="headerlink" title="2.2.3 创建切面类"></a>2.2.3 创建切面类</h6><pre><code class="java">package com.atguigu.aspect;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;/** * 切面: *  1. 必须的添加Aspect注解 *  2. 切面类必须进行IOC * * 通知: * 1. 确定通知类型:Before、AfterReturning、AfterThrowing、After、Around *    1.1 Before:前置通知，它是执行在目标方法之前 *    1.2 AfterReturning: 返回通知，它是执行在目标方法return之后(当然如果目标方法没有返回值的话就是在它正常结束之后) *    1.3 AfterThrowing: 异常通知，它是执行在目标方法异常结束之后 *    1.4 After: 后置通知,它是执行在目标方法结束之后(无论你是异常结束还是正常结束都会执行) *    1.5 Around: 环绕通知,它可以在切入点的前、后、出现异常之后、finally中都执行通知，它可以用来统计各个方法的执行时间 * * 2. 确定通知要做用的位置(切入点):用切入点表达式描述切入点 * * 切入点: 使用切入点表达式来声明通知需要作用的位置 * 1. 重用切入点: *    1.1 声明切入点: 编写一个public void 方法，该方法的方法体为空，在方法上添加Pointcut注解用于声明切入点 *    1.2 引用切入点: 在需要使用这个切入点的通知注解上引用 *        1.2.1 如果切入点和通知在同一个类中，通过 方法名()引用 *        1.2.2 如果切入点和通知不在同一个类中，通过 类的全限定名.方法名() 引用 * 2. 怎么编写切入点表达式: */@Aspect@Componentpublic class LogAspect &#123;    @Before(&quot;com.atguigu.aspect.AtguiguPointcut.pt1()&quot;)    public void printLogBefore(JoinPoint joinPoint)&#123;        //在前置通知中获取目标/切入点方法的名字以及参数        //joinPoint就是目标/切入点:我们就可以通过JoinPoint获取切入点的信息        //拿到目标方法的参数        Object[] args = joinPoint.getArgs();        //拿到目标方法的签名信息        Signature signature = joinPoint.getSignature();        //从目标方法的签名信息中获取方法名        String methodName = signature.getName();        System.out.println(&quot;[日志] &quot;+methodName+&quot; 方法开始了，参数是：&quot; + args[0] + &quot;,&quot; + args[1]);    &#125;    @AfterReturning(value = &quot;com.atguigu.aspect.AtguiguPointcut.pt1().pt1()&quot;,returning = &quot;result&quot;)    public void printLogAfterReturning(JoinPoint joinPoint,int result)&#123;        String methodName = joinPoint.getSignature().getName();        //怎么在返回通知中获取到切入点的返回值:        //1. 在通知方法中声明一个和返回值同类型的参数来接收目标方法的返回值        //2. 在AfterReturning注解中使用returning属性来指定由哪个参数接收返回值        System.out.println(&quot;[日志] &quot;+methodName+&quot; 方法结束了，结果是：&quot; + result);    &#125;    @AfterThrowing(value = &quot;com.atguigu.aspect.AtguiguPointcut.pt1().pt1()&quot;,throwing = &quot;throwable&quot;)    public void printLogAfterThrowing(JoinPoint joinPoint,Throwable throwable)&#123;        String methodName = joinPoint.getSignature().getName();        //怎么在异常通知中获取到异常信息:        //1. 在通知方法中声明一个Throwable类型的参数，用于接收异常信息        //2. 在AfterThrowing注解中添加throwing属性指定由哪个参数接收异常信息        System.out.println(&quot;[日志] &quot;+methodName+&quot; 方法出现了异常,异常信息是:&quot;+throwable.getStackTrace());    &#125;    @After(&quot;com.atguigu.aspect.AtguiguPointcut.pt1().pt1()&quot;)    public void printLogAfter(JoinPoint joinPoint)&#123;        String methodName = joinPoint.getSignature().getName();        System.out.println(&quot;[日志] &quot;+methodName+&quot; 方法结束了&quot;);    &#125;   /* @Around(&quot;com.atguigu.aspect.AtguiguPointcut.pt1()&quot;)    public Object printLogAround(ProceedingJoinPoint proceedingJoinPoint)&#123;        try &#123;            //ProceedingJoinPoint:表示目标方法            //在环绕通知中能够拿到切入点，所以就能够有它自己调用切入点            //我们自己调用切入点的时候就可以改变传给切入点的参数            System.out.println(&quot;环绕通知中执行切入点之前...&quot;);            Object[] args = new Object[]&#123;4,5&#125;;            Object result = proceedingJoinPoint.proceed(args);            System.out.println(&quot;环绕通知中执行切入点之后...&quot;);            //因为我们能够自己拿到切入点调用之后的结果，所以我们可以改变这个结果再将结果返回出去            result = 10000;            return 10000;        &#125; catch (Throwable throwable) &#123;            throwable.printStackTrace();            //表示执行切入点的时候出现了异常            System.out.println(&quot;出现了异常，环绕通知中处理异常...&quot;);            return 0;        &#125;finally &#123;            System.out.println(&quot;环绕通知中finally.....&quot;);        &#125;    &#125;*/   @Around(&quot;com.atguigu.aspect.AtguiguPointcut.pt1()&quot;)   public Object printLogAround(ProceedingJoinPoint proceedingJoinPoint)&#123;       //在目标方法执行之前获取毫秒数       long startTime = System.currentTimeMillis();       //执行目标方法       try &#123;           Object result = proceedingJoinPoint.proceed();           return result;       &#125; catch (Throwable throwable) &#123;           throwable.printStackTrace();           throw new RuntimeException(throwable.getMessage());       &#125; finally &#123;            //在目标方法执行结束后统计时长           long endTime = System.currentTimeMillis();           System.out.println(endTime - startTime);       &#125;   &#125;&#125;</code></pre><h6 id="2-2-4-创建Spring的配置文件"><a href="#2-2-4-创建Spring的配置文件" class="headerlink" title="2.2.4 创建Spring的配置文件"></a>2.2.4 创建Spring的配置文件</h6><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!--包扫描--&gt;    &lt;context:component-scan base-package=&quot;com.atguigu&quot;/&gt;    &lt;!--允许注解AOP--&gt;    &lt;aop:aspectj-autoproxy /&gt;&lt;/beans&gt;</code></pre><h6 id="2-2-5-测试"><a href="#2-2-5-测试" class="headerlink" title="2.2.5 测试"></a>2.2.5 测试</h6><pre><code class="java">package com.atguigu;import com.atguigu.component.Calculator;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:spring-application.xml&quot;)public class TestAop &#123;    @Autowired    private Calculator calculator;    @Test    public void testAdd()&#123;        //调用CalculatorPureImpl对象的add()方法        System.out.println(&quot;返回值是:&quot;+calculator.add(1, 2));    &#125;&#125;</code></pre><p>打印效果如下：</p><blockquote><p>[AOP前置通知] 方法开始了 方法内部 result = 12 [AOP返回通知] </p><p>方法成功返回了 [AOP后置通知] 方法最终结束了 方法外部 add = 12</p></blockquote><h5 id="2-3-通知执行顺序"><a href="#2-3-通知执行顺序" class="headerlink" title="2.3 通知执行顺序"></a>2.3 通知执行顺序</h5><ul><li>Spring版本5.3.x以前：<ul><li>前置通知</li><li>目标操作</li><li>后置通知</li><li>返回通知或异常通知</li></ul></li><li>Spring版本5.3.x以后：<ul><li>前置通知</li><li>目标操作</li><li>返回通知或异常通知</li><li>后置通知</li></ul></li></ul><h4 id="3-在通知内部获取细节信息"><a href="#3-在通知内部获取细节信息" class="headerlink" title="3. 在通知内部获取细节信息"></a>3. 在通知内部获取细节信息</h4><h5 id="3-1-JoinPoint接口"><a href="#3-1-JoinPoint接口" class="headerlink" title="3.1 JoinPoint接口"></a>3.1 JoinPoint接口</h5><p>org.aspectj.lang.JoinPoint</p><ul><li>要点1：JoinPoint接口通过getSignature()方法获取目标方法的签名</li><li>要点2：通过目标方法签名对象获取方法名</li><li>要点3：通过JoinPoint对象获取外界调用目标方法时传入的实参列表组成的数组</li></ul><pre><code class="java">// @Before注解标记前置通知方法// value属性：切入点表达式，告诉Spring当前通知方法要套用到哪个目标方法上// 在前置通知方法形参位置声明一个JoinPoint类型的参数，Spring就会将这个对象传入// 根据JoinPoint对象就可以获取目标方法名称、实际参数列表@Before(value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;)public void printLogBeforeCore(JoinPoint joinPoint) &#123;    // 1.通过JoinPoint对象获取目标方法签名对象    // 方法的签名：一个方法的全部声明信息    Signature signature = joinPoint.getSignature();        // 2.通过方法的签名对象获取目标方法的详细信息    String methodName = signature.getName();    System.out.println(&quot;methodName = &quot; + methodName);        int modifiers = signature.getModifiers();    System.out.println(&quot;modifiers = &quot; + modifiers);        String declaringTypeName = signature.getDeclaringTypeName();    System.out.println(&quot;declaringTypeName = &quot; + declaringTypeName);        // 3.通过JoinPoint对象获取外界调用目标方法时传入的实参列表    Object[] args = joinPoint.getArgs();        // 4.由于数组直接打印看不到具体数据，所以转换为List集合    List&lt;Object&gt; argList = Arrays.asList(args);        System.out.println(&quot;[AOP前置通知] &quot; + methodName + &quot;方法开始了，参数列表：&quot; + argList);&#125;</code></pre><p>需要获取方法签名、传入的实参等信息时，可以在通知方法声明JoinPoint类型的形参。 </p><h5 id="3-2-获取目标方法的方法返回值"><a href="#3-2-获取目标方法的方法返回值" class="headerlink" title="3.2 获取目标方法的方法返回值"></a>3.2 获取目标方法的方法返回值</h5><p>只有在AfterReturning返回通知中才能够获取目标方法的返回值</p><p><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_012.png"></p><p>通过@AfterReturning注解的returning属性获取目标方法的返回值 </p><pre><code class="java">// @AfterReturning注解标记返回通知方法// 在返回通知中获取目标方法返回值分两步：// 第一步：在@AfterReturning注解中通过returning属性设置一个名称// 第二步：使用returning属性设置的名称在通知方法中声明一个对应的形参@AfterReturning(        value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;,        returning = &quot;targetMethodReturnValue&quot;)public void printLogAfterCoreSuccess(JoinPoint joinPoint, Object targetMethodReturnValue) &#123;        String methodName = joinPoint.getSignature().getName();        System.out.println(&quot;[AOP返回通知] &quot;+methodName+&quot;方法成功结束了，返回值是：&quot; + targetMethodReturnValue);&#125;</code></pre><h5 id="3-3-获取目标方法抛出的异常"><a href="#3-3-获取目标方法抛出的异常" class="headerlink" title="3.3 获取目标方法抛出的异常"></a>3.3 获取目标方法抛出的异常</h5><p>只有在 AfterThrowing 异常通知中才能获取到目标方法抛出的异常</p><p><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_013.png"></p><p>通过@AfterThrowing注解的throwing属性获取目标方法抛出的异常对象 </p><pre><code class="java">// @AfterThrowing注解标记异常通知方法// 在异常通知中获取目标方法抛出的异常分两步：// 第一步：在@AfterThrowing注解中声明一个throwing属性设定形参名称// 第二步：使用throwing属性指定的名称在通知方法声明形参，Spring会将目标方法抛出的异常对象从这里传给我们@AfterThrowing(        value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;,        throwing = &quot;targetMethodException&quot;)public void printLogAfterCoreException(JoinPoint joinPoint, Throwable targetMethodException) &#123;        String methodName = joinPoint.getSignature().getName();        System.out.println(&quot;[AOP异常通知] &quot;+methodName+&quot;方法抛异常了，异常类型是：&quot; + targetMethodException.getClass().getName());&#125;</code></pre><p>打印效果局部如下：</p><blockquote><p>[AOP异常通知] div方法抛异常了，异常类型是：java.lang.ArithmeticException</p><p>java.lang.ArithmeticException: / by zero</p><p>at com.atguigu.aop.imp.CalculatorPureImpl.div(CalculatorPureImpl.java:42) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344)</p></blockquote><h4 id="4-切入点"><a href="#4-切入点" class="headerlink" title="4. 切入点"></a>4. 切入点</h4><h5 id="4-1-重用切入点"><a href="#4-1-重用切入点" class="headerlink" title="4.1 重用切入点"></a>4.1 重用切入点</h5><h6 id="4-1-1-声明切入点"><a href="#4-1-1-声明切入点" class="headerlink" title="4.1.1 声明切入点"></a>4.1.1 声明切入点</h6><p>在一处声明切入点表达式之后，其他有需要的地方引用这个切入点表达式。易于维护，一处修改，处处生效。声明方式如下： </p><pre><code class="java">@Pointcut(&quot;execution(int com.atguigu.component.CalculatorPureImpl.*(int,int))&quot;)public void calculatorPointCut()&#123;&#125;</code></pre><h6 id="4-1-2-同一个类内部引用切入点"><a href="#4-1-2-同一个类内部引用切入点" class="headerlink" title="4.1.2 同一个类内部引用切入点"></a>4.1.2 同一个类内部引用切入点</h6><p>通过方法名引入</p><pre><code class="java">@Before(&quot;calculatorPointCut()&quot;)public void printLogBeforeCore(JoinPoint joinPoint)&#123;</code></pre><h6 id="4-1-3-在其它类中引用切入点"><a href="#4-1-3-在其它类中引用切入点" class="headerlink" title="4.1.3 在其它类中引用切入点"></a>4.1.3 在其它类中引用切入点</h6><p>通过全限定名引入</p><pre><code class="java">@Before(&quot;com.atguigu.pointcut.AtguiguPointCut.calculatorPointCut()&quot;)public void printLogBeforeCore(JoinPoint joinPoint)&#123;&#125;</code></pre><h6 id="4-1-4-对项目中的所有切入点进行统一管理"><a href="#4-1-4-对项目中的所有切入点进行统一管理" class="headerlink" title="4.1.4 对项目中的所有切入点进行统一管理"></a>4.1.4 对项目中的所有切入点进行统一管理</h6><p>而作为存放切入点表达式的类，可以把整个项目中所有切入点表达式全部集中过来，便于统一管理： </p><pre><code class="java">package com.atguigu.pointcut;import org.aspectj.lang.annotation.Pointcut;public class AtguiguPointCut &#123;    @Pointcut(&quot;execution(int com.atguigu.component.CalculatorPureImpl.*(int,int))&quot;)    public void calculatorPointCut()&#123;    &#125;&#125;</code></pre><h5 id="4-2-切入点表达式语法"><a href="#4-2-切入点表达式语法" class="headerlink" title="4.2 切入点表达式语法"></a>4.2 切入点表达式语法</h5><h6 id="4-2-1-切入点表达式的作用"><a href="#4-2-1-切入点表达式的作用" class="headerlink" title="4.2.1 切入点表达式的作用"></a>4.2.1 切入点表达式的作用</h6><p><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_014.png"><br>切入点表达式的作用是用于描述将代理逻辑套用在哪些目标方法上</p><h6 id="4-2-2-语法细节"><a href="#4-2-2-语法细节" class="headerlink" title="4.2.2 语法细节"></a>4.2.2 语法细节</h6><ul><li>用*号代替“权限修饰符”和“返回值”部分表示“权限修饰符”和“返回值”不限</li><li>在包名的部分，一个“*”号只能代表包的层次结构中的一层，表示这一层是任意的。<ul><li>例如：*.Hello匹配com.Hello，不匹配com.atguigu.Hello</li></ul></li><li>在包名的部分，使用“*..”表示包名任意、包的层次深度任意</li><li>在类名的部分，类名部分整体用*号代替，表示类名任意</li><li>在类名的部分，可以使用*号代替类名的一部分</li></ul><pre><code class="java">*Service</code></pre><p>上面例子表示匹配所有名称以Service结尾的类或接口 </p><ul><li>在方法名部分，可以使用*号表示方法名任意</li><li>在方法名部分，可以使用*号代替方法名的一部分</li></ul><pre><code class="java">*Operation</code></pre><p>上面例子表示匹配所有方法名以Operation结尾的方法 </p><ul><li>在方法参数列表部分，使用(..)表示参数列表任意</li><li>在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头</li><li>在方法参数列表部分，基本数据类型和对应的包装类型是不一样的<ul><li>切入点表达式中使用 int 和实际方法中 Integer 是不匹配的</li></ul></li><li>在方法返回值部分，如果想要明确指定一个返回值类型，那么权限修饰符不能使用 *</li></ul><pre><code class="java">execution(public int *..*Service.*(.., int))</code></pre><p>上面例子是对的，下面例子是错的：</p><pre><code class="java">execution(* int *..*Service.*(.., int))</code></pre><p>但是public *表示权限修饰符明确，返回值任意是可以的。</p><ul><li>对于execution()表达式整体可以使用三个逻辑运算符号<ul><li>execution() || execution()表示满足两个execution()中的任何一个即可</li><li>execution() &amp;&amp; execution()表示两个execution()表达式必须都满足</li><li>!execution()表示不满足表达式的其他方法</li></ul></li></ul><h6 id="4-2-3-总结"><a href="#4-2-3-总结" class="headerlink" title="4.2.3 总结"></a>4.2.3 总结</h6><p><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_015.png"></p><h4 id="5-环绕通知"><a href="#5-环绕通知" class="headerlink" title="5. 环绕通知"></a>5. 环绕通知</h4><p>环绕通知对应整个try…catch…finally结构，可以在目标方法的各个部位进行套用代理逻辑，它能够真正介入并改变目标方法的执行</p><pre><code class="java">@Around(&quot;com.atguigu.pointcut.AtguiguPointCut.calculatorPointCut()&quot;)public Object around(ProceedingJoinPoint proceedingJoinPoint)&#123;    try &#123;        System.out.println(&quot;开启事务....&quot;);        //环绕通知是可以介入到目标方法执行之前、返回值之前、出现异常之后、finally中等等各个部位执行        //环绕通知可以在目标方法执行之前做一些事情: 就相当于前置通知        //获取目标方法的参数        Object[] args = proceedingJoinPoint.getArgs();        //改变目标方法的参数: 例如要做一些统一的参数的处理逻辑        //args[0] = 2;        //args[1] = 4;        //这句代码就是执行目标方法:也就是在这里开始你就能介入目标方法        Object result = proceedingJoinPoint.proceed(args);        //改变目标方法的返回值:        //环绕通知可以在目标方法执行成功之后，做一些事情: 就相当于返回通知        //return 1000;        System.out.println(&quot;提交事务...&quot;);        return result;    &#125; catch (Throwable throwable) &#123;        throwable.printStackTrace();        System.out.println(&quot;回滚事务...&quot;);        //环绕通知可以在目标方法执行出现异常之后，做一些事情: 就相当于异常通知        throw new RuntimeException(throwable.getMessage());    &#125; finally &#123;        //环绕通知可以在目标方法执行成功或者出现异常之后，做一些事情: 就相当于后置通知        System.out.println(&quot;将连接恢复默认状态，归还连接...&quot;);    &#125;&#125;</code></pre><h4 id="6-切面的优先级-了解"><a href="#6-切面的优先级-了解" class="headerlink" title="6. 切面的优先级(了解)"></a>6. 切面的优先级(了解)</h4><h5 id="6-1-优先级的规则"><a href="#6-1-优先级的规则" class="headerlink" title="6.1 优先级的规则"></a>6.1 优先级的规则</h5><p>相同目标方法上同时存在多个切面时，切面的优先级控制切面的<strong>内外嵌套</strong>顺序。</p><ul><li>优先级高的切面：外面</li><li>优先级低的切面：里面</li></ul><p>使用@Order注解可以控制切面的优先级：</p><ul><li>@Order(较小的数)：优先级高</li><li>@Order(较大的数)：优先级低</li></ul><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_016.png" style="zoom:67%;"><h5 id="6-2-实际意义"><a href="#6-2-实际意义" class="headerlink" title="6.2 实际意义"></a>6.2 实际意义</h5><p>实际开发时，如果有多个切面嵌套的情况，要慎重考虑。例如：如果事务切面优先级高，那么在缓存中命中数据的情况下，事务切面的操作都浪费了。 </p><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_017.png" style="zoom:67%;"><p>此时应该将缓存切面的优先级提高，在事务操作之前先检查缓存中是否存在目标数据。 </p><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_018.png" style="zoom:67%;"><h4 id="7-CGLIB的动态代理"><a href="#7-CGLIB的动态代理" class="headerlink" title="7. CGLIB的动态代理"></a>7. CGLIB的动态代理</h4><h5 id="7-1-动态代理的分类"><a href="#7-1-动态代理的分类" class="headerlink" title="7.1 动态代理的分类"></a>7.1 动态代理的分类</h5><p>动态代理分成两种:</p><p>第一种是JDK内置的动态代理，这种动态代理需要被代理者实现接口，如果被代理者没有实现接口，那么则无法使用JDK的动态代理</p><p>第二种是CGLIB的动态代理，在被代理类没有实现任何接口的情况下，Spring会自动使用cglib技术实现代理。</p><h5 id="7-2-Debug查看"><a href="#7-2-Debug查看" class="headerlink" title="7.2 Debug查看"></a>7.2 Debug查看</h5><h6 id="7-2-1-没有实现接口情况"><a href="#7-2-1-没有实现接口情况" class="headerlink" title="7.2.1 没有实现接口情况"></a>7.2.1 没有实现接口情况</h6><p><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_019.png"></p><h6 id="7-2-2-有实现接口的情况"><a href="#7-2-2-有实现接口的情况" class="headerlink" title="7.2.2 有实现接口的情况"></a>7.2.2 有实现接口的情况</h6><p><img src="http://www.slx.blue/2021/12/07/spring-day03-AOP/tu_020.png"></p><h5 id="7-3-Spring中到底使用哪种动态代理"><a href="#7-3-Spring中到底使用哪种动态代理" class="headerlink" title="7.3 Spring中到底使用哪种动态代理"></a>7.3 Spring中到底使用哪种动态代理</h5><p>如果要创建代理对象的类实现了接口，那么就使用JDK的动态代理；如果要创建代理对象的类没有实现接口，那么就使用CGLIB的动态代理</p><h3 id="第三节-基于XML方式配置AOP"><a href="#第三节-基于XML方式配置AOP" class="headerlink" title="第三节 基于XML方式配置AOP"></a>第三节 基于XML方式配置AOP</h3><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h4><h5 id="1-1-加入依赖"><a href="#1-1-加入依赖" class="headerlink" title="1.1 加入依赖"></a>1.1 加入依赖</h5><p>和基于注解的AOP时一样。</p><h5 id="1-2-准备代码"><a href="#1-2-准备代码" class="headerlink" title="1.2 准备代码"></a>1.2 准备代码</h5><p>把基于注解的Module复制一份，修改Module名，并导入到工程中，然后去除所有AOP注解。</p><h4 id="2-配置Spring配置文件"><a href="#2-配置Spring配置文件" class="headerlink" title="2. 配置Spring配置文件"></a>2. 配置Spring配置文件</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/context                           https://www.springframework.org/schema/context/spring-context.xsd                           http://www.springframework.org/schema/aop                           https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!--包扫描--&gt;    &lt;context:component-scan base-package=&quot;com.atguigu&quot;/&gt;    &lt;!--        使用xml方式配置AOP:            1. 切面: 封装非核心逻辑的那个类，非核心逻辑就是封装在切面的方法中            2. 通知: 将非核心逻辑套在核心逻辑上进行执行            3. 切入点: 核心逻辑    --&gt;    &lt;aop:config&gt;        &lt;!--            1. 切面: ref属性就是指定作为切面的那个对象的id，order属性表示切面的优先级        --&gt;        &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;logAspect&quot;&gt;            &lt;!--2. 通知--&gt;            &lt;!--配置前置通知--&gt;            &lt;aop:before method=&quot;printLogBeforeCore&quot; pointcut-ref=&quot;calculatorPoint&quot;/&gt;            &lt;!--配置返回通知--&gt;            &lt;aop:after-returning method=&quot;printLogAfterReturning&quot; pointcut-ref=&quot;calculatorPoint&quot; returning=&quot;result&quot;/&gt;            &lt;!--配置异常通知--&gt;            &lt;aop:after-throwing method=&quot;printLogAfterThrowing&quot; pointcut-ref=&quot;calculatorPoint&quot; throwing=&quot;throwable&quot;/&gt;            &lt;!--配置后置通知--&gt;            &lt;aop:after method=&quot;printLogFinallyEnd&quot; pointcut-ref=&quot;calculatorPoint&quot;/&gt;            &lt;!--配置环绕通知--&gt;            &lt;aop:around method=&quot;printLogAround&quot; pointcut-ref=&quot;calculatorPoint&quot;/&gt;            &lt;!--3. 切入点--&gt;            &lt;aop:pointcut id=&quot;calculatorPoint&quot;                          expression=&quot;execution(* com.atguigu.component.CalculatorPureImpl.*(..))&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;</code></pre><h4 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h4><pre><code class="java">package com.atguigu;import com.atguigu.component.Calculator;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:spring-application.xml&quot;)public class TestAop &#123;    @Autowired    private Calculator calculator;    @Test    public void testAdd()&#123;        //调用CalculatorPureImpl对象的add()方法        System.out.println(&quot;调用完目标方法之后获取返回值是:&quot;+calculator.sub(5, 3));    &#125;&#125;</code></pre><h3 id="第四节-AOP总结"><a href="#第四节-AOP总结" class="headerlink" title="第四节 AOP总结"></a>第四节 AOP总结</h3><p>目标:</p><ol><li><p>将目标方法中的非核心业务抽取出来制作成通知</p></li><li><p>在调用目标方法的核心业务的时候，自动将非核心业务套在核心业务上执行</p></li></ol><p>实现目标:</p><ol><li><p>具备一双慧眼:能识别出来哪里可以抽取</p></li><li><p>准备一个切面类:<br>  2.1 IOC<br>  2.2 让它成为切面类</p></li><li><p>将抽取出来的代码封装成方法，方法放在切面类中</p></li><li><p>放切面类中的方法成为通知</p><ol><li>前置通知: Before</li><li>返回通知:AfterReturning</li><li>异常通知:AfterThrowing</li><li>后置通知:After</li><li>环绕通知Around</li></ol></li><li><p>指定通知的作用位置(切入点): 就是引用切入点</p><ol><li>如果切入点和和通知在同一个类中：根据方法名引用</li><li>如果切入点跟通知不在同一个类中: 根据类的全限定名.方法名来引用</li></ol></li><li><p>声明切入点以及切入点的语法</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java设计模式-代理模式</title>
      <link href="/2021/12/06/java-Proxy/"/>
      <url>/2021/12/06/java-Proxy/</url>
      
        <content type="html"><![CDATA[<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="基本介绍："><a href="#基本介绍：" class="headerlink" title="基本介绍："></a>基本介绍：</h4><ol><li>代理模式：为一个对象提供一个替身，以控制对这个对象的访问(被代理的对象)。即通过代理对象访问目标对象，这样的好处是可以再目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。</li><li>被代理的对象可以是远程对象、创建开销大的对象或者需要安全控制的对象</li><li>代理模式有三种不同的形式，主要有三种 <ul><li><strong>静态</strong>代理 </li><li><strong>动态</strong>代理(<code>JDK</code>代理，接口代理) </li><li><code>Cglib</code>代理(可以再内存动态的创建对象，而不需要实现接口，属于<strong>动态代理</strong>的范畴)</li></ul></li></ol><h4 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1.静态代理"></a>1.静态代理</h4><p>静态代理在使用时，需要定义接口或者父类(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类</p><p>用例图：</p><p><img src="http://www.slx.blue/2021/12/06/java-Proxy/staticProxy.png" alt="image"></p><p>代码实现：</p><pre><code class="java">//接口public interface ITeacherDao &#123;    void teach(); // 授课的方法&#125;</code></pre><pre><code class="java">//实现方法public class TeacherDao implements ITeacherDao &#123;    @Override    public void teach() &#123;        System.out.println(&quot; 老师授课中  。。。。。&quot;);    &#125;&#125;</code></pre><pre><code class="java">//代理对象,静态代理public class TeacherDaoProxy implements ITeacherDao&#123;        private ITeacherDao target; // 目标对象，通过接口来聚合    //构造器    public TeacherDaoProxy(ITeacherDao target) &#123;        this.target = target;    &#125;    @Override    public void teach() &#123;        System.out.println(&quot;开始代理  完成某些操作。。。。。 &quot;);//方法        target.teach();        System.out.println(&quot;提交。。。。。&quot;);//方法    &#125;&#125;</code></pre><pre><code class="java">//客户端public class Client &#123;    public static void main(String[] args) &#123;        //创建目标对象(被代理对象)        TeacherDao teacherDao = new TeacherDao();                //创建代理对象, 同时将被代理对象传递给代理对象        TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao);                //通过代理对象，调用到被代理对象的方法        //即：执行的是代理对象的方法，代理对象再去调用目标对象的方法         teacherDaoProxy.teach();    &#125;&#125;</code></pre><p>静态代理优缺点：</p><ol><li>优点‘：在不修改目标对象的功能前提下，能通过代理对象对目标功能进行扩展</li><li>缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类</li><li>一旦接口增加方法，目标对象与代理对象都要维护</li></ol><h4 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2.动态代理"></a>2.动态代理</h4><p>基本介绍</p><ol><li>代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理</li><li>代理对象的生成，是利用<code>JDK</code>的<code>API</code>，动态的在内存中构建代理对象</li><li>动态代理也叫：<code>JDK</code>代理，接口代理</li></ol><p><code>JDK</code>中生成代理对象的<code>API</code></p><ol><li><p>代理类所在包：<code>java.lang.reflect.Proxy</code></p></li><li><p><code>JDK</code>实现代理类只需要使用<code>newProxyInstance</code>方法，但是该方法需要接收三个参数，完整方法为</p></li></ol><blockquote><pre><code>public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code></pre></blockquote><p><img src="http://www.slx.blue/2021/12/06/java-Proxy/dynamic.png" alt="dynamic"></p><p>代码实现</p><pre><code class="java">//接口public interface ITeacherDao &#123;    void teach(); // 授课方法    void sayHello(String name);&#125;</code></pre><pre><code class="java">//实现类public class TeacherDao implements ITeacherDao &#123;    @Override    public void teach() &#123;        System.out.println(&quot; 老师授课中.... &quot;);    &#125;    @Override    public void sayHello(String name) &#123;        System.out.println(&quot;hello &quot; + name);    &#125;&#125;</code></pre><pre><code class="java">public class ProxyFactory&lt;T&gt; &#123;    //目标对象 , Object    private T target;    //构造器传入 ， 对target 进行初始化    public ProxyFactory(T target) &#123;        this.target = target;    &#125;    //给目标对象 生成一个代理对象    public T getProxyInstance() &#123;        //说明        /*         *  public static Object newProxyInstance(ClassLoader loader,                                          Class&lt;?&gt;[] interfaces,                                          InvocationHandler h)                                                      //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定            //2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型            //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法,            // 会把当前执行的目标对象方法作为参数传入         */        return (T) Proxy.newProxyInstance(                target.getClass().getClassLoader(),  //构建代理对象的类加载器 反射                target.getClass().getInterfaces(),                new InvocationHandler() &#123;                    @Override                    public Object invoke(Object proxy,                                         Method method,                                          Object[] args) throws Throwable &#123;                        //invoke方法的作用是执行具体的代理逻辑                         //也就是代理对象调用任意方法都会执行invoke                        //参数一 proxy: 代理对象本身                        //参数二 method : 代理对象调用的方法                        //参数三 args : 代理对象调用方法时传入的参数                        //返回值表示代理对象调用方法所受到的返回值                        //此时创建的代理对象可以代理任意借口 如果想只代理对应方法                        String name = method.getName();                        //可以获取代理对象的方法名做if判断 进行核心逻辑判断 是否要代理                        if (!name.equals(&quot;&quot;))&#123;                            System.out.println(&quot;执行了对应方法&quot;);                            System.out.println(&quot;方法执行前 代理开始了 &quot;);                            //反射机制调用目标对象的方法                            Object returnVal = method.invoke(target, args);                            System.out.println(&quot;方法执行后 代理又开始了&quot;);                            return returnVal;                        &#125;                        //方法不需要代理                        return method.invoke(target,args);                    &#125;                &#125;);    &#125;&#125;</code></pre><pre><code class="java">//客户端public class Client &#123;    public static void main(String[] args) &#123;        //创建目标对象        ITeacherDao target = new TeacherDao();                //给目标对象，创建代理对象, 可以转成 ITeacherDao//        ProxyFactory&lt;ITeacherDao&gt; factory = new ProxyFactory&lt;&gt;(target);//        ITeacherDao proxyInstanceDao = factory.getProxyInstance();        ITeacherDao proxyInstance =             new ProxyFactory&lt;ITeacherDao&gt;(target).getProxyInstance();//直接获取代理对象        // proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象        System.out.println(&quot;proxyInstance=&quot; + proxyInstance.getClass());                //通过代理对象，调用目标对象的方法        //proxyInstance.teach();        proxyInstance.sayHello(&quot; 龙龙龙 &quot;);    &#125;&#125;</code></pre><h4 id="3-Cglib代理"><a href="#3-Cglib代理" class="headerlink" title="3.Cglib代理"></a>3.Cglib代理</h4><p>基本介绍：</p><ol><li><p>静态代理和<code>JDK</code>代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实<br>现任何的接口,这个时候可使用目标对象子类来实现代理-这就是<code>Cglib</code>代理</p></li><li><p>Cglib代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展，有些书也将Cglib代<br>理归属到动态代理。</p></li><li><p><code>Cglib</code>是一个强大的高性能的代码生成包,它可以在运行期扩展<code>java</code>类与实现<code>java</code>接口.它广泛的被许多<code>AOP</code>的<br>框架使用,例如Spring <code>AOP</code>，实现方法拦截</p></li><li><p>在<code>AOP</code>编程中如何选择代理模式:</p><ul><li>目标对象需要实现接口，用<code>JDK</code>代理</li><li>目标对象不需要实现接口，用<code>Cglib</code>代理</li></ul></li><li><p><code>Cglib</code>包的底层是通过使用字节码处理框架<code>ASM</code>来转换字节码并生成新的类</p></li></ol><p>设计类图：</p><p><img src="http://www.slx.blue/2021/12/06/java-Proxy/cglib.png" alt="dynamic"></p><p>代码实现</p><pre><code class="java">//被代理对象public class TeacherDao &#123;    public String teach() &#123;        System.out.println(&quot; 老师授课中  ， 我是cglib代理，不需要实现接口 &quot;);        return &quot;hello&quot;;    &#125;&#125;</code></pre><pre><code class="java">//代理工厂public class ProxyFactory implements MethodInterceptor &#123;    //维护一个目标对象    private Object target;        //构造器，传入一个被代理的对象    public ProxyFactory(Object target) &#123;        this.target = target;    &#125;    //返回一个代理对象:  是 target 对象的代理对象    public Object getProxyInstance() &#123;        //1. 创建一个工具类        Enhancer enhancer = new Enhancer();        //2. 设置父类        enhancer.setSuperclass(target.getClass());        //3. 设置回调函数        enhancer.setCallback(this);        //4. 创建子类对象，即代理对象        return enhancer.create();    &#125;        //重写  intercept 方法，会调用目标对象的方法    @Override    public Object intercept(Object arg0,                            Method method,                             Object[] args,                             MethodProxy arg3) throws Throwable &#123;        System.out.println(&quot;Cglib代理模式 ~~ 开始&quot;);        Object returnVal = method.invoke(target, args);        System.out.println(&quot;Cglib代理模式 ~~ 提交&quot;);        return returnVal;    &#125;&#125;</code></pre><pre><code class="java">//客户端public class Client &#123;    public static void main(String[] args) &#123;        //创建目标对象        TeacherDao target = new TeacherDao();        //获取到代理对象，并且将目标对象传递给代理对象        TeacherDao proxyInstance = (TeacherDao)new ProxyFactory(target).getProxyInstance();        //执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用        String res = proxyInstance.teach();        System.out.println(&quot;res=&quot; + res);    &#125;&#125;</code></pre><h4 id="4-其他变体"><a href="#4-其他变体" class="headerlink" title="4.其他变体"></a>4.其他变体</h4><p>几种常见的代理模式介绍一几种变体</p><ol><li>防火墙代理：内网通过代理穿透防火墙，实现对公网的访问。</li><li>缓存代理：比如 当请求图片文件等资源时，先到缓存代理取，如果取到资源则ok,如果取不到资源，再到公网或者数据库取，然后缓存。</li><li>远程代理：远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。</li><li>同步代理:主要使用在多线程编程中，完成多线程间同步工作</li></ol>]]></content>
      
      
      <categories>
          
          <category> designMode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java设计模式-单例模式</title>
      <link href="/2021/12/06/java-singleton/"/>
      <url>/2021/12/06/java-singleton/</url>
      
        <content type="html"><![CDATA[<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式有八种方式：</p><pre><code>饿汉式(静态常量实例化)饿汉式(静态代码块实例化)懒汉式(线程不安全)懒汉式(线程安全同步方法)懒汉式(同步代码块 ，写法错误) 并不能实现线程安全双重检查静态内部类枚举</code></pre><h4 id="饿汉式-静态常量"><a href="#饿汉式-静态常量" class="headerlink" title="饿汉式(静态常量)"></a>饿汉式(静态常量)</h4><pre><code class="java">class Singleton&#123;    //构造器私有化 外部能new    private Singleton()&#123;          &#125;    //本类内部创建对象实例    private final static Singleton instance = new Singleton();    //提供一个共有的静态方法 返回实例对象    public static Singleton getInstance()&#123;        return instance;    &#125;&#125;/*    写法较为简单，在类转载的时候就完成了实例化，避免了线程同步的问题。    缺点是在类装载的时候就完成实例化，没有达到懒加载的效果(Lazy Loading)。    如果从始至终从未使用过这个实例，则会造成内存浪费，    这种基于类加载机制避免了多线程同步的问题，不过instance在类装载的时候就完成实例化，    在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，    因此不能确定有其他的方式导致类装载，这个时候初始化instance就没有达到懒加载的效果    这种单例模式可以用，有可能造成内存浪    费*/</code></pre><h4 id="饿汉式-静态代码块"><a href="#饿汉式-静态代码块" class="headerlink" title="饿汉式(静态代码块)"></a>饿汉式(静态代码块)</h4><pre><code class="java">class Singleton&#123;    //构造器私有化 外部能new    private Singleton()&#123;&#125;    //本类内部创建对象实例    private  static Singleton instance ;    static&#123;        instance = new Singleton();    &#125;    //提供一个共有的静态方法 返回实例对象    public static Singleton getInstance()&#123;        return instance;    &#125;    //和静态常量类似，在静态代码块完成实例化。 优缺点也和饿汉式静态常量一样&#125;</code></pre><h4 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式(线程不安全)"></a>懒汉式(线程不安全)</h4><pre><code class="java">class Singleton&#123;    private static Singleton instance;    private Singleton()&#123;&#125;    //提供一个静态方法，当使用这个方法的时候才实例化    //懒汉式(线程不安全)    public static Singleton getInstance()&#123;        if (instance == null)&#123;            instance = new Singleton();        &#125;        return instance;    &#125;&#125;/*    小结：    1.起到了懒加载的效果，但是只能在多线程下才能使用    2.如果在多线程下 会导致线程不安全 一个线程进入if语句还没执行完 另一个线程也进来了 就会产生多个实例    3.在实际开发中 不要使用这种方式*/</code></pre><h4 id="懒汉式-线程安全"><a href="#懒汉式-线程安全" class="headerlink" title="懒汉式(线程安全)"></a>懒汉式(线程安全)</h4><pre><code class="java">class Singleton&#123;    private static Singleton instance;    private Singleton()&#123;&#125;    //提供一个静态方法，加入同步处理的代码，解决了线程安全问题    //懒汉式(线程安全)    public static synchronized Singleton getInstance()&#123;        if (instance == null)&#123;            //synchronized(Singleton.class)&#123;             //锁放在这里 并不能实现线程安全 因为线程进了if语句 迟早会执行                    instance = new Singleton();            //&#125;            &#125;        return instance;    &#125;&#125;/*    小结：    1.解决了线程不安全问题    2.效率太低了，每个线程想获得类的实例的时候 执行getInstance()方法都要进行同步。    而其实这个方法只执行一次实例化就够了，后面想要获得该实例应该是直接return，方法进行同步效率太低    3.在实际开发中 不要使用这种方式*/</code></pre><h4 id="双重检查-推荐"><a href="#双重检查-推荐" class="headerlink" title="双重检查(推荐)"></a>双重检查(推荐)</h4><pre><code class="java">class Singleton&#123;    private static volatile Singleton singleton;    private Singleton()&#123;&#125;    public static Singleton getInstance()&#123;        //双重检查        //提供一个静态的共有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题        if (singleton == null)&#123;            synchronized (Singleton.class)&#123;                if (singleton == null)&#123;                    singleton = new Singleton();                &#125;            &#125;        &#125;        return singleton;    &#125;&#125;/*    小结：    1.双重检查 判断了两次singleton == null 就可以保证线程安全    2.实例化代码只用执行一次 后面再次访问 的时候 如果不为空 就可以直接返回实例化对象 避免了方法反复同步    3.线程安全：实现了懒加载，效率较高    在实际开发中 推荐使用这种单例设计模式*/</code></pre><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><pre><code class="java">class Singleton&#123;    private static volatile Singleton instance;    //　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，    //当有其他线程需要读取时，它会去内存中读取新值。 保证了 可见性。    // 满足并发编程安全的三大特性 原子性 可见性 有序性    //构造器私有化    private Singleton()&#123;&#125;    //写一个静态内部类，该类中有一个静态属性Singleton    private static class SingletonInstance&#123;        private static final Singleton INSTANCE = new Singleton();    &#125;            //提供一个静态方法，直接返回SingletonInstance.INSTANCE    public static synchronized Singleton getInstance()&#123;        return SingletonInstance.INSTANCE;    &#125;&#125;/*小结:    1.这种方式采用的类装载机制来保证初始化实例只有一个线程    2.静态内部类方式在Singleton类被加载的时候并不会立即实例化，而是在需要实例化的时候，    调用getInstacne方法，才会装在SingleInstance类，从而完成Singeleton的实例化    3.类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，    在类进行初始化的时候，别的线程是无法进入的。    4.避免了线程不安全，利用静态内部类特点实现了延迟加载，效率高。    在工作中推荐使用*/</code></pre><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><pre><code class="java">enum  Singleton&#123;   INSTANCE;   public void sayOK()&#123;       System.out.println(&quot;ok~~~&quot;);   &#125;&#125;/*        小结        1.这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，        而且还能防止反序列化重新创建新的对象。        2.这种方式是Effective Jaca坐着Josh Bloch提倡的方式        推荐使用*/</code></pre><p>单例模式注意事项和细节说明：</p><p>1)单例模式保证了系统内存中 该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可提高系统的性能<br>2）当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是直接使用new<br>3）单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或者耗费资源过多（即重量级对象），但又经常用到的对象，工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等）</p><pre><code class="java">如果确定实例一定会使用 饿汉式是可以使用的 只是有可能会造成内存浪费 比如java的Runtime中就用了饿汉式 推荐使用： 双重检查、静态内部类、枚举</code></pre>]]></content>
      
      
      <categories>
          
          <category> designMode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java设计模式-七大原则</title>
      <link href="/2021/12/06/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2021/12/06/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h1><p>设计原则核心思想:</p><ol><li><p>找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码放在一起。</p></li><li><p> 针对接口编程，而不是针对实现编程。</p></li><li><p>为了交互对象之间的松耦合设计努力  </p></li></ol><pre><code>设计模式常见的七大原则：1)单一职责原则2)接口隔离原则3)依赖倒置原则4)里式替换原则5)开闭原则6)迪米特原则7)合成复用原则</code></pre><ol><li><p>代码重用性</p></li><li><p>可读性</p></li><li><p>可扩展性</p></li><li><p>可靠性</p></li><li><p>高内聚低耦合</p></li></ol><h2 id="单一隔离"><a href="#单一隔离" class="headerlink" title="单一隔离"></a>单一隔离</h2><pre><code>原则上 一个类应该尽量做一件事 一个类继承一个接口 如果实现类两个职责 当职责一进行修改的时候 很可能回对职责二造成影响但是一个类继承一个接口会导致开销过大在接口方法比较少的情况下可以 通过向下兼容 实现方法的单一职责</code></pre><h2 id="接口隔离"><a href="#接口隔离" class="headerlink" title="接口隔离"></a>接口隔离</h2><pre><code>如果一个接口方法过多，实现该接口就会需要去实现很多不需要实现的方法。这个时候我们就应该把接口进行拆分，去实现需要实现的接口即可。</code></pre><h2 id="依赖倒转-倒置"><a href="#依赖倒转-倒置" class="headerlink" title="依赖倒转(倒置)"></a>依赖倒转(倒置)</h2><pre><code>接口和抽象类的价值在于 设计高层模块不应该依赖于底层模块抽象不应该依赖细节，细节应该依赖抽象面向接口编程传递的三种方式1.构造器传递2.set接口传递3.接口传递使用接口或者抽象类的目的是制定好规范。而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成多了一个缓冲利于程序的扩展和优化</code></pre><h2 id="里式替换原则"><a href="#里式替换原则" class="headerlink" title="里式替换原则"></a>里式替换原则</h2><pre><code>问题：在编程中如何正确的实现继承   尽量满足里式替换原则 子类尽量不要重写父类的方法做到透明使用 如果子类想使用父类的方法 ，但是有可能会不小心重写了父类的方法 倒是一系列应用 带来了程序的入侵性所以可以 子类和父类都继承一个新的base类，base类实现了更为基础的代码和方法这样子类可以放心的重写方法达到的效果是 所有应用基类的类应该尽量做到透明使用</code></pre><p>​    </p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><pre><code>开闭原则是编程中 最基础最重要的原则一个软件实体类 模块和函数应该对外扩展开放(对提供方) 对修改关闭(对使用方)  用抽象构建，用实现扩展细节当我们增加一个功能时候 应该增加代码而不是修改代码 尽量不去修改原有的代码 当软件需要变化时 尽量通过扩展软件实体的行为来实现变化 而不是通过修改已有的代码来实现变化编程中遵循其他原则以及使用设计模式的目的就是遵循开闭原则改进思路分析 把创建的Shape类做成抽象类或者接口，并提供一个抽象的draw方法或者接口，让子类去实现即可。这样有新的图形种类时候 只需要让新的图形去继承Shape 并且实现draw方法即可，这样使用方的代码就不需要修改满足了开闭原则</code></pre><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><pre><code>一个对象应该对其他的对象保持最少的了解类与类之间的关系越密切，耦合度越大一个类里面 除了传递参数依赖类 应该尽量避免出现其他的陌生类，降低耦合度 这样代码修改起来容易</code></pre><h2 id="合成服用原则"><a href="#合成服用原则" class="headerlink" title="合成服用原则"></a>合成服用原则</h2><pre><code>原则是尽量使用合成/聚合 而不是使用继承B要想使用A的方法，可以继承于A 但是这样会导致关系太强 耦合度太高组合： 让B 里面注入一个A 聚合:  让B里面 set 一个A 或者构造器依赖： 在B里面把A传进来 称之为B依赖A 方法</code></pre><h1 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h1><pre><code>设计模式分为三种类型，共23种1、创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式2、适配器模式：桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式3、行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式</code></pre>]]></content>
      
      
      <categories>
          
          <category> designMode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-day02-annotation</title>
      <link href="/2021/12/06/spring-day02/"/>
      <url>/2021/12/06/spring-day02/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-day02"><a href="#spring-day02" class="headerlink" title="spring-day02"></a>spring-day02</h1><h2 id="第一章-基于注解管理bean"><a href="#第一章-基于注解管理bean" class="headerlink" title="第一章 基于注解管理bean"></a>第一章 基于注解管理bean</h2><h3 id="第一节-IOC的相关注解及包扫描"><a href="#第一节-IOC的相关注解及包扫描" class="headerlink" title="第一节 IOC的相关注解及包扫描"></a>第一节 IOC的相关注解及包扫描</h3><h4 id="1-注解的优势"><a href="#1-注解的优势" class="headerlink" title="1. 注解的优势"></a>1. 注解的优势</h4><p>和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。使用注解开发比使用XML更加简洁明了</p><h4 id="2-包扫描"><a href="#2-包扫描" class="headerlink" title="2. 包扫描"></a>2. 包扫描</h4><p>使用注解进行Bean管理必须要在xml配置文件中进行包扫描，这样的话spring-framework才能够解析你在Bean上所添加的注解，包扫描包含下面列举的四种情况:</p><h5 id="2-1-最基本的扫描方式-常用"><a href="#2-1-最基本的扫描方式-常用" class="headerlink" title="2.1 最基本的扫描方式[常用]"></a>2.1 最基本的扫描方式[常用]</h5><p>扫描指定包下的所有类以及其子包下的所有类</p><pre><code class="xml">&lt;!-- 配置自动扫描的包 --&gt;&lt;!-- 最基本的扫描方式 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu.ioc.component&quot;/&gt;</code></pre><h5 id="2-2-指定匹配模式"><a href="#2-2-指定匹配模式" class="headerlink" title="2.2 指定匹配模式"></a>2.2 指定匹配模式</h5><p>根据具体的匹配规则，扫描某个包下的某些类，需要注意规则匹配是匹配的直接在这个包下的类，不能是子包下的类</p><pre><code class="xml">&lt;!-- 情况二：在指定扫描包的基础上指定匹配模式 --&gt;&lt;context:component-scan                        base-package=&quot;com.atguigu.ioc.component&quot;                        resource-pattern=&quot;Soldier*.class&quot;/&gt;</code></pre><h5 id="2-3-指定要排除的组件"><a href="#2-3-指定要排除的组件" class="headerlink" title="2.3 指定要排除的组件"></a>2.3 指定要排除的组件</h5><p>扫描某个包下的所有类，但是排除掉一些注解</p><pre><code class="xml">&lt;!-- 情况三：指定不扫描的组件 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu.ioc.component&quot;&gt;        &lt;!-- context:exclude-filter标签：指定排除规则 --&gt;    &lt;!-- type属性：指定根据什么来进行排除，annotation取值表示根据注解来排除 --&gt;    &lt;!-- expression属性：指定排除规则的表达式，对于注解来说指定全类名即可 --&gt;    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt;</code></pre><h5 id="2-4-仅扫描指定组件"><a href="#2-4-仅扫描指定组件" class="headerlink" title="2.4 仅扫描指定组件"></a>2.4 仅扫描指定组件</h5><p>扫描某个包下的所有类，但是只扫描某种注解</p><pre><code class="xml">&lt;!-- 情况四：仅扫描指定的组件 --&gt;&lt;!-- 仅扫描 = 关闭默认规则 + 追加规则 --&gt;&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu.ioc.component&quot; use-default-filters=&quot;false&quot;&gt;        &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt;</code></pre><h4 id="3-常用的进行IOC的注解"><a href="#3-常用的进行IOC的注解" class="headerlink" title="3. 常用的进行IOC的注解"></a>3. 常用的进行IOC的注解</h4><p>我们在类上添加注解，可以实现将该类的对象配置到spring的IOC容器中，常用的注解有如下四种:</p><h5 id="3-1-Component注解"><a href="#3-1-Component注解" class="headerlink" title="3.1 Component注解"></a>3.1 Component注解</h5><p>该注解主要用在普通类上，即除了三层结构之外的其它类的对象如果需要配置到spring的IOC容器中，那么则需要在类上添加Component注解</p><pre><code class="java">package com.atguigu.ioc.component;import org.springframework.stereotype.Component;@Componentpublic class CommonComponent &#123;&#125;</code></pre><h5 id="3-2-Controller注解"><a href="#3-2-Controller注解" class="headerlink" title="3.2 Controller注解"></a>3.2 Controller注解</h5><p>该注解主要用在控制层的类上，控制器处于三层结构中的表现层，在JavaWeb阶段表现层使用的是Servlet，而在学习了spring-framework之后，表现层我们使用Controller代替</p><pre><code class="java">package com.atguigu.ioc.component;import org.springframework.stereotype.Controller;@Controllerpublic class SoldierController &#123;&#125;</code></pre><h5 id="3-3-Service注解"><a href="#3-3-Service注解" class="headerlink" title="3.3 Service注解"></a>3.3 Service注解</h5><p>该注解主要用在三层结构中的业务层的实现类上，用于将业务层的对象配置到spring的IOC容器中</p><pre><code class="java">package com.atguigu.ioc.component;import org.springframework.stereotype.Service;@Servicepublic class SoldierService implements ISoldierService&#123;&#125;</code></pre><h5 id="3-4-Repository注解"><a href="#3-4-Repository注解" class="headerlink" title="3.4 Repository注解"></a>3.4 Repository注解</h5><p>该注解主要用在三层结构中的持久层的实现类上，用于将持久层的对象配置到spring的IOC容器中，但是以后我们整合了Mybatis，这里就变成了Mapper接口，而Mapper接口是由Mybatis和Spring的整合包负责扫描的。由于Mybatis整合包想要把Mapper接口背后的代理类加入Spring的IOC容器需要结合Mybatis对Mapper配置文件的解析，所以这个事情是Mybatis和Spring的整合包来完成，将来由Mybatis负责扫描，也不需要使用Repository注解。</p><pre><code class="java">package com.atguigu.ioc.component;import org.springframework.stereotype.Repository;@Repositorypublic class SoldierDao implements ISoldierDao&#123;&#125;</code></pre><p>虽然我们学习的上述四个注解都实现IOC，但是其实他们四个在本质上是没有区别的。通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是在@Component注解的基础上起了三个新的名字。对于Spring使用IOC容器管理这些组件来说没有区别。所以@Controller、@Service、@Repository这三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。</p><p>注意：虽然它们本质上一样，但是为了代码的可读性，为了程序结构严谨我们肯定不能随便胡乱标记。</p><p><img src="http://www.slx.blue/2021/12/06/spring-day02/tu_001.png"></p><h4 id="4-给Bean设置name"><a href="#4-给Bean设置name" class="headerlink" title="4. 给Bean设置name"></a>4. 给Bean设置name</h4><p>在我们使用XML方式管理bean的时候，每个bean都有一个唯一标识，便于在其他地方引用。现在使用注解后，每个组件仍然应该有一个唯一标识。 </p><h5 id="4-1-默认情况"><a href="#4-1-默认情况" class="headerlink" title="4.1 默认情况"></a>4.1 默认情况</h5><p>类名首字母小写就是bean的id。例如：SoldierController类对应的bean的id就是soldierController。 </p><h5 id="4-2-使用value属性指定"><a href="#4-2-使用value属性指定" class="headerlink" title="4.2 使用value属性指定"></a>4.2 使用value属性指定</h5><pre><code class="java">@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123;&#125;</code></pre><p>当注解中只设置一个属性时，value属性的属性名可以省略： </p><pre><code class="java">@Controller(&quot;tianDog&quot;)public class SoldierController &#123;&#125;</code></pre><h4 id="5-怎么选择"><a href="#5-怎么选择" class="headerlink" title="5. 怎么选择"></a>5. 怎么选择</h4><ol><li>如果这个类是你自己写的类，表示你可以在它上面加注解，所以可以使用注解方式进行IOC</li><li>如果这个类不是你自己写的类，而是第三方依赖中的类，表示你不能在它上面加注解，那么就只能用配置文件方式进行IOC</li></ol><h3 id="第二节-依赖注入相关的注解"><a href="#第二节-依赖注入相关的注解" class="headerlink" title="第二节 依赖注入相关的注解"></a>第二节 依赖注入相关的注解</h3><h4 id="2-1-注入简单类型的属性"><a href="#2-1-注入简单类型的属性" class="headerlink" title="2.1 注入简单类型的属性"></a>2.1 注入简单类型的属性</h4><p>Value注解是用于给IOC容器中的Bean注入简单类型的属性值</p><pre><code class="java">@Service(&quot;smallDog&quot;)public class SoldierService &#123;    @Value(&quot;aobama&quot;)    private String name;    &#125;</code></pre><h4 id="2-2-读取properties中的数据并且进行注入"><a href="#2-2-读取properties中的数据并且进行注入" class="headerlink" title="2.2 读取properties中的数据并且进行注入"></a>2.2 读取properties中的数据并且进行注入</h4><h5 id="2-2-1-准备properties配置文件"><a href="#2-2-1-准备properties配置文件" class="headerlink" title="2.2.1 准备properties配置文件"></a>2.2.1 准备properties配置文件</h5><p>happyInfo.properties</p><pre><code class="properties">happy.componentName=aoalfu</code></pre><h5 id="2-2-2-使用PropertySource注解读取配置文件数据"><a href="#2-2-2-使用PropertySource注解读取配置文件数据" class="headerlink" title="2.2.2 使用PropertySource注解读取配置文件数据"></a>2.2.2 使用PropertySource注解读取配置文件数据</h5><pre><code class="java">package com.atguigu.component;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;/** * 当注解中只有一个属性需要赋值，并且这个属性的名字叫&quot;value&quot;的时候，可以省略&quot;value = &quot; */@Component(&quot;happyComponent&quot;)@PropertySource(&quot;classpath:happyInfo.properties&quot;)public class HappyComponent &#123;    @Value(&quot;$&#123;happy.componentName&#125;&quot;)    private String componentName;    public String getComponentName() &#123;        return componentName;    &#125;&#125;</code></pre><h4 id="2-3-注入Bean类型属性"><a href="#2-3-注入Bean类型属性" class="headerlink" title="2.3 注入Bean类型属性"></a>2.3 注入Bean类型属性</h4><h5 id="2-3-1-设定情景"><a href="#2-3-1-设定情景" class="headerlink" title="2.3.1 设定情景"></a>2.3.1 设定情景</h5><ul><li>UserController需要UserService</li><li>UserService需要UserDao</li><li>UserDao需要HappyComponent</li><li>HappyComponent需要componentName</li></ul><p>同时在各个组件中声明要调用的方法。 </p><h5 id="2-3-2-在各个组件中声明成员变量和方法"><a href="#2-3-2-在各个组件中声明成员变量和方法" class="headerlink" title="2.3.2 在各个组件中声明成员变量和方法"></a>2.3.2 在各个组件中声明成员变量和方法</h5><h6 id="2-3-2-1-UserController"><a href="#2-3-2-1-UserController" class="headerlink" title="2.3.2.1 UserController"></a>2.3.2.1 UserController</h6><pre><code class="java">package com.atguigu.controller;import com.atguigu.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;/** * 为了规范代码，提高代码的可读性，三层结构中不同层次的类使用不同的IOC注解 * 1. Controller注解使用在表现层 * 2. Service注解使用在业务层 * 3. Repository注解使用在持久层 * 4. Component注解使用在三层结构之外的类上 * * 依赖注入的注解: * 1. Autowired注解: 表示自动装配,它只能用于注入Bean类型的对象 * 2. Value注解: 注入简单类型的值 */@Controller(&quot;userController&quot;)public class UserController &#123;    private UserService userService;    public void printName()&#123;        System.out.println(&quot;打印:&quot; + userService.getName());    &#125;&#125;</code></pre><h6 id="2-3-2-2-UserServiceImpl"><a href="#2-3-2-2-UserServiceImpl" class="headerlink" title="2.3.2.2 UserServiceImpl"></a>2.3.2.2 UserServiceImpl</h6><pre><code class="java">package com.atguigu.service.impl;import com.atguigu.dao.UserDao;import com.atguigu.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * 包名:com.atguigu.service.impl */@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService &#123;    private UserDao userDao;    @Override    public String getName() &#123;        return userDao.getName();    &#125;&#125;</code></pre><h6 id="2-3-2-3-UserDaoImpl"><a href="#2-3-2-3-UserDaoImpl" class="headerlink" title="2.3.2.3 UserDaoImpl"></a>2.3.2.3 UserDaoImpl</h6><pre><code class="java">package com.atguigu.dao.impl;import com.atguigu.component.HappyComponent;import com.atguigu.dao.UserDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;/** * 包名:com.atguigu.dao.impl */@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123;    private HappyComponent happyComponent;    @Override    public String getName() &#123;        //按道理来说要执行SQL语句到数据查询数据        //但是今天通过依赖注入，模拟从数据库查询到name        return happyComponent.getComponentName();    &#125;&#125;</code></pre><h6 id="2-3-2-4-HappyComponent"><a href="#2-3-2-4-HappyComponent" class="headerlink" title="2.3.2.4 HappyComponent"></a>2.3.2.4 HappyComponent</h6><pre><code class="java">package com.atguigu.component;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;/** * 当注解中只有一个属性需要赋值，并且这个属性的名字叫&quot;value&quot;的时候，可以省略&quot;value = &quot; */@Component(&quot;happyComponent&quot;)public class HappyComponent &#123;    private String componentName;    public String getComponentName() &#123;        return componentName;    &#125;&#125;</code></pre><h5 id="2-3-3-使用Autowired注解进行注入"><a href="#2-3-3-使用Autowired注解进行注入" class="headerlink" title="2.3.3 使用Autowired注解进行注入"></a>2.3.3 使用Autowired注解进行注入</h5><h6 id="2-3-3-1-Autowired注解可以使用的位置"><a href="#2-3-3-1-Autowired注解可以使用的位置" class="headerlink" title="2.3.3.1 Autowired注解可以使用的位置"></a>2.3.3.1 Autowired注解可以使用的位置</h6><ol><li><p>用在成员变量上(最常用)</p><pre><code class="java">package com.atguigu.controller;import org.springframework.stereotype.Controller;@Controllerpublic class UserController &#123;    @Autowired    private UserService userService;    public void printName()&#123;        System.out.println(&quot;打印:&quot; + userService.getName());    &#125;&#125;</code></pre></li><li><p>用在构造器上</p><pre><code class="java">@Controllerpublic class UserController &#123;    private UserService userService;    @Autowired    public UserController(UserService userService) &#123;        this.userService = userService;    &#125;&#125;</code></pre></li><li><p>用在方法上</p><pre><code class="java">@Controllerpublic class UserController &#123;    private UserService userService;    @Autowired    public void setUserService((UserService userService) &#123;        this.userService = userService;    &#125;&#125;</code></pre></li><li><p>用在参数上</p><pre><code class="java">@Controllerpublic class UserController &#123;    private UserService userService;    public UserController(@Autowired UserService userService) &#123;        this.userService = userService;    &#125;&#125;</code></pre><h6 id="2-3-3-2-Autowired工作流程"><a href="#2-3-3-2-Autowired工作流程" class="headerlink" title="2.3.3.2 Autowired工作流程"></a>2.3.3.2 Autowired工作流程</h6><p><img src="http://www.slx.blue/2021/12/06/spring-day02/tu_002.png"></p></li></ol><p>首先根据所需要的组件类型到IOC容器中查找</p><ul><li>能够找到唯一的bean：直接执行装配</li><li>如果完全找不到匹配这个类型的bean：装配失败</li><li>和所需类型匹配的bean不止一个<ul><li>没有@Qualifier注解：根据@Autowired标记位置成员变量的变量名作为bean的id进行匹配<ul><li>能够找到：执行装配</li><li>找不到：装配失败</li></ul></li><li>使用@Qualifier注解：根据@Qualifier注解中指定的名称作为bean的id进行匹配<ul><li>能够找到：执行装配</li><li>找不到：装配失败</li></ul></li></ul></li></ul><h5 id="2-3-4-使用Resource注解进行注入"><a href="#2-3-4-使用Resource注解进行注入" class="headerlink" title="2.3.4 使用Resource注解进行注入"></a>2.3.4 使用Resource注解进行注入</h5><pre><code class="java">package com.atguigu.ioc.component;import org.springframework.stereotype.Controller;@Controllerpublic class SoldierController &#123;    @Resource    private SoldierService soldierService;    public void getMessage() &#123;        soldierService.getMessage();    &#125;&#125;</code></pre><h5 id="2-3-5-Autowired注解和Resource注解的区别"><a href="#2-3-5-Autowired注解和Resource注解的区别" class="headerlink" title="2.3.5 Autowired注解和Resource注解的区别"></a>2.3.5 Autowired注解和Resource注解的区别</h5><p>@Autowired功能虽说非常强大，但是也有些不足之处。比如：比如它跟spring强耦合了，如果换成了JFinal等其他框架，功能就会失效。而@Resource是JSR-250提供的，它是Java标准，绝大部分框架都支持。</p><p>除此之外，有些场景使用@Autowired无法满足的要求，改成@Resource却能解决问题。接下来，我们重点看看@Autowired和@Resource的区别。</p><ul><li>@Autowired默认按byType自动装配，而@Resource默认byName自动装配。</li><li>@Autowired只包含一个参数：required，表示是否开启自动注入，默认是true。而@Resource包含七个参数，其中最重要的两个参数是：name 和 type。</li><li>@Autowired如果要使用byName，需要使用@Qualifier一起配合。而@Resource如果指定了name，则用byName自动装配，如果指定了type，则用byType自动装配。</li><li>@Autowired能够用在：构造器、方法、参数、成员变量和注解上，而@Resource能用在：类、成员变量和方法上。</li><li>@Autowired是spring定义的注解，而@Resource是JSR-250定义的注解。</li></ul><p>此外，它们的装配顺序不同。 </p><p>Autowired的装配顺序:</p><img src="http://www.slx.blue/2021/12/06/spring-day02/tu_003.png" style="zoom:67%;"><p>Resource的装配顺序:</p><ol><li>如果同时指定了name和type： </li></ol><img src="http://www.slx.blue/2021/12/06/spring-day02/tu_004.png" style="zoom:50%;"><ol start="2"><li> 如果指定了name： </li></ol><img src="http://www.slx.blue/2021/12/06/spring-day02/tu_005.png" style="zoom:50%;"><ol start="3"><li>如果指定了type: </li></ol><img src="http://www.slx.blue/2021/12/06/spring-day02/tu_006.png" style="zoom:50%;"><ol start="4"><li> 如果既没有指定name，也没有指定type： </li></ol><img src="http://www.slx.blue/2021/12/06/spring-day02/tu_007.png" style="zoom:67%;"><h3 id="第三节-纯注解开发"><a href="#第三节-纯注解开发" class="headerlink" title="第三节 纯注解开发"></a>第三节 纯注解开发</h3><p>体验纯注解开发，是为了给将来学习SpringBoot打基础。因为在SpringBoot中，就是完全舍弃XML配置文件，全面使用注解来完成主要的配置。 </p><h4 id="1-使用配置类取代配置文件"><a href="#1-使用配置类取代配置文件" class="headerlink" title="1. 使用配置类取代配置文件"></a>1. 使用配置类取代配置文件</h4><h5 id="1-1-创建配置类"><a href="#1-1-创建配置类" class="headerlink" title="1.1 创建配置类"></a>1.1 创建配置类</h5><p>使用@Configuration注解将一个普通的类标记为Spring的配置类。 </p><pre><code class="java">package com.atguigu.configuration;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import javax.sql.DataSource;/** * 包名:com.atguigu.configuration * 1. 配置类上要添加一个@Configuration注解 */@Configurationpublic class AtguiguSpringConfiguration &#123;    &#125;</code></pre><h5 id="1-2-在配置类中配置包扫描"><a href="#1-2-在配置类中配置包扫描" class="headerlink" title="1.2 在配置类中配置包扫描"></a>1.2 在配置类中配置包扫描</h5><pre><code class="java">package com.atguigu.configuration;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import javax.sql.DataSource;/** * 包名:com.atguigu.configuration * 1. 配置类上要添加一个@Configuration注解 * 2. 使用@ComponentScan注解进行包扫描 */@Configuration@ComponentScan(&quot;com.atguigu&quot;)public class AtguiguSpringConfiguration &#123;&#125;</code></pre><h5 id="1-3-在配置类中配置bean"><a href="#1-3-在配置类中配置bean" class="headerlink" title="1.3 在配置类中配置bean"></a>1.3 在配置类中配置bean</h5><p>对Bean进行IOC的时候，如果是自己编写的类，则可以直接通过IOC注解进行配置，如果是<strong>非自己写的类</strong>:例如JDK中或者第三方框架中的类，我们可以通过配置文件进行IOC；但是在纯注解中没有了配置文件，所以我们需要使用@Bean注解进行IOC</p><pre><code class="java">package com.atguigu.configuration;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import javax.sql.DataSource;/** * 包名:com.atguigu.configuration * 1. 配置类上要添加一个@Configuration注解 * 2. 使用@ComponentScan注解进行包扫描 * 3. 使用@Bean注解配置第三方的类的IOC * 4. 从properties文件中读取数据 */@Configuration@ComponentScan(&quot;com.atguigu&quot;)@PropertySource(&quot;classpath:jdbcInfo.properties&quot;)public class AtguiguSpringConfiguration &#123;    @Value(&quot;$&#123;jdbc.username&#125;&quot;)    private String username;    @Value(&quot;$&#123;jdbc.password&#125;&quot;)    private String password;    @Value(&quot;$&#123;jdbc.url&#125;&quot;)    private String url;    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)    private String driver;    @Bean    public DataSource getDataSource()&#123;        DruidDataSource dataSource = new DruidDataSource();        dataSource.setDriverClassName(driver);        dataSource.setUrl(url);        dataSource.setUsername(username);        dataSource.setPassword(password);        return dataSource;    &#125;&#125;</code></pre><h5 id="1-4-根据配置类创建IOC容器对象"><a href="#1-4-根据配置类创建IOC容器对象" class="headerlink" title="1.4 根据配置类创建IOC容器对象"></a>1.4 根据配置类创建IOC容器对象</h5><pre><code class="java">// AnnotationConfigApplicationContext根据配置类创建IOC容器对象ApplicationContext iocContainerAnnotation = new AnnotationConfigApplicationContext(MyConfiguration.class);</code></pre><h5 id="1-5-测试"><a href="#1-5-测试" class="headerlink" title="1.5 测试"></a>1.5 测试</h5><pre><code class="java">package com.atguigu;import com.atguigu.configuration.AtguiguSpringConfiguration;import com.atguigu.controller.UserController;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;/** * 包名:com.atguigu */public class TestAnnotationOnly &#123;    @Test    public void testPrintConnection()&#123;        //1. 创建核心容器对象:AnnotationConfigApplicationContext核心容器是加载配置类的核心容器        ApplicationContext act = new AnnotationConfigApplicationContext(AtguiguSpringConfiguration.class);        //2. 从核心容器对象中获取UserController对象        UserController userController = (UserController) act.getBean(&quot;userController&quot;);        //3. 调用UserController对象printConnection()方法        userController.printConnection();    &#125;&#125;</code></pre><h3 id="第四节-Spring整合junit4"><a href="#第四节-Spring整合junit4" class="headerlink" title="第四节 Spring整合junit4"></a>第四节 Spring整合junit4</h3><h4 id="1-Spring整合Junit4的好处"><a href="#1-Spring整合Junit4的好处" class="headerlink" title="1. Spring整合Junit4的好处"></a>1. Spring整合Junit4的好处</h4><ul><li>好处1：不需要自己创建IOC容器对象了</li><li>好处2：任何需要的bean都可以在测试类中直接享受自动装配</li></ul><h4 id="2-具体操作"><a href="#2-具体操作" class="headerlink" title="2. 具体操作"></a>2. 具体操作</h4><h5 id="2-1-加入依赖"><a href="#2-1-加入依赖" class="headerlink" title="2.1 加入依赖"></a>2.1 加入依赖</h5><pre><code class="xml">&lt;!--   引入Spring整合Junit的依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;5.3.1&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre><h5 id="2-2-创建测试类"><a href="#2-2-创建测试类" class="headerlink" title="2.2 创建测试类"></a>2.2 创建测试类</h5><p>如果是使用的配置类:</p><pre><code class="java">package com.atguigu;import com.atguigu.configuration.AtguiguSpringConfiguration;import com.atguigu.controller.UserController;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * 包名:com.atguigu * 目标:在单元测试类中注入要测试的对象,这样就不需要自己创建核心容器了，也不需要自己调用getBean()方法从核心容器中获取对象了 * * 实现方案:使用Spring整合Junit单元测试 * 实现步骤: * 1. 引入spring整合Junit的依赖 * 2. 让单元测试类依赖SpringJUnit4ClassRunner来运行:在测试类上添加              @RunWith(SpringJUnit4ClassRunner.class) * 3. 加载配置文件或者配置类: 在测试类上添加@ContextConfiguration(classes = AtguiguSpringConfiguration.class)         */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = AtguiguSpringConfiguration.class)public class TestAnnotationOnly &#123;    @Autowired    private UserController userController;    @Test    public void testPrintConnection()&#123;        //3. 调用UserController对象printConnection()方法        userController.printConnection();    &#125;&#125;</code></pre><p>如果是使用的配置文件:</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:spring-application.xml&quot;)public class TestSpringAnnotation &#123;    @Autowired    private UserController userController;    @Test    public void testPrintConnection()&#123;        //3. 调用UserController对象printConnection()方法        userController.printConnection();    &#125;&#125;</code></pre><h3 id="第五节-内容总结"><a href="#第五节-内容总结" class="headerlink" title="第五节 内容总结"></a>第五节 内容总结</h3><ol><li>包扫描: 指定要进行组件扫描的包</li><li>IOC 注解:<ol><li>Component注解: 三层结构之外的其他类使用</li><li>Controller注解: 表现层的类使用</li><li>Service注解: 业务层的类使用</li><li>Repository注解: 持久层的类使用</li></ol></li><li>依赖注入注解：<ol><li>注入Bean:<ol><li>Autowired注解，它是byType进行自动注入，如果要byName必须结合Qualifier注解一起使用</li><li>Resource注解，它默认是byName进行自动注入</li></ol></li><li>注入简单类型: Value注解，以及使用PropertySource注解引入外部的properties文件</li></ol></li><li>注解方式和配置文件方式进行IOC和依赖注入的选择问题:<ol><li>如果是自己写的类就使用注解方式</li><li>如果是第三方jar中的类就使用配置文件方式</li></ol></li><li>Spring整合Junit：<ol><li>目的：简化单元测试</li><li>实现步骤:<ol><li>引入spring-test的依赖</li><li>Junit的依赖版本必须是4.12及以上</li><li>给单元测试类添加@Runwith(SpringJUnit4ClassRunner.class)</li><li>给单元测试类添加@ContextConfiguration(locations=”配置文件的路径”或者是classes=配置类.class)</li><li>直接注入你想使用的IOC容器中的对象就可以直接使用了</li></ol></li></ol></li><li>Spring的纯注解开发<ol><li>目的: 为了以后学习SpringBoot做准备，我们项目如果是使用Spring做开发的话是不会用纯注解的</li><li>步骤:<ol><li>配置类上要添加@Configuration注解标示为配置类</li><li>配置类上要添加@ComponentScan指定要扫描的包</li><li>如果要对第三方的类进行IOC配置<ol><li>在配置类中创建一个方法<ol><li>修饰符public</li><li>返回值是要进行IOC的对象的类型</li><li>方法体中编写创建IOC对象的代码</li><li>如果要给这个方法注入一个IOC容器中存在的对象，直接在方法的参数中声明就行了</li></ol></li><li>给该方法添加@Bean注解</li></ol></li><li>如果是使用纯注解开发，整合Junit的时候，@ContextConfiguration(classes=配置类.class)</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符集和编码问题</title>
      <link href="/2021/12/06/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2021/12/06/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><h3 id="一、为什么需要字符集"><a href="#一、为什么需要字符集" class="headerlink" title="一、为什么需要字符集"></a>一、为什么需要字符集</h3><p>我们在计算机屏幕上看到的是实体化的文字，而在计算机存储介质中存放的实际是二进制的比特(byte)流。简单来说字符集就规定了某个文字对应的二进制数值存放方式（编码）和某串二进制数值代表了哪个文字（解码）的转换关系。正因为字符和字节之间有着这种固定的对应关系，所以我们的文件在以相同的字符集传递的情况之下才不会出现乱码。</p><h3 id="二、为什么有各种各样的字符集标准"><a href="#二、为什么有各种各样的字符集标准" class="headerlink" title="二、为什么有各种各样的字符集标准"></a>二、为什么有各种各样的字符集标准</h3><p>很多规范和标准在最初制定时并不会意识到这将会是以后全球普适的准则，或者处于组织本身利益就想从本质上区别于现有标准。于是，就产生了那么多具有相同效果但又不相互兼容的标准了。</p><p>最早是美国人使用电脑，所以最初的字符集是ASCII,使用7位bit表示一个字符，总共能表示128种字符。后来，随着欧洲各个国家的计算机普及，人们发现ASCI码I对应的128个字符不能够满足需求了，因为欧洲各个国家都有一些特殊的字符。所以ASCII进行了扩容，使用8位bit表示一个字符，总共就能表示256种字符。</p><p>而当中国开始普及计算机后，发现256中字符根本没办法满足咱们中国人的日常需求，中华文化上下五千年，汉字的数量多了去了，一个字节根本没法对应一个字符。所以只能继续扩容，两个字节对应一个字符，所以后续的GB2312、GBK等等字符集就都被提出来了。</p><p>正因为世界上有各种各样的国家、民族需要使用计算机，各个国家地区都会根据自己的文化特色创造出相对应的字符集标准。</p><h3 id="三、同一个字在多种字符集下对应的16进制和二进制对比"><a href="#三、同一个字在多种字符集下对应的16进制和二进制对比" class="headerlink" title="三、同一个字在多种字符集下对应的16进制和二进制对比"></a>三、同一个字在多种字符集下对应的16进制和二进制对比</h3><table><thead><tr><th>字符集</th><th>16进制编码</th><th>对应的二进制数据</th></tr></thead><tbody><tr><td>UTF-8</td><td>0xE5B18C</td><td>1110 0101 1011 0001 1000 1100</td></tr><tr><td>UTF-16</td><td>0x5C4C</td><td>1011 1000 1001 1000</td></tr><tr><td>GBK</td><td>0x8CC5</td><td>1000 1100 1100 0101</td></tr></tbody></table><p>上述是同一个字在三种字符集下所对应的16进制和2进制数据，我们可以发现同样的一个字，在不同的字符集下对应的16进制和2进制数据完全不同。这个字就是我们平常用来形容一个人特别厉害的一个字——–”屌”!</p><h3 id="四、为什么会发生乱码？"><a href="#四、为什么会发生乱码？" class="headerlink" title="四、为什么会发生乱码？"></a>四、为什么会发生乱码？</h3><p>简单的说乱码的出现是因为：编码和解码时用了不同或者不兼容的字符集。对应到真实生活中，就好比是一个英国人为了表示祝福在纸上写了bless（编码过程）。而一个法国人拿到了这张纸，由于在法语中bless表示受伤的意思，所以认为他想表达的是受伤（解码过程）。这个就是一个现实生活中的乱码情况。在计算机科学中一样，一个用UTF-8编码后的字符，用GBK去解码。由于两个字符集的字库表不一样，同一个汉字在两个字符表的位置也不同，最终就会出现乱码。</p><p>在UTF-8字符编码下（一个汉字对应三个字节），”很屌”这两个字对应的16进制字符串</p><table><thead><tr><th>字符</th><th>UTF-8编码后的十六进制</th><th>UTF-8编码后对应的二进制</th></tr></thead><tbody><tr><td>很</td><td>E5BE88</td><td>1110 0101   1011 1110    1000 1000</td></tr><tr><td>屌</td><td>E5B18C</td><td>1110 0101    1011 0001     1000 1100</td></tr></tbody></table><p>于是我们得到了<code>E5BE88E5B18C</code>这么一串数值。而显示时我们用GBK解码进行展示（一个汉字对应两个字节），通过查表我们获得以下信息：</p><table><thead><tr><th>两个字节的十六进制数值</th><th>GBK解码后对应的字符</th></tr></thead><tbody><tr><td>E5BE</td><td>寰</td></tr><tr><td>88E5</td><td>堝</td></tr><tr><td>B18C</td><td>睂</td></tr></tbody></table><p>以上就是”很屌”这两个字在UTF-8字符集下进行编码，然后在GBK下进行解码，就变成了”寰堝睂”。不仅字符变得不认识了，甚至连字数都发生了变化。有没有觉得很屌的样子？</p><h3 id="五、如何将乱码后的字符串还原成它本来的样子"><a href="#五、如何将乱码后的字符串还原成它本来的样子" class="headerlink" title="五、如何将乱码后的字符串还原成它本来的样子"></a>五、如何将乱码后的字符串还原成它本来的样子</h3><p>要从乱码字符中反解出原来的正确文字需要对各个字符集编码规则有较为深刻的掌握。但是原理很简单，这里用最常见的UTF-8被错误用GBK展示时的乱码为例，来说明具体反解和识别过程。</p><h4 id="第1步-编码"><a href="#第1步-编码" class="headerlink" title="第1步 编码"></a>第1步 编码</h4><p>假设我们在页面上看到<code>寰堝睂</code>这样的乱码，而又得知我们的服务器当前使用GBK编码。那么第一步我们就能先通过GBK把乱码编码成二进制表达式。</p><h4 id="第二步-解码"><a href="#第二步-解码" class="headerlink" title="第二步 解码"></a>第二步 解码</h4><p>由于乱码之前的编码字符集是UTF-8，所以我们再使用UTF-8将二进制字节数组解码成字符串，这时候我们就能够得到这串字符串原本的样子<code>很屌</code></p><p>###六、几个常见名词的介绍</p><h4 id="ASCII码表"><a href="#ASCII码表" class="headerlink" title="ASCII码表"></a>ASCII码表</h4><p>一开始最多只能表示128个字符，经过拓展后最多能表示256个字符。</p><h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><p>Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案，相当于一个最大的字库。Unicode用数字0-0x10FFFF来映射这些字符，最多可以容纳1114112个字符。</p><p>既然Unicode包含全世界所有的文字和字符的话，那么为什么全世界不统一使用Unicode字库表来进行编码和解码呢?而非要弄出这么多各种各样的字符集出来呢?</p><p>因为如果全世界都统一使用Unicode的话，一个字符就要对应三个字节，对于美国人和欧洲人来说，他们使用ASCII的话每个字符只需要对应一个字节。这样所造成的后果就是，本来美国人使用ASCII的时候一个U盘能存放1500篇文章，而改成使用Unicode之后U盘只能存放500篇文章了。所以全世界统一使用Unicode字库表并不现实。</p><h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><p>UTF-8是一个当今接受度最广的字符集编码,但是它只涵盖了Unicode字库中的一小部分，Unicode的编号从<code>0000</code>开始一直到<code>10FFFF</code>共分为16个Plane，每个Plane中有65536个字符。而UTF-8则只实现了第一个Plane，所以这也造成了它在某些场景下对于特殊字符的处理困难。</p><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>Unicode：包容万国，优点是字符-&gt;数字的转换速度快，缺点是占用空间大。</p><p>UTF-8：精准，对不同的字符用不同的长度表示，优点是节省空间，缺点是：字符-&gt;数字的转换速度慢，因为每次都需要计算出字符需要多长的Bytes才能够准确表示。</p><p>所以一般在内存中使用的编码是unicode，用空间换时间，为了快。因为程序都需要加载到内存才能运行，因而内存应该是尽可能的保证快。但硬盘中或者网络传输用utf-8，网络I/O延迟或磁盘I/O延迟要远大与utf-8的转换延迟，而且I/O应该是尽可能地节省带宽，保证数据传输的稳定性。因为数据的传输，追求的是稳定，高效，数据量越小数据传输就越靠谱，于是都转成utf－8格式的，而不是unicode。</p>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-day01-XML</title>
      <link href="/2021/12/04/spring-day01/"/>
      <url>/2021/12/04/spring-day01/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-day01"><a href="#spring-day01" class="headerlink" title="spring-day01"></a>spring-day01</h1><h2 id="第一章-Spring的简介"><a href="#第一章-Spring的简介" class="headerlink" title="第一章 Spring的简介"></a>第一章 Spring的简介</h2><h3 id="第一节-Spring公司简介"><a href="#第一节-Spring公司简介" class="headerlink" title="第一节 Spring公司简介"></a>第一节 Spring公司简介</h3><p>该公司的创建者Rod Johnson被称之为Spring之父，他领导的Spring研发团队下有众多的优秀开发者，Spring公司旗下有非常多的优秀框架。例如:Spring FrameWork、Spring Boot、Spring Cloud、Spring Data、Spring Security等等，几乎涉及了Java开发的每一个领域。 官网地址：<a href="https://spring.io/">https://spring.io/</a> </p><p><img src="http://www.slx.blue/2021/12/04/spring-day01/tu_001.png"></p><h3 id="第二节-Spring-Framework的介绍"><a href="#第二节-Spring-Framework的介绍" class="headerlink" title="第二节 Spring Framework的介绍"></a>第二节 Spring Framework的介绍</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p>Spring Framework是Spring 基础框架，可以视为 Spring 基础设施，基本上任何其他 Spring 项目都是以 Spring Framework 为基础的。是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架</p><h4 id="2-特征"><a href="#2-特征" class="headerlink" title="2. 特征"></a>2. 特征</h4><ul><li>非侵入式：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常小。对领域模型(domain)可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。</li><li>控制反转：IOC——Inversion of Control，反转资源获取方向。把自己创建资源变成环境将资源准备好，我们享受资源注入。</li><li>面向切面编程：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功能。</li><li>容器：Spring IOC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发效率。</li><li>组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。</li><li>声明式：很多以前需要编写代码才能实现的功能，现在只需要声明需求即可由框架代为实现。</li><li>一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且 Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。</li></ul><h4 id="2-Spring-Framework五大功能模块"><a href="#2-Spring-Framework五大功能模块" class="headerlink" title="2. Spring Framework五大功能模块"></a>2. Spring Framework五大功能模块</h4><p><img src="http://www.slx.blue/2021/12/04/spring-day01/tu_002.png"></p><table><thead><tr><th>功能模块</th><th>功能介绍</th></tr></thead><tbody><tr><td>Core Container</td><td>核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。</td></tr><tr><td>AOP&amp;Aspects</td><td>面向切面编程</td></tr><tr><td>Test</td><td>提供了对 junit 或 TestNG 测试框架的整合。</td></tr><tr><td>Data Access/Integration</td><td>提供了对数据访问/集成的功能。</td></tr><tr><td>Spring MVC</td><td>提供了面向Web应用程序的集成功能。</td></tr></tbody></table><h2 id="第二章-IOC容器概念"><a href="#第二章-IOC容器概念" class="headerlink" title="第二章 IOC容器概念"></a>第二章 IOC容器概念</h2><h3 id="第一节-容器的概念"><a href="#第一节-容器的概念" class="headerlink" title="第一节 容器的概念"></a>第一节 容器的概念</h3><h4 id="1-普通容器"><a href="#1-普通容器" class="headerlink" title="1. 普通容器"></a>1. 普通容器</h4><p>普通容器只是负责存储数据(对象)，例如我们在JavaSE中学习的数组、List、Map等等，可以让我们使用它存储数据、获取数据，不具备其它复杂的功能</p><h4 id="2-复杂容器"><a href="#2-复杂容器" class="headerlink" title="2. 复杂容器"></a>2. 复杂容器</h4><p>复杂容器不仅要负责存储对象，还需要具备创建对象、调用对象方法、管理对象生命周期、并且在一定情况下负责销毁对象。例如我们之前学习的Tomcat就是一个复杂容器，它能够负责创建Servlet、Filter、Listener等等对象，并且管理他们的生命周期，在生命周期的不同阶段调用他们的不同方法。而我们后续要学习的IOC容器也是一个复杂容器</p><h3 id="第二节-IOC的概念"><a href="#第二节-IOC的概念" class="headerlink" title="第二节 IOC的概念"></a>第二节 IOC的概念</h3><h4 id="1-传统方式创建对象"><a href="#1-传统方式创建对象" class="headerlink" title="1. 传统方式创建对象"></a>1. 传统方式创建对象</h4><p>传统方式创建对象的方式是: 需要哪个类的对象，就直接在项目中new哪个类的对象，这样就会导致各个类之间的耦合度非常高</p><p><img src="http://www.slx.blue/2021/12/04/spring-day01/tu_003.png"></p><h4 id="2-IOC方式创建对象"><a href="#2-IOC方式创建对象" class="headerlink" title="2. IOC方式创建对象"></a>2. IOC方式创建对象</h4><p>IOC(inversion of control)的中文解释是“控制反转”，对象的使用者不是创建者.  作用是将对象的创建反转给spring框架来创建和管理。控制反转怎么去理解呢。 其实它反转的是什么呢，是对象的创建工作。 举个例子:平常我们在servlet或者service里面创建对象，都是使用new 的方式来直接创建对象，现在有了spring之后，我们就再也不new对象了，而是把对象创建的工作交给spring容器去维护。我们只需要告诉spring容器我们需要什么对象即可</p><p>IOC的作用：削减计算机程序的耦合(解除我们代码中的依赖关系)。</p><p><img src="http://www.slx.blue/2021/12/04/spring-day01/tu_004.png"></p><h3 id="第三节-IOC容器在Spring中的实现"><a href="#第三节-IOC容器在Spring中的实现" class="headerlink" title="第三节 IOC容器在Spring中的实现"></a>第三节 IOC容器在Spring中的实现</h3><p>Spring 的 IOC 容器就是 IOC 思想的一个落地的产品实现。IOC 容器中管理的组件也叫做 bean。在创建 bean 之前，首先需要创建 IOC 容器。Spring 提供了 IOC 容器的两种实现方式:</p><h4 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1. BeanFactory"></a>1. BeanFactory</h4><p>这是 IOC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 框架本身，供Spring框架内部功能使用，不建议开发人员使用。</p><h4 id="2-ApplicationContext"><a href="#2-ApplicationContext" class="headerlink" title="2. ApplicationContext"></a>2. ApplicationContext</h4><p>BeanFactory 的子接口，提供了更多高级特性。面向 Spring 框架的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。 </p><blockquote><p>以后在 Spring 环境下看到一个类或接口的名称中包含 ApplicationContext，那基本就可以断定，这个类或接口与 IOC 容器有关。</p></blockquote><h4 id="3-ApplicationContext的主要实现类"><a href="#3-ApplicationContext的主要实现类" class="headerlink" title="3. ApplicationContext的主要实现类"></a>3. ApplicationContext的主要实现类</h4><table><thead><tr><th>类型名</th><th>简介</th></tr></thead><tbody><tr><td><strong>ClassPathXmlApplicationContext</strong></td><td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>FileSystemXmlApplicationContext</td><td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>ConfigurableApplicationContext</td><td>ApplicationContext 的子接口，包含一些扩展方法 refresh() 和 close() ，让 ApplicationContext 具有启动、关闭和刷新上下文的能力。</td></tr><tr><td><strong>AnnotationConfigApplicationContext</strong></td><td>可以实现基于Java的配置类加载Spring的应用上下文，创建IOC容器对象</td></tr><tr><td><strong>WebApplicationContext</strong></td><td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引用存入 ServletContext 域中。</td></tr></tbody></table><h2 id="第三章-Spring-IOC"><a href="#第三章-Spring-IOC" class="headerlink" title="第三章 Spring IOC"></a>第三章 Spring IOC</h2><h3 id="第一节-快速入门"><a href="#第一节-快速入门" class="headerlink" title="第一节 快速入门"></a>第一节 快速入门</h3><h4 id="1-目标"><a href="#1-目标" class="headerlink" title="1. 目标"></a>1. 目标</h4><p>1.1 让Spring IOC容器创建类的对象</p><p>1.2 从Spring IOC容器中获取对象</p><h4 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h4><p><img src="http://www.slx.blue/2021/12/04/spring-day01/tu_006.png"></p><h4 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3. 具体实现"></a>3. 具体实现</h4><h5 id="3-1-Maven依赖"><a href="#3-1-Maven依赖" class="headerlink" title="3.1 Maven依赖"></a>3.1 Maven依赖</h5><pre><code class="xml">&lt;dependencies&gt;    &lt;!-- 基于Maven依赖传递性，导入spring-context依赖即可导入当前所需所有jar包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- junit测试 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h5 id="3-2-创建类"><a href="#3-2-创建类" class="headerlink" title="3.2 创建类"></a>3.2 创建类</h5><pre><code class="java">package com.atguigu.ioc.component;    public class HappyComponent &#123;        public void doWork() &#123;        System.out.println(&quot;component do work ...&quot;);    &#125;    &#125;</code></pre><h5 id="3-3-创建Spring-配置文件并且配置组件"><a href="#3-3-创建Spring-配置文件并且配置组件" class="headerlink" title="3.3 创建Spring 配置文件并且配置组件"></a>3.3 创建Spring 配置文件并且配置组件</h5><p>配置文件的存放路径建议放在resources根路径下，配置文件名字随意</p><p><img src="http://www.slx.blue/2021/12/04/spring-day01/tu_007.png"></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--        每一个实现类就对应一个bean标签            id属性: 对象的唯一标识，根据这个唯一标识，就可以从核心容器中获取对象            class属性: 对象所属的实现类的全限定名    --&gt;    &lt;bean id=&quot;happyComponent&quot; class=&quot;com.atguigu.ioc.component.HappyComponent&quot;/&gt;&lt;/beans&gt;</code></pre><ul><li>bean标签：通过配置bean标签告诉IOC容器需要创建对象的组件是什么</li><li>id属性：bean的唯一标识</li><li>class属性：组件类的全类名</li></ul><h5 id="3-4-从核心容器中获取对象"><a href="#3-4-从核心容器中获取对象" class="headerlink" title="3.4 从核心容器中获取对象"></a>3.4 从核心容器中获取对象</h5><h6 id="方式一：根据id获取"><a href="#方式一：根据id获取" class="headerlink" title="方式一：根据id获取"></a>方式一：根据id获取</h6><pre><code class="java">public class IOCTest &#123;        // 创建 IOC 容器对象，为便于其他实验方法使用声明为成员变量    private ApplicationContext iocContainer = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        @Test    public void testExperiment01() &#123;            // 从 IOC 容器对象中获取bean，也就是组件对象        HappyComponent happyComponent = (HappyComponent) iocContainer.getBean(&quot;happyComponent&quot;);        happyComponent.doWork();    &#125;&#125;</code></pre><h6 id="方式二：根据类型获取"><a href="#方式二：根据类型获取" class="headerlink" title="方式二：根据类型获取"></a>方式二：根据类型获取</h6><p>如果该类型在核心容器中只有一个对象：</p><pre><code class="java">@Testpublic void testExperiment02() &#123;        HappyComponent component = iocContainer.getBean(HappyComponent.class);        component.doWork();    &#125;</code></pre><p>如果该类型在核心容器中有多个对象：那么根据类型获取时会抛出异常，具体异常信息如下</p><blockquote><p>org.springframework.beans.factory.<strong>NoUniqueBeanDefinitionException</strong>: No qualifying bean of type ‘com.atguigu.ioc.component.HappyComponent’ available: expected single matching bean but found 2: happyComponent,happyComponent2</p></blockquote><h6 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h6><p>如果组件类实现了接口，根据接口类型可以获取 bean对象 吗？</p><blockquote><p>可以，前提是bean对象唯一</p></blockquote><p>如果一个接口有多个实现类，这些实现类都配置了 bean，根据接口类型可以获取 bean 吗？</p><blockquote><p>不行，因为bean对象不唯一</p></blockquote><h6 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h6><p>根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 <strong>instanceof</strong> 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。 </p><h3 id="第二节-依赖注入"><a href="#第二节-依赖注入" class="headerlink" title="第二节 依赖注入"></a>第二节 依赖注入</h3><p>依赖注入全称是 dependency Injection 翻译过来是依赖注入.其实就是如果spring核心容器管理的某一个类中存在属性，需要spring核心容器在创建该类实例的时候，顺便给这个对象里面的属性进行赋值。</p><h4 id="1-setter方法注入"><a href="#1-setter方法注入" class="headerlink" title="1. setter方法注入"></a>1. setter方法注入</h4><p>如果某个Bean对象的属性有对应的setter方法，那我们可以在配置文件中使用setter方法对属性进行依赖注入</p><h5 id="1-1-注入简单类型数据"><a href="#1-1-注入简单类型数据" class="headerlink" title="1.1 注入简单类型数据"></a>1.1 注入简单类型数据</h5><h6 id="1-1-1-给组件类添加一个简单类型属性"><a href="#1-1-1-给组件类添加一个简单类型属性" class="headerlink" title="1.1.1 给组件类添加一个简单类型属性"></a>1.1.1 给组件类添加一个简单类型属性</h6><pre><code class="java">package com.atguigu.component;/** * 包名:com.atguigu.component * 日期2021-08-29  10:10 * 给一个对象的成员变量赋值的方式: * 1. 调用set方法 * 2. 通过构造器 * 3. 通过暴力反射 */public class HappyComponent &#123;    private String username;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public void doWork() &#123;        System.out.println(&quot;component do work ...&quot;);    &#125;&#125;</code></pre><h6 id="1-1-2-在配置时给属性指定值"><a href="#1-1-2-在配置时给属性指定值" class="headerlink" title="1.1.2 在配置时给属性指定值"></a>1.1.2 在配置时给属性指定值</h6><p>通过property标签配置的属性值会通过setXxx()方法注入，大家可以通过debug方式验证一下 </p><pre><code class="xml">&lt;!--        依赖注入:给核心容器中的Bean对象的成员变量赋值        setter方法进行依赖注入:            在要进行依赖注入的bean标签中添加&lt;property&gt;子标签,该子标签的name属性就是要赋值的成员变量名            前提是这个属性一定要有set方法,name属性的值应该是&quot;setXXX&quot;后面的&quot;XXX&quot;首字母改小写            1. 注入简单类型数据: 那么我们使用property标签的value属性给简单类型的成员变量赋值            2. 注入Bean类型数据: 那么我们使用property标签的ref属性给Bean类型的成员变量赋值，                               ref属性的值就是要赋值的Bean类型的对象在核心容器中的id    --&gt;&lt;bean id=&quot;happyComponent&quot; class=&quot;com.atguigu.component.HappyComponent&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;奥巴马&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h6 id="1-1-3-测试代码"><a href="#1-1-3-测试代码" class="headerlink" title="1.1.3 测试代码"></a>1.1.3 测试代码</h6><pre><code class="java">@Testpublic void testGetHappyComponent()&#123;    //2. 使用核心容器对象获取HappyComponent对象    //根据id获取:获取ioc容器中id为&quot;happyComponent&quot;的对象    HappyComponent happyComponent1 = (HappyComponent) act.getBean(&quot;happyComponent&quot;);        //3. 使用HappyComponent对象获取username属性    System.out.println(happyComponent1.getUsername());&#125;</code></pre><h5 id="1-2-注入Bean类型数据"><a href="#1-2-注入Bean类型数据" class="headerlink" title="1.2 注入Bean类型数据"></a>1.2 注入Bean类型数据</h5><h6 id="1-2-1-声明新的组件类UserServlet"><a href="#1-2-1-声明新的组件类UserServlet" class="headerlink" title="1.2.1 声明新的组件类UserServlet"></a>1.2.1 声明新的组件类UserServlet</h6><pre><code class="java">package com.atguigu.servlet;import com.atguigu.service.UserService;/** * 包名:com.atguigu.servlet * * 日期2021-08-29  10:28 * 1. IOC : 由核心容器创建Bean对象 * 2. DI(依赖注入) : 给核心容器中的Bean对象的成员变量赋值 */public class UserServlet &#123;    private UserService userService;    public void setUserService(UserService userService) &#123;        this.userService = userService;    &#125;    public void sayHello()&#123;        userService.sayHello();    &#125;&#125;</code></pre><h6 id="1-2-2-声明新的组件接口UserService和实现类UserServiceImpl"><a href="#1-2-2-声明新的组件接口UserService和实现类UserServiceImpl" class="headerlink" title="1.2.2 声明新的组件接口UserService和实现类UserServiceImpl"></a>1.2.2 声明新的组件接口UserService和实现类UserServiceImpl</h6><p>UserService接口</p><pre><code class="java">package com.atguigu.service;/** * 包名:com.atguigu.service * * 日期2021-08-29  10:27 */public interface UserService &#123;    void sayHello();&#125;</code></pre><p>UserServiceImpl实现类</p><pre><code class="java">package com.atguigu.service.impl;import com.atguigu.component.HappyComponent;import com.atguigu.service.UserService;/** * 包名:com.atguigu.service * * 日期2021-08-29  10:33 * */public class UserServiceImpl implements UserService &#123;    private HappyComponent happyComponent;    public void setHappyComponent(HappyComponent happyComponent) &#123;        this.happyComponent = happyComponent;    &#125;    @Override    public void sayHello() &#123;        System.out.println(&quot;hello,&quot;+happyComponent.getUsername());    &#125;&#125;</code></pre><h6 id="1-2-3-在UserService对象中注入HappyComponent对象"><a href="#1-2-3-在UserService对象中注入HappyComponent对象" class="headerlink" title="1.2.3 在UserService对象中注入HappyComponent对象"></a>1.2.3 在UserService对象中注入HappyComponent对象</h6><pre><code class="xml">&lt;!--        使用依赖注入给HappyComponent属性赋值    --&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.service.impl.UserServiceImpl&quot;&gt;    &lt;property name=&quot;happyComponent&quot; ref=&quot;happyComponent&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h6 id="1-2-4-在UserServlet对象中注入UserService对象"><a href="#1-2-4-在UserServlet对象中注入UserService对象" class="headerlink" title="1.2.4 在UserServlet对象中注入UserService对象"></a>1.2.4 在UserServlet对象中注入UserService对象</h6><pre><code class="xml">&lt;!--        你想让ioc容器创建什么对象，就将那个类配置到bean标签中        使用依赖注入给UserService属性赋值    --&gt;&lt;bean id=&quot;userServlet&quot; class=&quot;com.atguigu.servlet.UserServlet&quot;&gt;    &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>这个操作在 IDEA 中有提示： </p><p><img src="http://www.slx.blue/2021/12/04/spring-day01/tu_009.png"></p><h6 id="1-2-5-测试"><a href="#1-2-5-测试" class="headerlink" title="1.2.5 测试"></a>1.2.5 测试</h6><pre><code class="java">@Testpublic void testSayHello()&#123;    //通过ioc容器获取UserServlet的对象    UserServlet userServlet = (UserServlet) act.getBean(&quot;userServlet&quot;);    //调用UserServlet的sayHello()方法    userServlet.sayHello();&#125;</code></pre><h6 id="1-2-6-易错点"><a href="#1-2-6-易错点" class="headerlink" title="1.2.6 易错点"></a>1.2.6 易错点</h6><blockquote><p>如果错把ref属性写成了value属性，会抛出异常： Caused by: java.lang.IllegalStateException: Cannot convert value of type ‘java.lang.String’ to required type ‘com.atguigu.ioc.component.HappyMachine’ for property ‘happyMachine’: no matching editors or conversion strategy found 意思是不能把String类型转换成我们要的HappyMachine类型 说明我们使用value属性时，Spring只把这个属性看做一个普通的字符串，不会认为这是一个bean的id，更不会根据它去找到bean来赋值</p></blockquote><h5 id="1-3-注入内部Bean类型数据-了解"><a href="#1-3-注入内部Bean类型数据-了解" class="headerlink" title="1.3 注入内部Bean类型数据(了解)"></a>1.3 注入内部Bean类型数据(了解)</h5><h6 id="1-3-1-重新配置原组件"><a href="#1-3-1-重新配置原组件" class="headerlink" title="1.3.1 重新配置原组件"></a>1.3.1 重新配置原组件</h6><p>在bean里面配置的bean就是内部bean，内部bean只能在当前bean内部使用，在其他地方不能使用。</p><pre><code class="xml">&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.service.impl.UserServiceImpl&quot;&gt;    &lt;property name=&quot;happyComponent&quot;&gt;        &lt;!--这个bean标签创建的HappyComponent对象只能用于给UserServiceImpl的happyComponent属性赋值,别的地方不能使用--&gt;        &lt;bean class=&quot;com.atguigu.component.HappyComponent&quot;&gt;            &lt;property name=&quot;username&quot; value=&quot;aobama&quot;&gt;&lt;/property&gt;        &lt;/bean&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h6 id="1-3-2-测试"><a href="#1-3-2-测试" class="headerlink" title="1.3.2 测试"></a>1.3.2 测试</h6><pre><code class="java">@Testpublic void testExperiment04() &#123;    //通过核心容器获取UserService的对象:我为什么要使用接口类型接收实现类的对象,为了解耦    UserService userService = (UserService) act.getBean(&quot;userService&quot;);    userService.sayHello();&#125;</code></pre><h5 id="1-4-引入外部属性文件用于给Bean注入属性"><a href="#1-4-引入外部属性文件用于给Bean注入属性" class="headerlink" title="1.4 引入外部属性文件用于给Bean注入属性"></a>1.4 引入外部属性文件用于给Bean注入属性</h5><h6 id="1-4-1-添加Maven依赖"><a href="#1-4-1-添加Maven依赖" class="headerlink" title="1.4.1 添加Maven依赖"></a>1.4.1 添加Maven依赖</h6><p>这个依赖只是为了使用Druid连接池，而不是引入外部属性文件所必须的</p><pre><code class="xml">&lt;!-- MySQL驱动 --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据源 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.0.31&lt;/version&gt;&lt;/dependency&gt;</code></pre><h6 id="1-4-2-创建外部属性文件"><a href="#1-4-2-创建外部属性文件" class="headerlink" title="1.4.2 创建外部属性文件"></a>1.4.2 创建外部属性文件</h6><p><img src="http://www.slx.blue/2021/12/04/spring-day01/tu_010.png"></p><pre><code class="properties">jdbc.user=rootjdbc.password=123456jdbc.url=jdbc:mysql://localhost:3306/mybatis-examplejdbc.driver=com.mysql.jdbc.Driver</code></pre><h6 id="1-4-3-在spring的配置文件中引入jdbc-properties文件"><a href="#1-4-3-在spring的配置文件中引入jdbc-properties文件" class="headerlink" title="1.4.3 在spring的配置文件中引入jdbc.properties文件"></a>1.4.3 在spring的配置文件中引入jdbc.properties文件</h6><pre><code class="xml">&lt;!-- 引入外部属性文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</code></pre><h6 id="1-4-4-在spring的配置文件中使用引入的jdbc-properties文件中的数据"><a href="#1-4-4-在spring的配置文件中使用引入的jdbc-properties文件中的数据" class="headerlink" title="1.4.4 在spring的配置文件中使用引入的jdbc.properties文件中的数据"></a>1.4.4 在spring的配置文件中使用引入的jdbc.properties文件中的数据</h6><pre><code class="xml">&lt;!--[重要]给bean的属性赋值：引入外部属性文件 --&gt;&lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt;</code></pre><h6 id="1-4-5-测试"><a href="#1-4-5-测试" class="headerlink" title="1.4.5 测试"></a>1.4.5 测试</h6><pre><code class="java">@Testpublic void testExperiment06() throws SQLException &#123;    DataSource dataSource = iocContainer.getBean(DataSource.class);    Connection connection = dataSource.getConnection();    System.out.println(&quot;connection = &quot; + connection);&#125;</code></pre><h6 id="1-4-6-结论"><a href="#1-4-6-结论" class="headerlink" title="1.4.6 结论"></a>1.4.6 结论</h6><p>标签的value属性: 注入简单类型数据</p><p>标签的ref属性:用于引入IOC容器中的Bean对象的id，注入Bean对象类型的数据</p><h5 id="1-5-注入集合类型属性-了解"><a href="#1-5-注入集合类型属性-了解" class="headerlink" title="1.5 注入集合类型属性(了解)"></a>1.5 注入集合类型属性(了解)</h5><h6 id="1-5-1-给组件类添加集合类型属性"><a href="#1-5-1-给组件类添加集合类型属性" class="headerlink" title="1.5.1 给组件类添加集合类型属性"></a>1.5.1 给组件类添加集合类型属性</h6><pre><code class="java">package com.atguigu.component;import java.util.List;/** * 包名:com.atguigu.component * * 日期2021-08-29  10:10 * 给一个对象的成员变量赋值的方式: * 1. 调用set方法 * 2. 通过构造器 * 3. 通过暴力反射 */public class HappyComponent &#123;    private String username;    private List&lt;String&gt; memberList;    public List&lt;String&gt; getMemberList() &#123;        return memberList;    &#125;    public void setMemberList(List&lt;String&gt; memberList) &#123;        this.memberList = memberList;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public void doWork() &#123;        System.out.println(&quot;component do work ...&quot;);    &#125;&#125;</code></pre><h6 id="1-5-2-配置"><a href="#1-5-2-配置" class="headerlink" title="1.5.2 配置"></a>1.5.2 配置</h6><pre><code class="xml">&lt;bean id=&quot;happyComponent&quot; class=&quot;com.atguigu.component.HappyComponent&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;奥巴马&quot;&gt;&lt;/property&gt;    &lt;!--注入集合类型的数据--&gt;    &lt;property name=&quot;memberList&quot;&gt;        &lt;!--&lt;list&gt;                &lt;value&gt;张三&lt;/value&gt;                &lt;value&gt;李四&lt;/value&gt;                &lt;value&gt;王五&lt;/value&gt;                &lt;value&gt;赵六&lt;/value&gt;            &lt;/list&gt;--&gt;        &lt;!--                使用set标签注入集合可以去重            --&gt;        &lt;!--&lt;set&gt;                &lt;value&gt;张三&lt;/value&gt;                &lt;value&gt;李四&lt;/value&gt;                &lt;value&gt;王五&lt;/value&gt;                &lt;value&gt;赵六&lt;/value&gt;                &lt;value&gt;王五&lt;/value&gt;            &lt;/set&gt;--&gt;        &lt;array&gt;            &lt;value&gt;张三&lt;/value&gt;            &lt;value&gt;李四&lt;/value&gt;            &lt;value&gt;王五&lt;/value&gt;            &lt;value&gt;赵六&lt;/value&gt;            &lt;value&gt;王五&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h5 id="1-6-注入Map类型属性-了解"><a href="#1-6-注入Map类型属性-了解" class="headerlink" title="1.6 注入Map类型属性(了解)"></a>1.6 注入Map类型属性(了解)</h5><h6 id="1-6-1-给组件类添加Map类型属性"><a href="#1-6-1-给组件类添加Map类型属性" class="headerlink" title="1.6.1 给组件类添加Map类型属性"></a>1.6.1 给组件类添加Map类型属性</h6><pre><code class="java">package com.atguigu.component;import java.util.List;import java.util.Map;/** * 包名:com.atguigu.component * * 日期2021-08-29  10:10 * 给一个对象的成员变量赋值的方式: * 1. 调用set方法 * 2. 通过构造器 * 3. 通过暴力反射 */public class HappyComponent &#123;    private String username;    private List&lt;String&gt; memberList;    private Map&lt;String,String&gt; managerMap;    public Map&lt;String, String&gt; getManagerMap() &#123;        return managerMap;    &#125;    public void setManagerMap(Map&lt;String, String&gt; managerMap) &#123;        this.managerMap = managerMap;    &#125;    public List&lt;String&gt; getMemberList() &#123;        return memberList;    &#125;    public void setMemberList(List&lt;String&gt; memberList) &#123;        this.memberList = memberList;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public void doWork() &#123;        System.out.println(&quot;component do work ...&quot;);    &#125;&#125;</code></pre><h6 id="1-6-2-配置"><a href="#1-6-2-配置" class="headerlink" title="1.6.2 配置"></a>1.6.2 配置</h6><pre><code class="xml">&lt;bean id=&quot;happyComponent&quot; class=&quot;com.atguigu.component.HappyComponent&quot;&gt;    &lt;!--注入Map类型的数据--&gt;    &lt;property name=&quot;managerMap&quot;&gt;        &lt;!--&lt;map&gt;                &lt;entry key=&quot;k1&quot; value=&quot;v1&quot; &gt;&lt;/entry&gt;                &lt;entry key=&quot;k2&quot; value=&quot;v2&quot;&gt;&lt;/entry&gt;                &lt;entry key=&quot;k3&quot; value=&quot;v3&quot;&gt;&lt;/entry&gt;                &lt;entry key=&quot;k4&quot; value=&quot;v4&quot;&gt;&lt;/entry&gt;            &lt;/map&gt;--&gt;        &lt;props&gt;            &lt;prop key=&quot;k1&quot;&gt;v1&lt;/prop&gt;            &lt;prop key=&quot;k2&quot;&gt;v2&lt;/prop&gt;            &lt;prop key=&quot;k3&quot;&gt;v3&lt;/prop&gt;            &lt;prop key=&quot;k4&quot;&gt;v4&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h5 id="1-7-注入Bean的集合类型-了解"><a href="#1-7-注入Bean的集合类型-了解" class="headerlink" title="1.7 注入Bean的集合类型(了解)"></a>1.7 注入Bean的集合类型(了解)</h5><h6 id="1-7-1-给组件添加Bean的集合类型属性"><a href="#1-7-1-给组件添加Bean的集合类型属性" class="headerlink" title="1.7.1 给组件添加Bean的集合类型属性"></a>1.7.1 给组件添加Bean的集合类型属性</h6><pre><code class="java">package com.atguigu.component;import java.util.List;import java.util.Map;/** * 包名:com.atguigu.component * * 日期2021-08-29  10:10 * 给一个对象的成员变量赋值的方式: * 1. 调用set方法 * 2. 通过构造器 * 3. 通过暴力反射 */public class HappyComponent &#123;    private String username;    private List&lt;String&gt; memberList;    private Map&lt;String,String&gt; managerMap;    private List&lt;User&gt; userList;    public List&lt;User&gt; getUserList() &#123;        return userList;    &#125;    public void setUserList(List&lt;User&gt; userList) &#123;        this.userList = userList;    &#125;    public Map&lt;String, String&gt; getManagerMap() &#123;        return managerMap;    &#125;    public void setManagerMap(Map&lt;String, String&gt; managerMap) &#123;        this.managerMap = managerMap;    &#125;    public List&lt;String&gt; getMemberList() &#123;        return memberList;    &#125;    public void setMemberList(List&lt;String&gt; memberList) &#123;        this.memberList = memberList;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public void doWork() &#123;        System.out.println(&quot;component do work ...&quot;);    &#125;&#125;</code></pre><p>User类</p><pre><code class="java">package com.atguigu.component;/** * 包名:com.atguigu.component * * 日期2021-08-29  14:57 */public class User &#123;    private String name;    private String address;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;&#125;</code></pre><h6 id="1-7-2-配置"><a href="#1-7-2-配置" class="headerlink" title="1.7.2 配置"></a>1.7.2 配置</h6><pre><code class="xml">&lt;bean id=&quot;happyComponent&quot; class=&quot;com.atguigu.component.HappyComponent&quot;&gt;    &lt;property name=&quot;username&quot; value=&quot;奥巴马&quot;&gt;&lt;/property&gt;    &lt;!--注入集合类型的数据--&gt;    &lt;property name=&quot;memberList&quot;&gt;        &lt;!--&lt;list&gt;                &lt;value&gt;张三&lt;/value&gt;                &lt;value&gt;李四&lt;/value&gt;                &lt;value&gt;王五&lt;/value&gt;                &lt;value&gt;赵六&lt;/value&gt;            &lt;/list&gt;--&gt;        &lt;!--                使用set标签注入集合可以去重            --&gt;        &lt;!--&lt;set&gt;                &lt;value&gt;张三&lt;/value&gt;                &lt;value&gt;李四&lt;/value&gt;                &lt;value&gt;王五&lt;/value&gt;                &lt;value&gt;赵六&lt;/value&gt;                &lt;value&gt;王五&lt;/value&gt;            &lt;/set&gt;--&gt;        &lt;array&gt;            &lt;value&gt;张三&lt;/value&gt;            &lt;value&gt;李四&lt;/value&gt;            &lt;value&gt;王五&lt;/value&gt;            &lt;value&gt;赵六&lt;/value&gt;            &lt;value&gt;王五&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;    &lt;!--注入Map类型的数据--&gt;    &lt;property name=&quot;managerMap&quot;&gt;        &lt;!--&lt;map&gt;                &lt;entry key=&quot;k1&quot; value=&quot;v1&quot; &gt;&lt;/entry&gt;                &lt;entry key=&quot;k2&quot; value=&quot;v2&quot;&gt;&lt;/entry&gt;                &lt;entry key=&quot;k3&quot; value=&quot;v3&quot;&gt;&lt;/entry&gt;                &lt;entry key=&quot;k4&quot; value=&quot;v4&quot;&gt;&lt;/entry&gt;            &lt;/map&gt;--&gt;        &lt;props&gt;            &lt;prop key=&quot;k1&quot;&gt;v1&lt;/prop&gt;            &lt;prop key=&quot;k2&quot;&gt;v2&lt;/prop&gt;            &lt;prop key=&quot;k3&quot;&gt;v3&lt;/prop&gt;            &lt;prop key=&quot;k4&quot;&gt;v4&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;    &lt;!--注入Bean的集合类型--&gt;    &lt;property name=&quot;userList&quot;&gt;        &lt;list&gt;            &lt;bean class=&quot;com.atguigu.component.User&quot;&gt;                &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;                &lt;property name=&quot;address&quot; value=&quot;深圳&quot;&gt;&lt;/property&gt;            &lt;/bean&gt;            &lt;bean class=&quot;com.atguigu.component.User&quot;&gt;                &lt;property name=&quot;name&quot; value=&quot;李四&quot;&gt;&lt;/property&gt;                &lt;property name=&quot;address&quot; value=&quot;广州&quot;&gt;&lt;/property&gt;            &lt;/bean&gt;            &lt;bean class=&quot;com.atguigu.component.User&quot;&gt;                &lt;property name=&quot;name&quot; value=&quot;王五&quot;&gt;&lt;/property&gt;                &lt;property name=&quot;address&quot; value=&quot;北京&quot;&gt;&lt;/property&gt;            &lt;/bean&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h4 id="2-构造器注入-了解"><a href="#2-构造器注入-了解" class="headerlink" title="2. 构造器注入(了解)"></a>2. 构造器注入(了解)</h4><p>在前面我们通过<code>&lt;bean&gt;</code>标签配置Bean对象，其实是执行Bean类的无参构造函数创建的对象，当Bean类包含有参构造函数的时候，我们在配置文件中可以通过有参构造函数进行配置注入</p><h5 id="2-1-声明组件类"><a href="#2-1-声明组件类" class="headerlink" title="2.1 声明组件类"></a>2.1 声明组件类</h5><pre><code class="java">package com.atguigu.ioc.component;    public class HappyTeam &#123;            private String teamName;    private Integer memberCount;    private Double memberSalary;        public String getTeamName() &#123;        return teamName;    &#125;        public void setTeamName(String teamName) &#123;        this.teamName = teamName;    &#125;        public Integer getMemberCount() &#123;        return memberCount;    &#125;        public void setMemberCount(Integer memberCount) &#123;        this.memberCount = memberCount;    &#125;        public Double getMemberSalary() &#123;        return memberSalary;    &#125;        public void setMemberSalary(Double memberSalary) &#123;        this.memberSalary = memberSalary;    &#125;        @Override    public String toString() &#123;        return &quot;HappyTeam&#123;&quot; +                &quot;teamName=&#39;&quot; + teamName + &#39;\&#39;&#39; +                &quot;, memberCount=&quot; + memberCount +                &quot;, memberSalary=&quot; + memberSalary +                &#39;&#125;&#39;;    &#125;        public HappyTeam(String teamName, Integer memberCount, Double memberSalary) &#123;        this.teamName = teamName;        this.memberCount = memberCount;        this.memberSalary = memberSalary;    &#125;        public HappyTeam() &#123;    &#125;&#125;</code></pre><h5 id="2-2-配置构造器注入"><a href="#2-2-配置构造器注入" class="headerlink" title="2.2 配置构造器注入"></a>2.2 配置构造器注入</h5><pre><code class="xml">&lt;!-- 给bean的属性赋值：构造器注入 --&gt;&lt;bean id=&quot;happyTeam&quot; class=&quot;com.atguigu.ioc.component.HappyTeam&quot;&gt;    &lt;constructor-arg value=&quot;happyCorps&quot;/&gt;    &lt;constructor-arg value=&quot;10&quot;/&gt;    &lt;constructor-arg value=&quot;1000.55&quot;/&gt;&lt;/bean&gt;</code></pre><h5 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h5><pre><code class="java">@Testpublic void testExperiment08() &#123;        HappyTeam happyTeam = iocContainer.getBean(HappyTeam.class);        System.out.println(&quot;happyTeam = &quot; + happyTeam);    &#125;</code></pre><h5 id="2-4-补充"><a href="#2-4-补充" class="headerlink" title="2.4 补充"></a>2.4 补充</h5><p>constructor-arg标签还有两个属性可以进一步描述构造器参数：</p><ul><li>index属性：指定参数所在位置的索引（从0开始）</li><li>name属性：指定参数名</li></ul><h4 id="3-特殊值处理-了解"><a href="#3-特殊值处理-了解" class="headerlink" title="3. 特殊值处理(了解)"></a>3. 特殊值处理(了解)</h4><h5 id="3-1-声明一个类用于测试"><a href="#3-1-声明一个类用于测试" class="headerlink" title="3.1 声明一个类用于测试"></a>3.1 声明一个类用于测试</h5><pre><code class="java">package com.atguigu.ioc.component;    public class PropValue &#123;    private String commonValue;    private String expression;        public String getCommonValue() &#123;        return commonValue;    &#125;        public void setCommonValue(String commonValue) &#123;        this.commonValue = commonValue;    &#125;        public String getExpression() &#123;        return expression;    &#125;        public void setExpression(String expression) &#123;        this.expression = expression;    &#125;        @Override    public String toString() &#123;        return &quot;PropValue&#123;&quot; +                &quot;commonValue=&#39;&quot; + commonValue + &#39;\&#39;&#39; +                &quot;, expression=&#39;&quot; + expression + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;    public PropValue(String commonValue, String expression) &#123;        this.commonValue = commonValue;        this.expression = expression;    &#125;    public PropValue() &#123;    &#125;&#125;</code></pre><h5 id="3-2-null值"><a href="#3-2-null值" class="headerlink" title="3.2 null值"></a>3.2 null值</h5><pre><code class="xml">&lt;property name=&quot;commonValue&quot;&gt;    &lt;!-- null标签：将一个属性值明确设置为null --&gt;    &lt;null/&gt;&lt;/property&gt;</code></pre><h5 id="3-3-当value值中有特殊字符时"><a href="#3-3-当value值中有特殊字符时" class="headerlink" title="3.3 当value值中有特殊字符时"></a>3.3 当value值中有特殊字符时</h5><h6 id="3-3-1-使用XML实体字符-转义符-解决"><a href="#3-3-1-使用XML实体字符-转义符-解决" class="headerlink" title="3.3.1 使用XML实体字符(转义符)解决"></a>3.3.1 使用XML实体字符(转义符)解决</h6><pre><code class="xml">&lt;bean id=&quot;propValue&quot; class=&quot;com.atguigu.ioc.component.PropValue&quot;&gt;    &lt;!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 --&gt;    &lt;!-- 解决方案一：使用XML实体来代替 --&gt;    &lt;property name=&quot;expression&quot; value=&quot;a &amp;lt; b&quot;/&gt;&lt;/bean&gt;</code></pre><h6 id="3-3-2-使用CDATA解决"><a href="#3-3-2-使用CDATA解决" class="headerlink" title="3.3.2 使用CDATA解决"></a>3.3.2 使用CDATA解决</h6><pre><code class="xml">&lt;bean id=&quot;propValue&quot; class=&quot;com.atguigu.ioc.component.PropValue&quot;&gt;    &lt;property name=&quot;expression&quot;&gt;        &lt;!-- 解决方案二：使用CDATA节 --&gt;        &lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt;        &lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt;        &lt;!-- 所以CDATA节中写什么符号都随意 --&gt;        &lt;value&gt;&lt;![CDATA[a &lt; b]]&gt;&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h4 id="4-p命名空间方式注入-了解"><a href="#4-p命名空间方式注入-了解" class="headerlink" title="4. p命名空间方式注入(了解)"></a>4. p命名空间方式注入(了解)</h4><h5 id="4-1-引入p命名空间的约束"><a href="#4-1-引入p命名空间的约束" class="headerlink" title="4.1 引入p命名空间的约束"></a>4.1 引入p命名空间的约束</h5><p>使用 p 名称空间需要导入相关的 XML 约束，在 IDEA 的协助下导入即可： </p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</code></pre><h5 id="4-2-使用p命名空间注入"><a href="#4-2-使用p命名空间注入" class="headerlink" title="4.2 使用p命名空间注入"></a>4.2 使用p命名空间注入</h5><pre><code class="xml">&lt;!--注入简单类型数据--&gt;&lt;bean id=&quot;happyComponent&quot; class=&quot;com.atguigu.component.HappyComponent&quot; p:username=&quot;奥拉夫&quot;&gt;&lt;/bean&gt;    &lt;!--注入Bean类型数据--&gt;&lt;bean id=&quot;userServlet&quot; class=&quot;com.atguigu.servlet.UserServlet&quot; p:userService-ref=&quot;userService&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.service.impl.UserServiceImpl&quot; p:happyComponent-ref=&quot;happyComponent&quot;&gt;&lt;/bean&gt;</code></pre><h5 id="4-3-测试"><a href="#4-3-测试" class="headerlink" title="4.3 测试"></a>4.3 测试</h5><pre><code class="java">@Testpublic void testSayHello()&#123;    //通过ioc容器获取UserServlet的对象    UserServlet userServlet = (UserServlet) act.getBean(&quot;userServlet&quot;);    //调用UserServlet的sayHello()方法    userServlet.sayHello();&#125;</code></pre><h4 id="5-自动装配"><a href="#5-自动装配" class="headerlink" title="5. 自动装配"></a>5. 自动装配</h4><p>所谓自动装配就是一个组件需要其他组件时，由 IOC 容器负责找到那个需要的组件，并装配进去。  </p><h5 id="5-1-配置"><a href="#5-1-配置" class="headerlink" title="5.1 配置"></a>5.1 配置</h5><pre><code class="xml">&lt;bean id=&quot;happyComponent2&quot; class=&quot;com.atguigu.component.HappyComponent&quot; p:username=&quot;奥拉夫&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;happyComponent&quot; class=&quot;com.atguigu.component.HappyComponent&quot; p:username=&quot;奥巴马&quot;&gt;&lt;/bean&gt;    &lt;!--        你想让ioc容器创建什么对象，就将那个类配置到bean标签中        使用依赖注入给UserService属性赋值        自动装配:autowire属性表示自动装配，就是不需要你去管依赖注入，IOC容器会自动进行依赖注入。它的取值有如下两个            1. byName:根据要注入的属性名和Bean对象的id的对应关系去注入            2. byType:表示核心容器会自动在自身容器中查找一个该类型的对象，给成员变量赋值    --&gt;&lt;bean id=&quot;userServlet&quot; class=&quot;com.atguigu.servlet.UserServlet&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;    </code></pre><h5 id="5-2-测试"><a href="#5-2-测试" class="headerlink" title="5.2 测试"></a>5.2 测试</h5><pre><code class="java">@Testpublic void testSayHello()&#123;    //通过ioc容器获取UserServlet的对象    UserServlet userServlet = (UserServlet) act.getBean(&quot;userServlet&quot;);    //调用UserServlet的sayHello()方法    userServlet.sayHello();&#125;</code></pre><h3 id="第三节-Bean的作用域和生命周期"><a href="#第三节-Bean的作用域和生命周期" class="headerlink" title="第三节 Bean的作用域和生命周期"></a>第三节 Bean的作用域和生命周期</h3><h4 id="1-Bean的作用域"><a href="#1-Bean的作用域" class="headerlink" title="1. Bean的作用域"></a>1. Bean的作用域</h4><h5 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h5><p>在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表：</p><table><thead><tr><th>取值</th><th>含义</th><th>创建对象的时机</th></tr></thead><tbody><tr><td>singleton</td><td>在IOC容器中，这个bean的对象始终为单实例</td><td>IOC容器初始化时</td></tr><tr><td>prototype</td><td>这个bean在IOC容器中有多个实例</td><td>获取bean时</td></tr></tbody></table><p>如果是在WebApplicationContext环境下还会有另外两个作用域（但几乎不用）：</p><table><thead><tr><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>request</td><td>在一个请求范围内有效</td></tr><tr><td>session</td><td>在一个会话范围内有效</td></tr></tbody></table><h5 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2 配置"></a>1.2 配置</h5><pre><code class="xml">&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;&lt;bean id=&quot;happyComment&quot; scope=&quot;prototype&quot; class=&quot;com.atguigu.component.HappyComment&quot;&gt;&lt;/bean&gt;</code></pre><h5 id="1-3-测试"><a href="#1-3-测试" class="headerlink" title="1.3 测试"></a>1.3 测试</h5><pre><code class="java">@Testpublic void testGetBean() &#123;    HappyComment happyComment01 = (HappyComment) act.getBean(&quot;happyComment&quot;);    HappyComment happyComment02 = (HappyComment) act.getBean(&quot;happyComment&quot;);        System.out.println(happyComment01 == happyComment02);&#125;</code></pre><h4 id="2-Bean的生命周期-了解"><a href="#2-Bean的生命周期-了解" class="headerlink" title="2. Bean的生命周期(了解)"></a>2. Bean的生命周期(了解)</h4><h5 id="2-1-bean的生命周期清单"><a href="#2-1-bean的生命周期清单" class="headerlink" title="2.1 bean的生命周期清单"></a>2.1 bean的生命周期清单</h5><ul><li>bean对象创建（调用无参构造器）</li><li>给bean对象设置属性（依赖注入）</li><li>bean对象初始化之前操作（由bean的后置处理器前置方法负责）</li><li>bean对象初始化（需在配置bean时指定初始化方法）</li><li>bean对象初始化之后操作（由bean的后置处理器后置方法负责）</li><li>bean对象就绪可以使用</li><li>bean对象销毁（需在配置bean时指定销毁方法）</li><li>IOC容器关闭</li></ul><h5 id="2-2-指定bean的初始化方法和销毁方法"><a href="#2-2-指定bean的初始化方法和销毁方法" class="headerlink" title="2.2 指定bean的初始化方法和销毁方法"></a>2.2 指定bean的初始化方法和销毁方法</h5><h6 id="2-2-1-创建两个方法作为初始化和销毁方法"><a href="#2-2-1-创建两个方法作为初始化和销毁方法" class="headerlink" title="2.2.1 创建两个方法作为初始化和销毁方法"></a>2.2.1 创建两个方法作为初始化和销毁方法</h6><p>用com.atguigu.component.HappyComponent类测试，在类中加俩方法： </p><pre><code class="java">package com.atguigu.component;/** * 包名:PACKAGE_NAME * * 日期2021-08-29  16:02 * 目标:让HappyComponent对象创建的时候，就执行initLifeCircle()方法，在HappyComponent对象销毁之前就执行destroyLifeCircle() */public class HappyComponent &#123;    public void initLifeCircle()&#123;        System.out.println(&quot;HappyComponent对象创建了，我可以做一些初始化操作...&quot;);    &#125;    public void destroyLifeCircle()&#123;        System.out.println(&quot;HappyComponent对象销毁了，我可以做一些数据备份工作...&quot;);    &#125;    public void sayHello()&#123;        System.out.println(&quot;hello world&quot;);    &#125;&#125;</code></pre><h6 id="2-2-2-配置bean时指定初始化和销毁方法"><a href="#2-2-2-配置bean时指定初始化和销毁方法" class="headerlink" title="2.2.2 配置bean时指定初始化和销毁方法"></a>2.2.2 配置bean时指定初始化和销毁方法</h6><pre><code class="xml">&lt;!--        bean标签的scope属性表示这个Bean对象的范围:            1. singleton(默认取值): 单例            2. prototype: 多例        bean标签的init-method属性是用于配置这个Bean对象的初始化方法,        bean标签的destroy-method属性是用于配置这个Bean对象的销毁方法    --&gt;&lt;bean id=&quot;happyComponent&quot; class=&quot;com.atguigu.component.HappyComponent&quot;      scope=&quot;prototype&quot;      init-method=&quot;initLifeCircle&quot;      destroy-method=&quot;destroyLifeCircle&quot;&gt;&lt;/bean&gt;</code></pre><h5 id="2-3-bean的后置处理器"><a href="#2-3-bean的后置处理器" class="headerlink" title="2.3 bean的后置处理器"></a>2.3 bean的后置处理器</h5><h6 id="2-3-1-创建后置处理器类"><a href="#2-3-1-创建后置处理器类" class="headerlink" title="2.3.1 创建后置处理器类"></a>2.3.1 创建后置处理器类</h6><pre><code class="java">package com.atguigu.ioc.process;    import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;    // 声明一个自定义的bean后置处理器// 注意：bean后置处理器不是单独针对某一个bean生效，而是针对IOC容器中所有bean都会执行public class MyHappyBeanProcessor implements BeanPostProcessor &#123;        @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;            System.out.println(&quot;☆☆☆&quot; + beanName + &quot; = &quot; + bean);            return bean;    &#125;        @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;            System.out.println(&quot;★★★&quot; + beanName + &quot; = &quot; + bean);            return bean;    &#125;&#125;</code></pre><h6 id="2-3-2-把bean的后置处理器放入IOC容器"><a href="#2-3-2-把bean的后置处理器放入IOC容器" class="headerlink" title="2.3.2 把bean的后置处理器放入IOC容器"></a>2.3.2 把bean的后置处理器放入IOC容器</h6><pre><code class="xml">&lt;!-- bean的后置处理器要放入IOC容器才能生效 --&gt;&lt;bean id=&quot;myHappyBeanProcessor&quot; class=&quot;com.atguigu.ioc.process.MyHappyBeanProcessor&quot;/&gt;</code></pre><h6 id="2-3-3-执行效果示例"><a href="#2-3-3-执行效果示例" class="headerlink" title="2.3.3 执行效果示例"></a>2.3.3 执行效果示例</h6><blockquote><p>HappyComponent创建对象 </p><p>HappyComponent要设置属性了 </p><p>☆☆☆happyComponent = com.atguigu.ioc.component.HappyComponent@ca263c2 </p><p>HappyComponent初始化 </p><p>★★★happyComponent = com.atguigu.ioc.component.HappyComponent@ca263c2 HappyComponent销毁</p></blockquote><h3 id="第四节-FactoryBean机制-了解"><a href="#第四节-FactoryBean机制-了解" class="headerlink" title="第四节 FactoryBean机制(了解)"></a>第四节 FactoryBean机制(了解)</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><p>FactoryBean是Spring提供的一种整合第三方框架的常用机制。和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值。通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。</p><p>将来我们整合Mybatis时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。</p><p>源码:</p><pre><code class="java">/* * Copyright 2002-2020 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.beans.factory;import org.springframework.lang.Nullable;/** * Interface to be implemented by objects used within a &#123;@link BeanFactory&#125; which * are themselves factories for individual objects. If a bean implements this * interface, it is used as a factory for an object to expose, not directly as a * bean instance that will be exposed itself. * * &lt;p&gt;&lt;b&gt;NB: A bean that implements this interface cannot be used as a normal bean.&lt;/b&gt; * A FactoryBean is defined in a bean style, but the object exposed for bean * references (&#123;@link #getObject()&#125;) is always the object that it creates. * * &lt;p&gt;FactoryBeans can support singletons and prototypes, and can either create * objects lazily on demand or eagerly on startup. The &#123;@link SmartFactoryBean&#125; * interface allows for exposing more fine-grained behavioral metadata. * * &lt;p&gt;This interface is heavily used within the framework itself, for example for * the AOP &#123;@link org.springframework.aop.framework.ProxyFactoryBean&#125; or the * &#123;@link org.springframework.jndi.JndiObjectFactoryBean&#125;. It can be used for * custom components as well; however, this is only common for infrastructure code. * * &lt;p&gt;&lt;b&gt;&#123;@code FactoryBean&#125; is a programmatic contract. Implementations are not * supposed to rely on annotation-driven injection or other reflective facilities.&lt;/b&gt; * &#123;@link #getObjectType()&#125; &#123;@link #getObject()&#125; invocations may arrive early in the * bootstrap process, even ahead of any post-processor setup. If you need access to * other beans, implement &#123;@link BeanFactoryAware&#125; and obtain them programmatically. * * &lt;p&gt;&lt;b&gt;The container is only responsible for managing the lifecycle of the FactoryBean * instance, not the lifecycle of the objects created by the FactoryBean.&lt;/b&gt; Therefore, * a destroy method on an exposed bean object (such as &#123;@link java.io.Closeable#close()&#125; * will &lt;i&gt;not&lt;/i&gt; be called automatically. Instead, a FactoryBean should implement * &#123;@link DisposableBean&#125; and delegate any such close call to the underlying object. * * &lt;p&gt;Finally, FactoryBean objects participate in the containing BeanFactory&#39;s * synchronization of bean creation. There is usually no need for internal * synchronization other than for purposes of lazy initialization within the * FactoryBean itself (or the like). * * @author Rod Johnson * @author Juergen Hoeller * @since 08.03.2003 * @param &lt;T&gt; the bean type * @see org.springframework.beans.factory.BeanFactory * @see org.springframework.aop.framework.ProxyFactoryBean * @see org.springframework.jndi.JndiObjectFactoryBean */public interface FactoryBean&lt;T&gt; &#123;    /**     * The name of an attribute that can be     * &#123;@link org.springframework.core.AttributeAccessor#setAttribute set&#125; on a     * &#123;@link org.springframework.beans.factory.config.BeanDefinition&#125; so that     * factory beans can signal their object type when it can&#39;t be deduced from     * the factory bean class.     * @since 5.2     */    String OBJECT_TYPE_ATTRIBUTE = &quot;factoryBeanObjectType&quot;;            /**     * Return an instance (possibly shared or independent) of the object     * managed by this factory.     * &lt;p&gt;As with a &#123;@link BeanFactory&#125;, this allows support for both the     * Singleton and Prototype design pattern.     * &lt;p&gt;If this FactoryBean is not fully initialized yet at the time of     * the call (for example because it is involved in a circular reference),     * throw a corresponding &#123;@link FactoryBeanNotInitializedException&#125;.     * &lt;p&gt;As of Spring 2.0, FactoryBeans are allowed to return &#123;@code null&#125;     * objects. The factory will consider this as normal value to be used; it     * will not throw a FactoryBeanNotInitializedException in this case anymore.     * FactoryBean implementations are encouraged to throw     * FactoryBeanNotInitializedException themselves now, as appropriate.     * @return an instance of the bean (can be &#123;@code null&#125;)     * @throws Exception in case of creation errors     * @see FactoryBeanNotInitializedException     */    @Nullable    T getObject() throws Exception;        /**     * Return the type of object that this FactoryBean creates,     * or &#123;@code null&#125; if not known in advance.     * &lt;p&gt;This allows one to check for specific types of beans without     * instantiating objects, for example on autowiring.     * &lt;p&gt;In the case of implementations that are creating a singleton object,     * this method should try to avoid singleton creation as far as possible;     * it should rather estimate the type in advance.     * For prototypes, returning a meaningful type here is advisable too.     * &lt;p&gt;This method can be called &lt;i&gt;before&lt;/i&gt; this FactoryBean has     * been fully initialized. It must not rely on state created during     * initialization; of course, it can still use such state if available.     * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Autowiring will simply ignore FactoryBeans that return     * &#123;@code null&#125; here. Therefore it is highly recommended to implement     * this method properly, using the current state of the FactoryBean.     * @return the type of object that this FactoryBean creates,     * or &#123;@code null&#125; if not known at the time of the call     * @see ListableBeanFactory#getBeansOfType     */    @Nullable    Class&lt;?&gt; getObjectType();        /**     * Is the object managed by this factory a singleton? That is,     * will &#123;@link #getObject()&#125; always return the same object     * (a reference that can be cached)?     * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; If a FactoryBean indicates to hold a singleton object,     * the object returned from &#123;@code getObject()&#125; might get cached     * by the owning BeanFactory. Hence, do not return &#123;@code true&#125;     * unless the FactoryBean always exposes the same reference.     * &lt;p&gt;The singleton status of the FactoryBean itself will generally     * be provided by the owning BeanFactory; usually, it has to be     * defined as singleton there.     * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; This method returning &#123;@code false&#125; does not     * necessarily indicate that returned objects are independent instances.     * An implementation of the extended &#123;@link SmartFactoryBean&#125; interface     * may explicitly indicate independent instances through its     * &#123;@link SmartFactoryBean#isPrototype()&#125; method. Plain &#123;@link FactoryBean&#125;     * implementations which do not implement this extended interface are     * simply assumed to always return independent instances if the     * &#123;@code isSingleton()&#125; implementation returns &#123;@code false&#125;.     * &lt;p&gt;The default implementation returns &#123;@code true&#125;, since a     * &#123;@code FactoryBean&#125; typically manages a singleton instance.     * @return whether the exposed object is a singleton     * @see #getObject()     * @see SmartFactoryBean#isPrototype()     */    default boolean isSingleton() &#123;        return true;    &#125;&#125;</code></pre><h4 id="2-实现FactoryBean接口"><a href="#2-实现FactoryBean接口" class="headerlink" title="2. 实现FactoryBean接口"></a>2. 实现FactoryBean接口</h4><pre><code class="java">package com.atguigu.component;import org.springframework.beans.factory.FactoryBean;/** * 包名:com.atguigu.component * * 日期2021-08-31  09:03 * 要使用FactoryBean机制就得写一个类实现FactoryBean接口,接口的泛型表示你想通过这个FactoryBean创建什么对象 * * FactoryBean机制:你在spring的配置文件中进行IOC配置的是HappyComponentFactoryBean类，但是真正创建出来存储在核心容器中的对象是 *                HappyComponentFactoryBean对象调用getObject()方法所获取的对象(HappyComponent) */public class HappyComponentFactoryBean implements FactoryBean&lt;HappyComponent&gt; &#123;    private String componentName;    public void setComponentName(String componentName) &#123;        this.componentName = componentName;    &#125;    @Override    public HappyComponent getObject() throws Exception &#123;        HappyComponent happyComponent = new HappyComponent();        happyComponent.setComponentName(componentName);        return happyComponent;    &#125;    @Override    public Class&lt;?&gt; getObjectType() &#123;        return null;    &#125;&#125;</code></pre><h4 id="3-配置bean"><a href="#3-配置bean" class="headerlink" title="3. 配置bean"></a>3. 配置bean</h4><pre><code class="xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;           xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;        &lt;bean id=&quot;happyComponent&quot; class=&quot;com.atguigu.component.HappyComponentFactoryBean&quot;&gt;            &lt;property name=&quot;componentName&quot; value=&quot;奥巴马&quot;&gt;&lt;/property&gt;        &lt;/bean&gt;    &lt;/beans&gt;</code></pre><h4 id="4-测试获取bean"><a href="#4-测试获取bean" class="headerlink" title="4. 测试获取bean"></a>4. 测试获取bean</h4><pre><code class="java">package com.atguigu;import com.atguigu.component.HappyComponent;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestFactoryBean &#123;    @Test    public void testGetBean()&#123;        //1. 创建核心容器        ApplicationContext act = new ClassPathXmlApplicationContext(&quot;spring-application.xml&quot;);        //2.从核心容器中获取对象        HappyComponent happyComponent = (HappyComponent) act.getBean(&quot;happyComponent&quot;);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA导入Spring源码</title>
      <link href="/2021/12/03/IDEA_Import_SpringCode/"/>
      <url>/2021/12/03/IDEA_Import_SpringCode/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA导入Spring源码"><a href="#IDEA导入Spring源码" class="headerlink" title="IDEA导入Spring源码"></a>IDEA导入Spring源码</h1><h2 id="1-下载spring源码"><a href="#1-下载spring源码" class="headerlink" title="1.下载spring源码"></a>1.下载spring源码</h2><p> Spring源码现在在由github托管,git地址</p><blockquote><p><a href="https://github.com/spring-projects/spring-framework/tree/5.1.x">https://github.com/spring-projects/spring-framework/tree/5.1.x</a></p><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126191825760.png" alt="image-20211126191825760"></p></blockquote><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126191900085.png" alt="image-20211126191900085"></p><p>先把源码下载好，推荐5.0X或者5.1X</p><h2 id="2-下载gradle"><a href="#2-下载gradle" class="headerlink" title="2.下载gradle"></a>2.下载gradle</h2><p>安装配置gradle环境变量</p><ul><li>To build you will need Git and JDK 8 update 60 or later. Be sure that your JAVA_HOME environment variable points to the jdk1.8.0 folder extracted from the JDK download.</li></ul><p>所以安装前要确保javahome在jdk<strong>1.8.0.60</strong>以上版本 </p><p>在下载之前，先找到我们下载的源码，spring-framework\gradle\wrapper下面的gradle-wrapper.properties文件，</p><p>打开先瞅两眼！</p><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126194001815.png" alt="/image-20211126194001815"></p><p>打开后可以看到 默认是去gradle仓库下载指定版本的，</p><p>所以接下来我们下载的时候最好下载适配版本，不然很容易出现各种奇奇怪怪的错误。</p><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126194132893.png" alt="/image-20211126194132893"></p><p>gradle下载地址</p><blockquote><p><a href="https://services.gradle.org/distributions/">https://services.gradle.org/distributions/</a></p></blockquote><p>配置gradle的环境变量</p><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126192740437.png" alt="/image-20211126192740437"></p><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126192813164.png" alt="image-20211126192813164"></p><p>下面这个是gradle的仓库位置，自己选地方放就行了，注意二级目录是.gradle不能改。</p><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126192852129.png" alt="image-20211126192852129"></p><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126193015207.png" alt="image-20211126193015207"></p><p>如果不改的话默认就会在C盘用户下面的创建一个.gradle</p><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126195925377.png" alt="image-20211126195925377"></p><p>最后把path添加上</p><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126193245885.png" alt="image-20211126193245885"></p><p>配好之后可以在cmd上输入 gradle -v检测是否配成功</p><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126193343526.png" alt="image-20211126193343526"></p><p>其实这一步不做也可以，主要是为了之后使用方便，如果是单纯的构建源码可以省略这步。</p><h2 id="3-构建源码"><a href="#3-构建源码" class="headerlink" title="3.构建源码"></a>3.构建源码</h2><p>我们先选中下载好的源码，直接open打开即可。</p><p>先打开IDEA的Settings  –&gt; Plugins 检查有没有下载好插件</p><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126193538024.png" alt="image-20211126193538024"></p><p>插件安装好之后 在Settings找到Gradle</p><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126193820036.png" alt="image-20211126193820036"></p><p>可以看到这里可以选择是用gradle-wrapper.properties指定的地址下载gradle，默认会先去你指定的仓库先找，找不到就去下载。也可以使用本地的gradle。建议使用本地gradle。</p><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126195251922.png" alt="image-20211126195251922"></p><p>配置好之后 我们找到build.gradle文件，配置上国内镜像 下载速度会快很多</p><pre><code class="properties">allprojects &#123;            repositories &#123;                maven &#123; url &#39;https://maven.aliyun.com/repository/gradle-plugin&#39; &#125;                maven &#123; url &#39;https://maven.aliyun.com/repository/google&#39; &#125;                maven &#123; url &#39;https://maven.aliyun.com/repository/jcenter&#39;&#125;            &#125;        &#125;</code></pre><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126195730078.png" alt="image-20211126195730078"></p><p>然后等待构建完成即可</p><h2 id="4-常见错误"><a href="#4-常见错误" class="headerlink" title="4.常见错误"></a>4.常见错误</h2><p>这里列举一些遇到的坑</p><p>第一个</p><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126200402355.png" alt="image-20211126200402355"></p><p>报找不到这个插件，反正网上试了各种办法都不行，然后换了个idea就没这个错误了。。。这个错误用的是IDEA2019.3.1报的。然后我用2018.2.3和2021.1都没这个问题。感兴趣的自己钻研。。。。。。。</p><p>附上版本适配图</p><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126200816658.png" alt="image-20211126200816658"></p><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126200826599.png" alt="image-20211126200826599"></p><p>第二个  </p><pre><code class="java">Unable to find method &#39;org.gradle.api.artifacts.result.ComponentSelectionReason.getDescription()Ljava/lang/String;&#39;.Possible causes for this unexpected error include:&lt;ul&gt;&lt;li&gt;Gradle&#39;s dependency cache may be corrupt (this sometimes occurs after a network connection timeout.)Re-download dependencies and sync project (requires network)&lt;/li&gt;&lt;li&gt;The state of a Gradle build process (daemon) may be corrupt. Stopping all Gradle daemons may solve this problem.Stop Gradle build processes (requires restart)&lt;/li&gt;&lt;li&gt;Your project may be using a third-party plugin which is not compatible with the other plugins in the project or the version of Gradle requested by the project.&lt;/li&gt;&lt;/ul&gt;In the case of corrupt Gradle processes, you can also try closing the IDE and then killing all Java processes.</code></pre><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126200934973.png" alt="image-20211126200934973"></p><p>这个问题出现的可能有两种，</p><p>1、gradle不适配，换几个试试。gradle得和spring源码还有IDEA都适配。巨坑</p><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126201658911.png" alt="image-20211126201658911"></p><p>2、IDEA版本太低！就是这个问题搞了我三个小时！！！！我用2021.1的IDEA就解决了这个错误</p><p>第三个</p><p><img src="http://www.slx.blue/2021/12/03/IDEA_Import_SpringCode/image-20211126201335041.png" alt="image-20211126201335041"></p><p>这个错误。。，gradle版本太低了。和源码不适配，得往高了换。换了一般都能解决。</p><p>第四个</p><pre><code class="java">Caused by: java.lang.NoSuchMethodError: org.gradle.api.artifacts.ProjectDependency.getConfiguration</code></pre><p>如果 <em>build.gradle</em> 文件包含 <strong>spring-boot-gradle-plugin，</strong>升级其版本 或者其他插件版本低了</p><p>第五个 jar包找不到问题，百度很好解决。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis-缓存</title>
      <link href="/2021/12/03/mybatis04/"/>
      <url>/2021/12/03/mybatis04/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis-day04"><a href="#Mybatis-day04" class="headerlink" title="Mybatis-day04"></a>Mybatis-day04</h1><h2 id="第一章-Mybatis的缓存机制"><a href="#第一章-Mybatis的缓存机制" class="headerlink" title="第一章 Mybatis的缓存机制"></a>第一章 Mybatis的缓存机制</h2><h3 id="第一节-缓存机制的概述"><a href="#第一节-缓存机制的概述" class="headerlink" title="第一节 缓存机制的概述"></a>第一节 缓存机制的概述</h3><h4 id="1-什么是缓存"><a href="#1-什么是缓存" class="headerlink" title="1. 什么是缓存"></a>1. 什么是缓存</h4><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_004.png"></p><h4 id="2-一级缓存和二级缓存的对比"><a href="#2-一级缓存和二级缓存的对比" class="headerlink" title="2. 一级缓存和二级缓存的对比"></a>2. 一级缓存和二级缓存的对比</h4><h5 id="2-1-使用顺序"><a href="#2-1-使用顺序" class="headerlink" title="2.1 使用顺序"></a>2.1 使用顺序</h5><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_005.png"></p><p>查询的顺序是：</p><ul><li>先查询二级缓存，因为二级缓存中可能会有其他SqlSession已经查出来的数据，可以拿来直接使用。</li><li>如果二级缓存没有命中，再查询一级缓存</li><li>如果一级缓存也没有命中，则查询数据库</li><li>SqlSession关闭之前，一级缓存中的数据会写入二级缓存</li></ul><h5 id="2-2-作用范围"><a href="#2-2-作用范围" class="headerlink" title="2.2 作用范围"></a>2.2 作用范围</h5><ul><li>一级缓存：SqlSession级别</li><li>二级缓存：SqlSessionFactory级别</li></ul><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_006.png"></p><p> 它们之间范围的大小参考下面图： </p><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_007.png"></p><h3 id="第二节-一级缓存"><a href="#第二节-一级缓存" class="headerlink" title="第二节 一级缓存"></a>第二节 一级缓存</h3><h4 id="1-代码验证一级缓存"><a href="#1-代码验证一级缓存" class="headerlink" title="1 代码验证一级缓存"></a>1 代码验证一级缓存</h4><pre><code class="java">@Testpublic void testFirstLevelCache()&#123;    //验证一级缓存的存在:要求两次查询使用的是同一个sqlSession对象    //一级缓存是Mybatis自动开启的，不需要配置，也无法关闭(表示你必须使用一级缓存)    SqlSession sqlSession = sessionFactory.openSession();    EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class);    Employee employee1 = employeeMapper.selectEmployee(7);    System.out.println(employee1);    //一级缓存什么时候会被清除呢?    //1. sqlSession提交事务   2. sqlSession调用clearCache()方法    //3. sqlSession被销毁了close()一级缓存的内容会被写入到二级缓存    //4. 数据发生改变:其实并没有清除一级缓存，而是修改缓存中数据    SqlSession sqlSession2 = sessionFactory.openSession();    EmployeeMapper employeeMapper2 = sqlSession2.getMapper(EmployeeMapper.class);    employee1.setEmpName(&quot;zs&quot;);    employeeMapper2.updateEmployee(employee1);    sqlSession2.commit();    Employee employee2 = employeeMapper.selectEmployee(7);    System.out.println(employee2);&#125;</code></pre><p>一共只打印了一条SQL语句。 </p><h4 id="2-一级缓存失效的情况"><a href="#2-一级缓存失效的情况" class="headerlink" title="2 一级缓存失效的情况"></a>2 一级缓存失效的情况</h4><ul><li>不是同一个SqlSession(因为一级缓存只能用在同一个SqlSession中)</li><li>同一个SqlSession但是查询条件发生了变化</li><li>同一个SqlSession两次查询期间执行了任何一次增删改操作,那么会改变缓存的数据</li><li>同一个SqlSession两次查询期间手动清空了缓存: 调用sqlSession的clearCache()方法</li><li>同一个SqlSession两次查询期间提交了事务: 调用sqlSession的commit()方法</li></ul><h3 id="第三节-二级缓存"><a href="#第三节-二级缓存" class="headerlink" title="第三节 二级缓存"></a>第三节 二级缓存</h3><h4 id="1-代码测试二级缓存"><a href="#1-代码测试二级缓存" class="headerlink" title="1 代码测试二级缓存"></a>1 代码测试二级缓存</h4><h5 id="1-1-开启二级缓存功能"><a href="#1-1-开启二级缓存功能" class="headerlink" title="1.1 开启二级缓存功能"></a>1.1 开启二级缓存功能</h5><p>在想要使用二级缓存的Mapper配置文件中加入cache标签</p><pre><code class="xml">&lt;!-- 加入cache标签启用二级缓存功能 --&gt;&lt;cache/&gt;</code></pre><h5 id="1-2-让实体类支持序列化"><a href="#1-2-让实体类支持序列化" class="headerlink" title="1.2 让实体类支持序列化"></a>1.2 让实体类支持序列化</h5><pre><code class="java">public class Employee implements Serializable &#123;&#125;</code></pre><h5 id="1-3-junit测试"><a href="#1-3-junit测试" class="headerlink" title="1.3 junit测试"></a>1.3 junit测试</h5><p>这个功能的测试操作需要将SqlSessionFactory对象设置为成员变量 </p><pre><code class="java">@Testpublic void testSecondCacheLevel()&#123;    //测试二级缓存的存在:二级缓存是使用在不同的SqlSession中，但是是同一个SqlSessionFactory    //二级缓存不是Mybatis自动开启的，需要我们手动进行配置    //1. 在要进行二级缓存的映射配置文件中开启二级缓存(使用&lt;cache/&gt;标签)    //2. 要进行二级缓存的POJO类需要实现Serializable接口(进行序列化:将对象的数据存储到硬盘中)    //3. 二级缓存的创建时机(什么时候数据会写入到二级缓存中):sqlSession对象close()的时候    SqlSession sqlSession1 = sessionFactory.openSession();    EmployeeMapper employeeMapper1 = sqlSession1.getMapper(EmployeeMapper.class);    SqlSession sqlSession2 = sessionFactory.openSession();    EmployeeMapper employeeMapper2 = sqlSession2.getMapper(EmployeeMapper.class);    Employee employee1 = employeeMapper1.selectEmployee(7);    System.out.println(employee1);    //sqlSession1关闭，那么sqlSession1查询到的数据就会写入到二级缓存中    sqlSession1.close();    Employee employee2 = employeeMapper2.selectEmployee(7);    System.out.println(employee2);    sqlSession2.close();&#125;</code></pre><h5 id="1-4-缓存命中率"><a href="#1-4-缓存命中率" class="headerlink" title="1.4 缓存命中率"></a>1.4 缓存命中率</h5><p>日志中打印的Cache Hit Ratio叫做缓存命中率 </p><pre><code>Cache Hit Ratio [com.atguigu.mybatis.EmployeeMapper]: 0.0（0/1)Cache Hit Ratio [com.atguigu.mybatis.EmployeeMapper]: 0.5（1/2）Cache Hit Ratio [com.atguigu.mybatis.EmployeeMapper]: 0.6666666666666666（2/3）Cache Hit Ratio [com.atguigu.mybatis.EmployeeMapper]: 0.75（3/4）Cache Hit Ratio [com.atguigu.mybatis.EmployeeMapper]: 0.8（4/5）</code></pre><p>缓存命中率=命中缓存的次数/查询的总次数 </p><h4 id="2-查询结果存入二级缓存的时机"><a href="#2-查询结果存入二级缓存的时机" class="headerlink" title="2 查询结果存入二级缓存的时机"></a>2 查询结果存入二级缓存的时机</h4><p>结论：SqlSession关闭的时候，一级缓存中的内容会被存入二级缓存 </p><pre><code class="java">// 1.开启两个SqlSessionSqlSession session01 = factory.openSession();SqlSession session02 = factory.openSession();    // 2.获取两个EmployeeMapperEmployeeMapper employeeMapper01 = session01.getMapper(EmployeeMapper.class);EmployeeMapper employeeMapper02 = session02.getMapper(EmployeeMapper.class);    // 3.使用两个EmployeeMapper做两次查询，返回两个Employee对象Employee employee01 = employeeMapper01.selectEmployeeById(2);Employee employee02 = employeeMapper02.selectEmployeeById(2);    // 4.比较两个Employee对象System.out.println(&quot;employee02.equals(employee01) = &quot; + employee02.equals(employee01));</code></pre><p>上面代码打印的结果是： </p><pre><code>DEBUG 12-01 10:10:32,209 Cache Hit Ratio [com.atguigu.mybatis.EmployeeMapper]: 0.0  (LoggingCache.java:62) DEBUG 12-01 10:10:32,570 ==&gt;  Preparing: select emp_id,emp_name,emp_salary,emp_gender,emp_age from t_emp where emp_id=?   (BaseJdbcLogger.java:145) DEBUG 12-01 10:10:32,624 ==&gt; Parameters: 2(Integer)  (BaseJdbcLogger.java:145) DEBUG 12-01 10:10:32,643 &lt;==      Total: 1  (BaseJdbcLogger.java:145) DEBUG 12-01 10:10:32,644 Cache Hit Ratio [com.atguigu.mybatis.EmployeeMapper]: 0.0  (LoggingCache.java:62) DEBUG 12-01 10:10:32,661 ==&gt;  Preparing: select emp_id,emp_name,emp_salary,emp_gender,emp_age from t_emp where emp_id=?   (BaseJdbcLogger.java:145) DEBUG 12-01 10:10:32,662 ==&gt; Parameters: 2(Integer)  (BaseJdbcLogger.java:145) DEBUG 12-01 10:10:32,665 &lt;==      Total: 1  (BaseJdbcLogger.java:145) employee02.equals(employee01) = false</code></pre><p>修改代码： </p><pre><code class="java">// 1.开启两个SqlSessionSqlSession session01 = factory.openSession();SqlSession session02 = factory.openSession();    // 2.获取两个EmployeeMapperEmployeeMapper employeeMapper01 = session01.getMapper(EmployeeMapper.class);EmployeeMapper employeeMapper02 = session02.getMapper(EmployeeMapper.class);    // 3.使用两个EmployeeMapper做两次查询，返回两个Employee对象Employee employee01 = employeeMapper01.selectEmployeeById(2);    // ※第一次查询完成后，把所在的SqlSession关闭，使一级缓存中的数据存入二级缓存session01.close();Employee employee02 = employeeMapper02.selectEmployeeById(2);    // 4.比较两个Employee对象System.out.println(&quot;employee02.equals(employee01) = &quot; + employee02.equals(employee01));    // 5.另外一个SqlSession用完正常关闭session02.close();</code></pre><p> 打印结果： </p><pre><code>DEBUG 12-01 10:14:06,804 Cache Hit Ratio [com.atguigu.mybatis.EmployeeMapper]: 0.0  (LoggingCache.java:62) DEBUG 12-01 10:14:07,135 ==&gt;  Preparing: select emp_id,emp_name,emp_salary,emp_gender,emp_age from t_emp where emp_id=?   (BaseJdbcLogger.java:145) DEBUG 12-01 10:14:07,202 ==&gt; Parameters: 2(Integer)  (BaseJdbcLogger.java:145) DEBUG 12-01 10:14:07,224 &lt;==      Total: 1  (BaseJdbcLogger.java:145) DEBUG 12-01 10:14:07,308 Cache Hit Ratio [com.atguigu.mybatis.EmployeeMapper]: 0.5  (LoggingCache.java:62) employee02.equals(employee01) = false</code></pre><h4 id="3-二级缓存相关配置-了解"><a href="#3-二级缓存相关配置-了解" class="headerlink" title="3 二级缓存相关配置(了解)"></a>3 二级缓存相关配置(了解)</h4><p>在Mapper配置文件中添加的cache标签可以设置一些属性：</p><ul><li><p>eviction属性：缓存回收策略</p><p>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。</p><p>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。</p><p>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。</p><p>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</p><p>默认的是 LRU。</p></li><li><p>flushInterval属性：刷新间隔，单位毫秒</p><p>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新</p></li><li><p>size属性：引用数目，正整数</p><p>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</p></li><li><p>readOnly属性：只读，true/false</p><p>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。</p><p>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是 false。</p></li></ul><h3 id="第四节-整合EHCache"><a href="#第四节-整合EHCache" class="headerlink" title="第四节 整合EHCache"></a>第四节 整合EHCache</h3><h4 id="1-EHCache简介"><a href="#1-EHCache简介" class="headerlink" title="1. EHCache简介"></a>1. EHCache简介</h4><p>Ehcache 是一种开源的、基于标准的缓存，可提高性能、卸载数据库并简化可扩展性。它是最广泛使用的基于 Java 的缓存，因为它健壮、经过验证、功能齐全，并且与其他流行的库和框架集成。 Ehcache 从进程内缓存一直扩展到具有 TB 级缓存的混合进程内/进程外部署。  官网地址为:  <a href="https://www.ehcache.org/">https://www.ehcache.org/</a> </p><h4 id="2-Mybatis整合操作"><a href="#2-Mybatis整合操作" class="headerlink" title="2. Mybatis整合操作"></a>2. Mybatis整合操作</h4><h5 id="2-1-添加依赖"><a href="#2-1-添加依赖" class="headerlink" title="2.1 添加依赖"></a>2.1 添加依赖</h5><pre><code class="xml">&lt;!-- Mybatis EHCache整合包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;    &lt;version&gt;1.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- slf4j日志门面的一个具体实现 --&gt;&lt;dependency&gt;    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;    &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><h5 id="2-2-创建EHCache配置文件"><a href="#2-2-创建EHCache配置文件" class="headerlink" title="2.2 创建EHCache配置文件"></a>2.2 创建EHCache配置文件</h5><p>ehcache.xml</p><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_008.png"></p><p>文件内容</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt;    &lt;!-- 磁盘保存路径 --&gt;    &lt;diskStore path=&quot;D:\atguigu\ehcache&quot;/&gt;    &lt;!--    maxElementsInMemory:设置 在内存中缓存 对象的个数    maxElementsOnDisk：设置 在硬盘中缓存 对象的个数    eternal：设置缓存是否 永远不过期    overflowToDisk：当系统宕机的时候是否保存到磁盘上    maxElementsInMemory的时候，是否转移到硬盘中    timeToIdleSeconds：当2次访问 超过该值的时候，将缓存对象失效    timeToLiveSeconds：一个缓存对象 最多存放的时间（生命周期）    diskExpiryThreadIntervalSeconds：设置每隔多长时间，通过一个线程来清理硬盘中的缓存    clearOnFlush: 内存数量最大时是否清除    memoryStoreEvictionPolicy：当超过缓存对象的最大值时，处理的策略；LRU (最少使用)，FIFO (先进先出), LFU (最少访问次数)    --&gt;    &lt;defaultCache                  maxElementsInMemory=&quot;1000&quot;                  maxElementsOnDisk=&quot;10000000&quot;                  eternal=&quot;false&quot;                  overflowToDisk=&quot;true&quot;                  timeToIdleSeconds=&quot;120&quot;                  timeToLiveSeconds=&quot;120&quot;                  diskExpiryThreadIntervalSeconds=&quot;120&quot;                  memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;    &lt;/defaultCache&gt;&lt;/ehcache&gt;</code></pre><p>引入第三方框架或工具时，配置文件的文件名可以自定义吗？</p><ul><li>可以自定义：文件名是由我告诉其他环境</li><li>不能自定义：文件名是框架内置的、约定好的，就不能自定义，以避免框架无法加载这个文件</li></ul><h5 id="2-3-指定缓存管理器的具体类型"><a href="#2-3-指定缓存管理器的具体类型" class="headerlink" title="2.3 指定缓存管理器的具体类型"></a>2.3 指定缓存管理器的具体类型</h5><p>还是到查询操作所的Mapper配置文件中，找到之前设置的cache标签： </p><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_009.png"></p><pre><code class="xml">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;</code></pre><h5 id="2-4-加入logback日志"><a href="#2-4-加入logback日志" class="headerlink" title="2.4 加入logback日志"></a>2.4 加入logback日志</h5><p>存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。 </p><h6 id="2-4-1-各种Java日志框架简介"><a href="#2-4-1-各种Java日志框架简介" class="headerlink" title="2.4.1 各种Java日志框架简介"></a>2.4.1 各种Java日志框架简介</h6><p>门面：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>JCL（Jakarta Commons Logging）</td><td>陈旧</td></tr><tr><td>SLF4J（Simple Logging Facade for Java）★</td><td>适合</td></tr><tr><td>jboss-logging</td><td>特殊专业领域使用</td></tr></tbody></table><p>实现：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>log4j★</td><td>最初版</td></tr><tr><td>JUL（java.util.logging）</td><td>JDK自带</td></tr><tr><td>log4j2</td><td>Apache收购log4j后全面重构，内部实现和log4j完全不同</td></tr><tr><td>logback★</td><td>优雅、强大</td></tr></tbody></table><p>注：标记★的技术是同一作者。</p><h6 id="2-4-2-logback配置文件"><a href="#2-4-2-logback配置文件" class="headerlink" title="2.4.2 logback配置文件"></a>2.4.2 logback配置文件</h6><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_010.png"></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;true&quot;&gt;    &lt;!-- 指定日志输出的位置 --&gt;    &lt;appender name=&quot;STDOUT&quot;        class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;encoder&gt;            &lt;!-- 日志输出的格式 --&gt;            &lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;            &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;        &lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;    &lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;    &lt;root level=&quot;DEBUG&quot;&gt;        &lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;    &lt;/root&gt;        &lt;!-- 根据特殊需求指定局部日志级别 --&gt;    &lt;logger name=&quot;com.atguigu.crowd.mapper&quot; level=&quot;DEBUG&quot;/&gt;    &lt;/configuration&gt;</code></pre><h6 id="2-4-3-junit测试"><a href="#2-4-3-junit测试" class="headerlink" title="2.4.3 junit测试"></a>2.4.3 junit测试</h6><p>正常按照二级缓存的方式测试即可。因为整合EHCache后，其实就是使用EHCache代替了Mybatis自带的二级缓存。 </p><h6 id="2-4-4-EHCache配置文件说明"><a href="#2-4-4-EHCache配置文件说明" class="headerlink" title="2.4.4 EHCache配置文件说明"></a>2.4.4 EHCache配置文件说明</h6><p>当借助CacheManager.add(“缓存名称”)创建Cache时，EhCache便会采用<defalutCache>指定的的管理策略。</defalutCache></p><p>defaultCache标签各属性说明：</p><table><thead><tr><th>属性名</th><th>是否必须</th><th>作用</th></tr></thead><tbody><tr><td>maxElementsInMemory</td><td>是</td><td>在内存中缓存的element的最大数目</td></tr><tr><td>maxElementsOnDisk</td><td>是</td><td>在磁盘上缓存的element的最大数目，若是0表示无穷大</td></tr><tr><td>eternal</td><td>是</td><td>设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断</td></tr><tr><td>overflowToDisk</td><td>是</td><td>设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上</td></tr><tr><td>timeToIdleSeconds</td><td>否</td><td>当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大</td></tr><tr><td>timeToLiveSeconds</td><td>否</td><td>缓存element的有效生命期，默认是0.,也就是element存活时间无穷大</td></tr><tr><td>diskSpoolBufferSizeMB</td><td>否</td><td>DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区</td></tr><tr><td>diskPersistent</td><td>否</td><td>在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。</td></tr><tr><td>diskExpiryThreadIntervalSeconds</td><td>否</td><td>磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作</td></tr><tr><td>memoryStoreEvictionPolicy</td><td>否</td><td>当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出）</td></tr></tbody></table><h3 id="第五节-缓存的原理"><a href="#第五节-缓存的原理" class="headerlink" title="第五节 缓存的原理"></a>第五节 缓存的原理</h3><h4 id="1-Cache接口"><a href="#1-Cache接口" class="headerlink" title="1. Cache接口"></a>1. Cache接口</h4><h5 id="1-1-Cache接口的重要地位"><a href="#1-1-Cache接口的重要地位" class="headerlink" title="1.1 Cache接口的重要地位"></a>1.1 Cache接口的重要地位</h5><p>org.apache.ibatis.cache.Cache接口：所有缓存都必须实现的顶级接口</p><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_011.png"></p><h5 id="1-2-Cache接口中的方法"><a href="#1-2-Cache接口中的方法" class="headerlink" title="1.2 Cache接口中的方法"></a>1.2 Cache接口中的方法</h5><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_012.png"></p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>putObject()</td><td>将对象存入缓存</td></tr><tr><td>getObject()</td><td>从缓存中取出对象</td></tr><tr><td>removeObject()</td><td>从缓存中删除对象</td></tr></tbody></table><h5 id="1-3-缓存的本质"><a href="#1-3-缓存的本质" class="headerlink" title="1.3 缓存的本质"></a>1.3 缓存的本质</h5><p>根据Cache接口中方法的声明我们能够看到，缓存的本质是一个<strong>Map</strong>。 </p><h4 id="2-PerpetualCache类"><a href="#2-PerpetualCache类" class="headerlink" title="2. PerpetualCache类"></a>2. PerpetualCache类</h4><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_013.png"></p><p>org.apache.ibatis.cache.impl.PerpetualCache是Mybatis的默认缓存，也是Cache接口的默认实现。Mybatis一级缓存和自带的二级缓存都是通过PerpetualCache来操作缓存数据的。但是这就奇怪了，同样是PerpetualCache这个类，怎么能区分出来两种不同级别的缓存呢？</p><p>其实很简单，调用者不同。</p><ul><li>一级缓存：由BaseExecutor调用PerpetualCache</li><li>二级缓存：由CachingExecutor调用PerpetualCache，而CachingExecutor可以看做是对BaseExecutor的装饰</li></ul><h4 id="3-一级缓存机制"><a href="#3-一级缓存机制" class="headerlink" title="3. 一级缓存机制"></a>3. 一级缓存机制</h4><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_014.png"></p><p> org.apache.ibatis.executor.BaseExecutor类中的关键方法： </p><h5 id="3-1-query-方法"><a href="#3-1-query-方法" class="headerlink" title="3.1 query()方法"></a>3.1 query()方法</h5><pre><code class="java">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());    if (closed) &#123;        throw new ExecutorException(&quot;Executor was closed.&quot;);    &#125;    if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) &#123;        clearLocalCache();    &#125;    List&lt;E&gt; list;    try &#123;        queryStack++;                // 尝试从本地缓存中获取数据        list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;                if (list != null) &#123;            handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);        &#125; else &#123;                        // 如果本地缓存中没有查询到数据，则查询数据库            list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);        &#125;    &#125; finally &#123;        queryStack--;    &#125;    if (queryStack == 0) &#123;        for (org.apache.ibatis.executor.BaseExecutor.DeferredLoad deferredLoad : deferredLoads) &#123;            deferredLoad.load();        &#125;        // issue #601        deferredLoads.clear();        if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;            // issue #482            clearLocalCache();        &#125;    &#125;    return list;&#125;</code></pre><h5 id="3-2-queryFromDatabase-方法"><a href="#3-2-queryFromDatabase-方法" class="headerlink" title="3.2 queryFromDatabase()方法"></a>3.2 queryFromDatabase()方法</h5><pre><code class="java">private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;    List&lt;E&gt; list;    localCache.putObject(key, EXECUTION_PLACEHOLDER);    try &#123;                // 从数据库中查询数据        list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);    &#125; finally &#123;        localCache.removeObject(key);    &#125;        // 将数据存入本地缓存    localCache.putObject(key, list);    if (ms.getStatementType() == StatementType.CALLABLE) &#123;        localOutputParameterCache.putObject(key, parameter);    &#125;    return list;&#125;</code></pre><h4 id="4-二级缓存机制"><a href="#4-二级缓存机制" class="headerlink" title="4. 二级缓存机制"></a>4. 二级缓存机制</h4><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_015.png"></p><p>下面我们来看看CachingExecutor类中的query()方法在不同情况下使用的具体缓存对象： </p><h5 id="4-1-未开启二级缓存"><a href="#4-1-未开启二级缓存" class="headerlink" title="4.1 未开启二级缓存"></a>4.1 未开启二级缓存</h5><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_016.png"></p><h5 id="4-1-使用Mybatis自带的二级缓存"><a href="#4-1-使用Mybatis自带的二级缓存" class="headerlink" title="4.1 使用Mybatis自带的二级缓存"></a>4.1 使用Mybatis自带的二级缓存</h5><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_017.png"></p><h5 id="4-1-使用EHCache"><a href="#4-1-使用EHCache" class="headerlink" title="4.1 使用EHCache"></a>4.1 使用EHCache</h5><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_018.png"></p><h2 id="第二章-逆向工程"><a href="#第二章-逆向工程" class="headerlink" title="第二章 逆向工程"></a>第二章 逆向工程</h2><h3 id="第一节-概念"><a href="#第一节-概念" class="headerlink" title="第一节 概念"></a>第一节 概念</h3><ul><li>正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的。</li><li>逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：<ul><li>Java实体类</li><li>Mapper接口</li><li>Mapper配置文件</li></ul></li></ul><h3 id="第二节-基本原理"><a href="#第二节-基本原理" class="headerlink" title="第二节 基本原理"></a>第二节 基本原理</h3><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_019.png"></p><h3 id="第三节-逆向工程的具体操作"><a href="#第三节-逆向工程的具体操作" class="headerlink" title="第三节 逆向工程的具体操作"></a>第三节 逆向工程的具体操作</h3><h4 id="1-配置POM"><a href="#1-配置POM" class="headerlink" title="1. 配置POM"></a>1. 配置POM</h4><pre><code class="xml">&lt;!-- 依赖MyBatis核心包 --&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.7&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--mysql驱动--&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.3&lt;/version&gt;        &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!--log4j--&gt;    &lt;dependency&gt;        &lt;groupId&gt;log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j&lt;/artifactId&gt;        &lt;version&gt;1.2.17&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--junit--&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!--lombok--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;version&gt;1.18.8&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- 控制Maven在构建过程中相关配置 --&gt;&lt;build&gt;    &lt;!-- 构建过程中用到的插件 --&gt;    &lt;plugins&gt;        &lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;1.3.0&lt;/version&gt;            &lt;!-- 插件的依赖 --&gt;            &lt;dependencies&gt;                &lt;!-- 逆向工程的核心依赖 --&gt;                &lt;dependency&gt;                    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                    &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;                    &lt;version&gt;1.3.2&lt;/version&gt;                &lt;/dependency&gt;                &lt;!-- 数据库连接池 --&gt;                &lt;dependency&gt;                    &lt;groupId&gt;com.mchange&lt;/groupId&gt;                    &lt;artifactId&gt;c3p0&lt;/artifactId&gt;                    &lt;version&gt;0.9.2&lt;/version&gt;                &lt;/dependency&gt;                &lt;!-- MySQL驱动 --&gt;                &lt;dependency&gt;                    &lt;groupId&gt;mysql&lt;/groupId&gt;                    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                    &lt;version&gt;5.1.8&lt;/version&gt;                &lt;/dependency&gt;            &lt;/dependencies&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><h4 id="2-MBG配置文件"><a href="#2-MBG配置文件" class="headerlink" title="2. MBG配置文件"></a>2. MBG配置文件</h4><p>文件名必须是:generatorConfig.xml</p><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_020.png"></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;!--            targetRuntime: 执行生成的逆向工程的版本                    MyBatis3Simple: 生成基本的CRUD（清新简洁版）                    MyBatis3: 生成带条件的CRUD（奢华尊享版）     --&gt;    &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;!-- 数据库的连接信息 --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;                        userId=&quot;root&quot;                        password=&quot;123456&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!--            javaBean的生成策略            targetPackage 表示生成的JavaBean存放到哪个包中            targetProject 表示生成的JavaBean存放到哪个主目录中        --&gt;        &lt;javaModelGenerator targetPackage=&quot;com.atguigu.pojo&quot; targetProject=&quot;.\src\main\java&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;!--            SQL映射文件的生成策略         --&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.atguigu.mapper&quot;  targetProject=&quot;.\src\main\resources&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- Mapper接口的生成策略 --&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.atguigu.mapper&quot;  targetProject=&quot;.\src\main\java&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 逆向分析的表 --&gt;        &lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;        &lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;        &lt;table tableName=&quot;t_emp&quot; domainObjectName=&quot;Employee&quot;/&gt;        &lt;table tableName=&quot;t_customer&quot; domainObjectName=&quot;Customer&quot;/&gt;        &lt;table tableName=&quot;t_order&quot; domainObjectName=&quot;Order&quot;/&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><h4 id="3-执行MBG插件的generate目标"><a href="#3-执行MBG插件的generate目标" class="headerlink" title="3. 执行MBG插件的generate目标"></a>3. 执行MBG插件的generate目标</h4><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_021.png"></p><h4 id="4-效果"><a href="#4-效果" class="headerlink" title="4. 效果"></a>4. 效果</h4><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_022.png"></p><h4 id="5-测试代码"><a href="#5-测试代码" class="headerlink" title="5. 测试代码"></a>5. 测试代码</h4><pre><code class="java">package com.atguigu;import com.atguigu.mapper.EmployeeMapper;import com.atguigu.pojo.Employee;import com.atguigu.pojo.EmployeeExample;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;/** * 包名:com.atguigu * * @author Leevi * 日期2021-08-28  14:06 */public class TestMybatis &#123;    private SqlSession sqlSession;    private EmployeeMapper employeeMapper;    private InputStream is;    @Before    public void init() throws IOException &#123;        //目标:创建出EmployeeManager接口的代理对象        //1. 加载核心配置文件，转成字节输入流        is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);        //2. 创建SqlSessionFactoryBuilder对象        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();        //3. 构建出SqlSessionFactory        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);        //4. 使用SqlSessionFactory对象创建出sqlSession对象        sqlSession = sqlSessionFactory.openSession();        //5. 使用sqlSession对象创建UserMapper接口的代理对象        employeeMapper = sqlSession.getMapper(EmployeeMapper.class);    &#125;    @After    public void destroy() throws IOException &#123;        //提交事务        sqlSession.commit();        //关闭资源        is.close();        sqlSession.close();    &#125;    @Test    public void testInsertEmployee()&#123;        employeeMapper.insert(new Employee(null,&quot;王五&quot;,3000d));    &#125;    @Test    public void testDeleteEmployeeByPrimaryKey()&#123;        employeeMapper.deleteByPrimaryKey(15014);    &#125;    @Test    public void testDeleteByExample()&#123;        //根据较为复杂的条件进行删除，比如要删除empId在2000到8000之间的所有员工        //1. 创建一个EmployeeExample对象        EmployeeExample employeeExample = new EmployeeExample();        //2. 使用EmployeeExample对象获取criteria对象        EmployeeExample.Criteria criteria = employeeExample.createCriteria();        //3. 通过criteria来拼接条件        criteria.andEmpIdBetween(3000,8000);        employeeMapper.deleteByExample(employeeExample);    &#125;    @Test    public void testUpdateEmployee()&#123;        employeeMapper.updateByPrimaryKeySelective(new Employee(4,null,2000d));    &#125;    @Test    public void testQueryByPrimaryKey()&#123;        //根据主键查询        Employee employee = employeeMapper.selectByPrimaryKey(4);        System.out.println(employee);    &#125;    @Test    public void testQueryAll()&#123;        EmployeeExample employeeExample = new EmployeeExample();        //查询所有数据        List&lt;Employee&gt; employeeList = employeeMapper.selectByExample(employeeExample);    &#125;    @Test    public void testQueryByExample()&#123;        //复杂条件:查询(名字中包含s，并且大于3000)  或者 (emp_id在8001-8234之间,并且名字中包含3）的所有元素        EmployeeExample employeeExample = new EmployeeExample();        EmployeeExample.Criteria criteria1 = employeeExample.createCriteria();        criteria1.andEmpNameLike(&quot;%s%&quot;)                 .andEmpSalaryGreaterThan(3000d);        EmployeeExample.Criteria criteria2 = employeeExample.or();        criteria2.andEmpIdBetween(8001,8234)                 .andEmpNameLike(&quot;%3%&quot;);        employeeMapper.selectByExample(employeeExample);    &#125;&#125;</code></pre><h3 id="第四节-QBC查询"><a href="#第四节-QBC查询" class="headerlink" title="第四节  QBC查询"></a>第四节  QBC查询</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p>QBC：Query By Criteria ， 最大的特点就是将SQL语句中的WHERE子句进行了组件化的封装，让我们可以通过调用Criteria对象的方法自由的拼装查询条件。 </p><h4 id="2-例子"><a href="#2-例子" class="headerlink" title="2. 例子"></a>2. 例子</h4><pre><code class="java">@Testpublic void testQueryByExample()&#123;    //复杂条件:查询(名字中包含s，并且大于3000)  或者 (emp_id在8001-8234之间,并且名字中包含3）的所有元素    EmployeeExample employeeExample = new EmployeeExample();    EmployeeExample.Criteria criteria1 = employeeExample.createCriteria();    criteria1.andEmpNameLike(&quot;%s%&quot;)        .andEmpSalaryGreaterThan(3000d);    EmployeeExample.Criteria criteria2 = employeeExample.or();    criteria2.andEmpIdBetween(8001,8234)        .andEmpNameLike(&quot;%3%&quot;);    employeeMapper.selectByExample(employeeExample);&#125;//实际执行的SQL语句:select emp_id, emp_name, emp_salary from t_emp WHERE ( emp_name like ? and emp_salary &gt; ? ) or( emp_id between ? and ? and emp_name like ? )</code></pre><h2 id="第三章-Mybatis的其它补充内容-了解"><a href="#第三章-Mybatis的其它补充内容-了解" class="headerlink" title="第三章 Mybatis的其它补充内容(了解)"></a>第三章 Mybatis的其它补充内容(了解)</h2><h3 id="第一节-插件机制"><a href="#第一节-插件机制" class="headerlink" title="第一节 插件机制"></a>第一节 插件机制</h3><h4 id="1-Mybatis四大对象"><a href="#1-Mybatis四大对象" class="headerlink" title="1. Mybatis四大对象"></a>1. Mybatis四大对象</h4><h5 id="1-1-Executor"><a href="#1-1-Executor" class="headerlink" title="1.1 Executor"></a>1.1 Executor</h5><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_023.png"></p><h5 id="1-2-ParameterHandler"><a href="#1-2-ParameterHandler" class="headerlink" title="1.2 ParameterHandler"></a>1.2 ParameterHandler</h5><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_024.png"></p><h5 id="2-3-ResultSetHandler"><a href="#2-3-ResultSetHandler" class="headerlink" title="2.3 ResultSetHandler"></a>2.3 ResultSetHandler</h5><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_025.png"></p><h5 id="2-4-StatementHandler"><a href="#2-4-StatementHandler" class="headerlink" title="2.4 StatementHandler"></a>2.4 StatementHandler</h5><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_026.png"></p><h4 id="2-Mybatis插件机制的作用"><a href="#2-Mybatis插件机制的作用" class="headerlink" title="2. Mybatis插件机制的作用"></a>2. Mybatis插件机制的作用</h4><p>插件是MyBatis提供的一个非常强大的机制，我们可以通过插件来修改MyBatis的一些核心行为。插件通过<strong>动态代理</strong>机制，可以介入四大对象的任何一个方法的执行。著名的Mybatis插件包括 PageHelper（分页插件）、通用 Mapper（SQL生成插件）等。</p><p>如果想编写自己的Mybatis插件可以通过实现org.apache.ibatis.plugin.Interceptor接口来完成，表示对Mybatis常规操作进行拦截，加入自定义逻辑。</p><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_027.png"></p><p> 但是由于插件涉及到Mybatis底层工作机制，在没有足够把握时不要轻易尝试。 </p><h3 id="第二节-Mybatis底层的JDBC封装"><a href="#第二节-Mybatis底层的JDBC封装" class="headerlink" title="第二节 Mybatis底层的JDBC封装"></a>第二节 Mybatis底层的JDBC封装</h3><p> org.apache.ibatis.executor.statement.PreparedStatementHandler类： </p><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_028.png"></p><p>查找上面目标时，Debug查看源码的切入点是：</p><p>org.apache.ibatis.session.defaults.DefaultSqlSession类的update()方法</p><p><img src="http://www.slx.blue/2021/12/03/mybatis04/tu_029.png"></p><p>然后在分析<code>this.executor.update()方法</code></p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java设计模式</title>
      <link href="/2021/12/03/javaDesignMode/"/>
      <url>/2021/12/03/javaDesignMode/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h1><p>设计原则核心思想:</p><ol><li><p>找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码放在一起。</p></li><li><p> 针对接口编程，而不是针对实现编程。</p></li><li><p>为了交互对象之间的松耦合设计努力  </p></li></ol><pre><code>设计模式常见的七大原则：1)单一职责原则2)接口隔离原则3)依赖倒置原则4)里式替换原则5)开闭原则6)迪米特原则7)合成复用原则</code></pre><ol><li><p>代码重用性</p></li><li><p>可读性</p></li><li><p>可扩展性</p></li><li><p>可靠性</p></li><li><p>高内聚低耦合</p></li></ol><h2 id="单一隔离"><a href="#单一隔离" class="headerlink" title="单一隔离"></a>单一隔离</h2><pre><code>原则上 一个类应该尽量做一件事 一个类继承一个接口 如果实现类两个职责 当职责一进行修改的时候 很可能回对职责二造成影响但是一个类继承一个接口会导致开销过大在接口方法比较少的情况下可以 通过向下兼容 实现方法的单一职责</code></pre><h2 id="接口隔离"><a href="#接口隔离" class="headerlink" title="接口隔离"></a>接口隔离</h2><pre><code>如果一个接口方法过多，实现该接口就会需要去实现很多不需要实现的方法。这个时候我们就应该把接口进行拆分，去实现需要实现的接口即可。</code></pre><h2 id="依赖倒转-倒置"><a href="#依赖倒转-倒置" class="headerlink" title="依赖倒转(倒置)"></a>依赖倒转(倒置)</h2><pre><code>接口和抽象类的价值在于 设计高层模块不应该依赖于底层模块抽象不应该依赖细节，细节应该依赖抽象面向接口编程传递的三种方式1.构造器传递2.set接口传递3.接口传递使用接口或者抽象类的目的是制定好规范。而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成多了一个缓冲利于程序的扩展和优化</code></pre><h2 id="里式替换原则"><a href="#里式替换原则" class="headerlink" title="里式替换原则"></a>里式替换原则</h2><pre><code>问题：在编程中如何正确的实现继承   尽量满足里式替换原则 子类尽量不要重写父类的方法做到透明使用 如果子类想使用父类的方法 ，但是有可能会不小心重写了父类的方法 倒是一系列应用 带来了程序的入侵性所以可以 子类和父类都继承一个新的base类，base类实现了更为基础的代码和方法这样子类可以放心的重写方法达到的效果是 所有应用基类的类应该尽量做到透明使用</code></pre><p>​    </p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><pre><code>开闭原则是编程中 最基础最重要的原则一个软件实体类 模块和函数应该对外扩展开放(对提供方) 对修改关闭(对使用方)  用抽象构建，用实现扩展细节当我们增加一个功能时候 应该增加代码而不是修改代码 尽量不去修改原有的代码 当软件需要变化时 尽量通过扩展软件实体的行为来实现变化 而不是通过修改已有的代码来实现变化编程中遵循其他原则以及使用设计模式的目的就是遵循开闭原则改进思路分析 把创建的Shape类做成抽象类或者接口，并提供一个抽象的draw方法或者接口，让子类去实现即可。这样有新的图形种类时候 只需要让新的图形去继承Shape 并且实现draw方法即可，这样使用方的代码就不需要修改满足了开闭原则</code></pre><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><pre><code>一个对象应该对其他的对象保持最少的了解类与类之间的关系越密切，耦合度越大一个类里面 除了传递参数依赖类 应该尽量避免出现其他的陌生类，降低耦合度 这样代码修改起来容易</code></pre><h2 id="合成服用原则"><a href="#合成服用原则" class="headerlink" title="合成服用原则"></a>合成服用原则</h2><pre><code>原则是尽量使用合成/聚合 而不是使用继承B要想使用A的方法，可以继承于A 但是这样会导致关系太强 耦合度太高组合： 让B 里面注入一个A 聚合:  让B里面 set 一个A 或者构造器依赖： 在B里面把A传进来 称之为B依赖A 方法</code></pre><h1 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h1><pre><code>设计模式分为三种类型，共23种1、创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式2、适配器模式：桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式3、行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式</code></pre><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="饿汉式-静态常量"><a href="#饿汉式-静态常量" class="headerlink" title="饿汉式(静态常量)"></a>饿汉式(静态常量)</h4><pre><code class="java">class Singleton&#123;    //构造器私有化 外部能new    private Singleton()&#123;          &#125;    //本类内部创建对象实例    private final static Singleton instance = new Singleton();    //提供一个共有的静态方法 返回实例对象    public static Singleton getInstance()&#123;        return instance;    &#125;&#125;/*写法较为简单，在类转载的时候就完成了实例化，避免了线程同步的问题。缺点是在类装载的时候就完成实例化，没有达到懒加载的效果(Lazy Loading)。如果从始至终从未使用过这个实例，则会造成内存浪费，这种基于类加载机制避免了多线程同步的问题，不过instance在类装载的时候就完成实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式导致类装载，这个时候初始化instance就没有达到懒加载的效果这种单例模式可以用，有可能造成内存浪费*/</code></pre><h4 id="饿汉式-静态代码块"><a href="#饿汉式-静态代码块" class="headerlink" title="饿汉式(静态代码块)"></a>饿汉式(静态代码块)</h4><pre><code class="java">class Singleton&#123;    //构造器私有化 外部能new    private Singleton()&#123;&#125;    //本类内部创建对象实例    private  static Singleton instance ;    static&#123;        instance = new Singleton();    &#125;    //提供一个共有的静态方法 返回实例对象    public static Singleton getInstance()&#123;        return instance;    &#125;&#125;//和静态常量类似，在静态代码块完成实例化。 优缺点也和饿汉式静态常量一样</code></pre><h4 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式(线程不安全)"></a>懒汉式(线程不安全)</h4><pre><code class="java">class Singleton&#123;    private static Singleton instance;    private Singleton()&#123;&#125;    //提供一个静态方法，当使用这个方法的时候才实例化    //懒汉式(线程不安全)    public static Singleton getInstance()&#123;        if (instance == null)&#123;            instance = new Singleton();        &#125;        return instance;    &#125;&#125;/*小结：1.起到了懒加载的效果，但是只能在多线程下才能使用2.如果在多线程下 会导致线程不安全 一个线程进入if语句还没执行完 另一个线程也进来了 就会产生多个实例3.在实际开发中 不要使用这种方式*/</code></pre><h4 id="懒汉式-线程安全"><a href="#懒汉式-线程安全" class="headerlink" title="懒汉式(线程安全)"></a>懒汉式(线程安全)</h4><pre><code class="java">class Singleton&#123;    private static Singleton instance;    private Singleton()&#123;&#125;    //提供一个静态方法，加入同步处理的代码，解决了线程安全问题    //懒汉式(线程安全)    public static synchronized Singleton getInstance()&#123;        if (instance == null)&#123;            //synchronized(Singleton.class)&#123;             //锁放在这里 并不能实现线程安全 因为线程进了if语句 迟早会执行                    instance = new Singleton();            //&#125;            &#125;        return instance;    &#125;&#125;/*小结：1.解决了线程不安全问题2.效率太低了，每个线程想获得类的实例的时候 执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化就够了，后面想要获得该实例应该是直接return，方法进行同步效率太低3.在实际开发中 不要使用这种方式*/</code></pre><h4 id="双重检查-推荐"><a href="#双重检查-推荐" class="headerlink" title="双重检查(推荐)"></a>双重检查(推荐)</h4><pre><code class="java">class Singleton&#123;    private static volatile Singleton singleton;    private Singleton()&#123;&#125;    public static Singleton getInstance()&#123;        //双重检查        //提供一个静态的共有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题        if (singleton == null)&#123;            synchronized (Singleton.class)&#123;                if (singleton == null)&#123;                    singleton = new Singleton();                &#125;            &#125;        &#125;        return singleton;    &#125;&#125;/*小结：1.双重检查 判断了两次singleton == null 就可以保证线程安全2.实例化代码只用执行一次 后面再次访问 的时候 如果不为空 就可以直接返回实例化对象 避免了方法反复同步3.线程安全：实现了懒加载，效率较高在实际开发中 推荐使用这种单例设计模式*/</code></pre><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><pre><code class="java">class Singleton&#123;    private static volatile Singleton instance;    //　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，    //当有其他线程需要读取时，它会去内存中读取新值。 保证了 可见性。    // 满足并发编程安全的三大特性 原子性 可见性 有序性    //构造器私有化    private Singleton()&#123;&#125;    //写一个静态内部类，该类中有一个静态属性Singleton    private static class SingletonInstance&#123;        private static final Singleton INSTANCE = new Singleton();    &#125;            //提供一个静态方法，直接返回SingletonInstance.INSTANCE    public static synchronized Singleton getInstance()&#123;        return SingletonInstance.INSTANCE;    &#125;&#125;/*小结:1.这种方式采用的类装载机制来保证初始化实例只有一个线程2.静态内部类方式在Singleton类被加载的时候并不会立即实例化，而是在需要实例化的时候，调用getInstacne方法，才会装在SingleInstance类，从而完成Singeleton的实例化3.类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化的时候，别的线程是无法进入的。4.避免了线程不安全，利用静态内部类特点实现了延迟加载，效率高。在工作中推荐使用*/</code></pre><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><pre><code class="java">enum  Singleton&#123;   INSTANCE;   public void sayOK()&#123;       System.out.println(&quot;ok~~~&quot;);   &#125;&#125;/*小结1.这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。2.这种方式是Effective Jaca坐着Josh Bloch提倡的方式推荐使用*/</code></pre><p>单例模式有八种方式：</p><pre><code>饿汉式(静态常量实例化)饿汉式(静态代码块实例化)懒汉式(线程不安全)懒汉式(线程安全同步方法)懒汉式(同步代码块 ，写法错误) 并不能实现线程安全双重检查静态内部类枚举</code></pre><p>单例模式注意事项和细节说明：</p><p>1)单例模式保证了系统内存中 该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可提高系统的性能<br>2）当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是直接使用new<br>3）单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或者耗费资源过多（即重量级对象），但又经常用到的对象，工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等）</p><pre><code class="java">如果确定实例一定会使用 饿汉式是可以使用的 只是有可能会造成内存浪费 比如java的Runtime中就用了饿汉式 推荐使用： 双重检查、静态内部类、枚举</code></pre><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>需求：一个披萨项目，要便于披萨种类的扩展，要便于维护</p><ol><li>披萨的种类有很多(比如<code>GreekPizz</code>、<code>Chjeesepizz</code>等)</li><li>披萨的制作有prepare，bake，cut，box</li><li>完成披萨店订购功能。</li></ol><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><ol><li>抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象 cu答族，而无需指明具体的类</li><li>抽象工厂模式可以将简单工厂模式和工厂方法进行整合</li><li>从设计层面看，抽象工厂模式就是对简单工厂模式的改进或者说进一步的抽象</li><li>将工厂抽象成两橙，<code>AbsFactory</code>(抽象工厂)和具体实现的工厂子类，程序员可以根据创建对象类型使用对应的工厂子类。这样将单个简单地工厂变成了工厂cu答族，更利于代码的维护</li></ol><pre><code class="java">定义一个抽象的工厂，然后定义实体工厂实现工厂方法。</code></pre><blockquote><p>Calendar中使用了工厂模式</p></blockquote><p>工厂模式小结</p><ol><li>工厂模式的意义：将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。</li><li>三种工厂模式（简单工厂模式，工厂方法模式，抽象工厂模式）</li><li>设计模式的依赖抽象原则<ul><li>创建对象实例中，不要直接new类，而是把这个new类的动作放在一个工厂的方法中，并返回。有的书上说不要直接持有具体类的应用。</li><li>不要让类继承具体类，而是继承抽象类或者是实现interface（接口）</li><li>不要覆盖基类中已经实现的方法</li></ul></li></ol><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ul><li>现有一只羊，姓名为tom，年龄为1：颜色为白色，请编写程序创建和tom羊属性完全相同的10只羊</li></ul><pre><code class="java">//传统方式public class Sheep &#123;    private String name;    private int age;    private String color;    //生成构造和getset方法以及toString等等...&#125; public static void main(String[] args) &#123;     Sheep sheep = new Sheep(&quot;tom&quot;,1,&quot;白色&quot;);     //克隆十次...     new Sheep(sheep.getName(),sheep.getAge(),sheep.getColor()); &#125;</code></pre><p>传统方式的优缺点</p><ol><li>有点是比较好理解，简单易操作</li><li>在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂，效率较低</li><li>总是需要重新初始化对象，而不是动态的获得对象运行时的状态，不够灵活</li></ol><p>思路：<code>java</code>中Object类是所有类的父类，Object提供了一个clone方法，可以将一个<code>java</code>对象复制一份，但是需要实现clone的<code>java</code>类需要实现一个接口<code>Clonealbe</code>，该接口表示该类能够复制且具有复制的能力=&gt;原型模式</p><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象</li><li>原型模式是一种创建型设计模式，允许一个对象在创建另外一个可定制的对象，无需知道如何创建的细节</li><li>工作的原理：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝他们来实施创建，即对象.clone() </li><li>形象理解：猴子拔出猴毛变成其他猴子</li></ol><p>改进：</p><pre><code class="java">public class Sheep implements Cloneable&#123;    private String name;    private int age;    private String color;     //生成构造和getset方法以及toString等等...    //克隆该实例 使用默认的clone方法来完成    @Override    protected Object clone() throws CloneNotSupportedException &#123;        Sheep sheep = null;        Sheep clone = (Sheep) super.clone();        return clone;    &#125;&#125;public class Client &#123;    public static void main(String[] args)  &#123;        Sheep sheep = new Sheep(&quot;tom&quot;,1,&quot;包塞&quot;);        try &#123;            //克隆十次            Sheep clone1 = (Sheep) sheep.clone();            Sheep clone2 = (Sheep) sheep.clone();            //....        &#125; catch (CloneNotSupportedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><blockquote><p>原型模式在Spring框架中源码分析</p></blockquote><pre><code class="java"> public void testImport()&#123;     Object bean1 = applicationContext.getBean(xxx);          Object bean2 = applicationContext.getBean(xxx);       //如果是scope = prototype 多例 就用到了原型模式     //getbean每次都是通过clone生成的对象  &#125;</code></pre><p>原型模式完成对象的创建，如果被克隆的对象中有对象属性，那么克隆的时候并不会被克隆</p><h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p>浅拷贝：</p><ol><li>对于数据类型是基本类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性复制一份给新的对象</li><li>对于数据类型是应用数据类型的成员变量，比如成员变量是某个数组，某个类的对象等，那么浅拷贝会进行引用传递，也就是只将该成员变量的引用值(内存地址)复制一份给新的对象。实际上两个对象都指向同一个实例，所以这种情况下 一个对象中修改该成员变量会影响到另一个对象的该成员变量值</li><li>比如默认开启的对象克隆就是浅拷贝</li><li><code> Sheep clone2 = (Sheep) sheep.clone();</code></li></ol><p>深拷贝：</p><ol><li>复制对象的<strong>所有</strong>基本数据类型的成员变量值 </li><li>为所有应用数据类型的成员变量<strong>申请存储空间</strong>，并复制每个应用数据类型成员变量所引用的对象，直到该对象可达的所有对象，<strong>也就是说，对象进行深拷贝要对整个对象(包括引用对象)进行拷贝</strong></li><li>深拷贝实现方式1：<strong>重写clone</strong>方法来实现深拷贝</li><li>深拷贝实现方式2：通过<strong>序列化</strong>实现深拷贝  </li></ol><h4 id="小案例"><a href="#小案例" class="headerlink" title="小案例"></a>小案例</h4><pre><code class="java">//克隆引用对象public class DeepCloneTarget implements Serializable,Cloneable &#123;    private static final long serialVersionUID = 1L;    private String cloneName;    private String cloneClass;    public DeepCloneTarget(String cloneName, String cloneClass) &#123;        this.cloneName = cloneName;        this.cloneClass = cloneClass;    &#125;    //因为该类的属性都是string 所以直接用默认clone方式即可    @Override    protected Object clone() throws CloneNotSupportedException &#123;        return super.clone();    &#125;&#125;</code></pre><pre><code class="java">//要克隆的对象 实现了两种克隆方式public class DeepProtoType implements Serializable,Cloneable &#123;    public String name;//String 属性    public DeepCloneTarget deepCloneTarget;//引用类型 //属性是对象 默认克隆会浅拷贝    //深拷贝-1 使用重写clone方法    @Override    protected Object clone() throws CloneNotSupportedException &#123;        Object deep = null;        //这里完成对基本数据类型(属性)和字符串的clone        deep = super.clone();        //对引用类型的属性进行单独处理        DeepProtoType deepProtoType = (DeepProtoType) deep;        deepProtoType.deepCloneTarget = (DeepCloneTarget) deepCloneTarget.clone();        return deepProtoType;    &#125;    //深拷贝2 使用对象的序列化实现(推荐)    public Object deepClone()&#123;        //创建流对象        ByteArrayOutputStream bos = null;        ObjectOutputStream oos = null;        ByteArrayInputStream bis = null;        ObjectInputStream ois = null;        try &#123;            bos = new ByteArrayOutputStream();            oos = new ObjectOutputStream(bos);            oos.writeObject(this); //当前这个对象以对象流的方式输出 序列化            //再反序列化 读出来 相当于存了值 成功克隆了一个新的对象            bis = new ByteArrayInputStream(bos.toByteArray());            ois = new ObjectInputStream(bis);            DeepProtoType copy = (DeepProtoType) ois.readObject();            return copy;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return null;        &#125;finally &#123;            try &#123;                bos.close();                oos.close();                bis.close();                ois.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><pre><code class="java">//测试public class Client &#123;    public static void main(String[] args) throws CloneNotSupportedException &#123;        DeepProtoType dp = new DeepProtoType();        dp.name = &quot;小水牛&quot;;        dp.deepCloneTarget = new DeepCloneTarget(&quot;大水牛&quot;, &quot;敲能喝&quot;);        //方式一 完成深拷贝       /*        DeepProtoType clone = (DeepProtoType) dp.clone();        System.out.println(dp.hashCode());//460141958        System.out.println(clone.hashCode());//1163157884       */       //方式二 完成深拷贝        DeepProtoType p = (DeepProtoType) dp.deepClone();        System.out.println(&quot;克隆原型：&quot;+dp.name + &quot;--&quot; + dp.deepCloneTarget.hashCode());        //克隆原型：小水牛--325040804        System.out.println(&quot;克隆的对象&quot;+p.name + &quot;--&quot; + p.deepCloneTarget.hashCode());        //克隆的对象小水牛--2065951873    &#125;&#125;//推荐使用的是通过序列化实现深拷贝，这样无论原型如何修改都不会影响克隆 因为直接通过流来反序列化创建</code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率</li><li>不用重新初始化对象，而是动态的获得对象运行时的状态</li><li>如果原型对象发生变化（增加或减少属性），其他克隆对象也会发生相应的变化，无需修改代码</li><li>在实现深克隆的时候 可能需要比较复杂的代码</li><li>缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但是对已有的类来说进行改造的时候 需要修改它的源代码，违背了<code>OCP</code>（开闭原则）。</li></ol><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><ol><li>需求：需要建房子 这一过程为打桩 砌墙 封顶</li><li>房子有各种各种的 比如普通房 高楼 别墅 各种房子的过程虽然一样 但是要求不要相同</li><li>编写程序完成需求</li></ol><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><pre><code class="java">public abstract class AbstractHouse &#123;  //抽象房子类    public abstract void buildBasic();// 打地基    public abstract void buildWalls(); //砌墙    public abstract void roofed();//封顶    public void build()&#123; //造房子        buildBasic();        buildWalls();        roofed();    &#125;&#125;//普通房子类public class CommonHouse extends AbstractHouse &#123;    @Override    public void buildBasic() &#123;        System.out.println(&quot;给普通房子打地基&quot;);    &#125;    @Override    public void buildWalls() &#123;        System.out.println(&quot;给普通房子砌墙&quot;);    &#125;    @Override    public void roofed() &#123;        System.out.println(&quot;给普通房子封顶&quot;);    &#125;&#125;public class Client &#123;    public static void main(String[] args) &#123;        CommonHouse commonHouse = new CommonHouse();        commonHouse.build();    &#125;&#125;</code></pre><p><img src="http://www.slx.blue/2021/12/03/javaDesignMode/TraditionalBuilder.jpg" alt="java"></p><ol><li><p>有点是比较好理解，简单易操作</p></li><li><p>设计的程序结构过于简单，没有设计缓存层对象，程序的扩展和维护不好,也就是说 这种设计方案把产品（房子）和创建产品的过程（建房子build方法）封装在一起 ，耦合性增强了</p></li><li><p>解决方案：将<strong>产品</strong>和<strong>产品建造过程</strong>解耦 =&gt; 建造者模式</p></li></ol><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>建造者模式(Builder Pattern)又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别） 使这个抽象过程的不同方法可以构造出不同表现(属性)的对象。</li><li>建造者模式是一步一步创建一个复杂的对象 ，他允许用户指定复杂的类型就可以构建他们，用户不需要知道具体构建细节。</li></ol><h4 id="建造者模式的四个角色"><a href="#建造者模式的四个角色" class="headerlink" title="建造者模式的四个角色"></a>建造者模式的四个角色</h4><ol><li>Product(产品角色) ：一个具体的产品对象</li><li>Builder(抽象建造者)：创建一个Product对象的各个部件的接口/抽象类</li><li><code>ConcreteBuilder</code>(具体建造者)实现接口，构建和装配各个部件</li><li>Director(指挥者)：构建一个Builder接口的对象，它主要是用于创建一个复杂的对象。主要有两个作用，一是：隔离客户与对象产生的过程，二是：复杂控制产品对象的生产过程</li></ol><p>产品：</p><pre><code class="java">//产品public class House &#123;//对应产品    private String base;    private String wall;    private String roofed;//对应getset方法&#125;</code></pre><p>抽象的建造者Builder:</p><pre><code class="java">public abstract class HouseBuilder &#123;    protected House house = new House(); //组合一个产品    //将建造的流程写好,抽象方法    public abstract void buildBasic();    public abstract void buildWalls();    public abstract void roofed();    //建造房子 建好后将房子返回    public House BuildHouse()&#123;        return house;    &#125;&#125;</code></pre><p>指挥者Director</p><pre><code class="java">//指挥者 这里去指定制作流程 返回房子public class HouseDirector &#123;    HouseBuilder houseBuilder = null;    //1.构造器传入  依赖    public HouseDirector(HouseBuilder houseBuilder) &#123;        this.houseBuilder = houseBuilder;    &#125;    //2.通过set方法传入 聚合    public void setHouseBuilder(HouseBuilder houseBuilder) &#123;        this.houseBuilder = houseBuilder;    &#125;    //如何处理建房流程，交给指挥者    public House constructorHouse()&#123;        houseBuilder.buildBasic();        houseBuilder.buildWalls();        houseBuilder.roofed();        return houseBuilder.BuildHouse();    &#125;&#125;</code></pre><p>两个产品类：</p><pre><code class="java">//普通房子public class CommonHouse extends HouseBuilder&#123;    @Override    public void buildBasic() &#123;        System.out.println(&quot;普通房子打地基五米&quot;);    &#125;    @Override    public void buildWalls() &#123;        System.out.println(&quot;普通房子砌墙10cm&quot;);    &#125;    @Override    public void roofed() &#123;        System.out.println(&quot;普通房子封顶&quot;);    &#125;&#125;//高楼public class HighBuilding extends HouseBuilder&#123;    @Override    public void buildBasic() &#123;        System.out.println(&quot;高楼打地基50&quot;);    &#125;    @Override    public void buildWalls() &#123;        System.out.println(&quot;高楼砌墙20cm&quot;);    &#125;    @Override    public void roofed() &#123;        System.out.println(&quot;高楼透明屋顶&quot;);    &#125;&#125;</code></pre><p>实现：</p><pre><code class="java">public class Client &#123;    public static void main(String[] args) &#123;        //盖普通房子        CommonHouse commonHouse = new CommonHouse();        //准备创建房子的指挥者        HouseDirector houseDirector = new HouseDirector(commonHouse);        //完成盖房子，返回产品（房子）        House house = houseDirector.constructorHouse();        //盖高楼        HighBuilding highBuilding = new HighBuilding();        houseDirector.setHouseBuilder(highBuilding);        House house1 = houseDirector.constructorHouse();    &#125;&#125;</code></pre><p><img src="http://www.slx.blue/2021/12/03/javaDesignMode/improveBuilder-1637309987736.jpg" alt="java"></p><p><code>JDK</code>中用到的建造者模式 <code>java.lang.StringBuilder</code></p><ul><li><code>Appendable</code>接口定义了多个append方法（抽象方法） ， 即<code>Appendable</code>为建造者，定义了抽象方法</li><li><code>AbstractStringBuilder</code>已经是建造者，只是不能实例化</li><li><code>StringBuilder</code>即充当了指挥者角色，同时同时充当了具体的建造者。建造方法的实现是由<code>AbstractStringBuilder</code>完成，而<code>StringBuilder</code>继承了<code>AbstractStringBuilder</code></li></ul><p><strong>建造者模式的注意事项和细节</strong></p><ol><li><p>客户端（使用程序）不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p></li><li><p>建造者模式所创建的产品一般具有较多相同的共同点，其组成部分相似，如果产品之间的差异性很大，则不是和使用建造者模式，因此其使用范围收到一定的限制。</p></li><li><p>如果产品内部变化复杂，可能会导致需要定义很多具体建造者来实现这种变化，导致系统变得庞大，因此要考虑是否适合选择建造者模式。</p></li><li><p>每一个具体的建造者都相对独立，而与其他的具体建造者无关，因此可以很方便的替换具体建造者或者增加新的具体建造者，用户使用不同的建造者即可得到不同的产品对象。</p></li><li><p>可以更加精细的控制产品的建造过程，将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建流程。</p></li><li><p>增加新的具体创建者无需修改原油类库的代码，指挥者针对抽象建造者类变成，系统扩展方便，符合开闭原则。</p><blockquote><p><strong>抽象工厂模式和建造者模式</strong></p></blockquote><p>抽象工厂模式实现对产品家族的创建，一个产品家族是一系列产品，具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产。而建造者模式则是按照指定的蓝图构建产品，它的主要目的是通过组装零配件而生产一个新的产品。</p></li></ol><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>基本介绍</p><ol><li>适配器模式(<code>Adapter Pattern</code>)将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)</li><li>适配器模式属于结构型模式</li><li>主要分为三类:类适配器模式，对象适配器模式  ，接口适配器模式   </li></ol><p>工作原理</p><ul><li>适配器模式：将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容</li><li>从用户的角度看不到适配者，是解耦的。</li><li>用户调用适配器转换出来的目标接口方法，适配器再调用被适配者的相关接口方法</li><li>用户收到反馈结果，只感觉是和目标接口交互</li></ul><h4 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h4><pre><code class="java">/** * @description:被适配的类 src 提供方、 **/public class Voltage220V &#123;    public int output220V()&#123;        int src = 220;        System.out.println(&quot;电压=&quot; + src + &quot;V&quot;);        return src;    &#125;&#125;</code></pre><pre><code class="java">//充电接口public interface Voltage5V &#123;    public int output5V();&#125;</code></pre><pre><code class="java">/** * @description:适配器类 * 继承被适配的类 实现适配器类的接口 **/public class VoltageAdapter extends Voltage220V implements Voltage5V&#123;    @Override    public int output5V() &#123;        int srcV  = output220V();        int destV = srcV/44;        return destV;    &#125;&#125;</code></pre><pre><code class="java">/** * @description：手机 有充电方法 依赖了一个接口 **/public class Phone &#123;    //充电方法    public void charging (Voltage5V iVoltage)&#123;        if (iVoltage.output5V() == 5)&#123;            System.out.println(&quot;电压为5V，可冲&quot;);        &#125;else if (iVoltage.output5V() &gt; 5)&#123;            System.out.println(&quot;电压大于5V 无法充电&quot;);        &#125;    &#125;&#125;</code></pre><pre><code class="java">public class Client &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;====类适配器模式&quot;);        Phone phone = new Phone();        phone.charging(new VoltageAdapter());    &#125;&#125;</code></pre><p>类适配器模式注意事项和细节</p><ol><li>Java是单继承机制 ，所以类适配器需要继承<code>src</code>这一点算是一个缺点，因为这要求<code>dst</code>必须是接口，有一定的局限性</li><li><code>src</code>类的方法在Adapter中都会暴露出来，增加了使用成本</li><li>由于其继承了<code>src</code>类，所以它可以根据需求重写<code>src</code>类的方法，使得Adapter的灵活性增强了\</li></ol><h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><p>基本介绍</p><ol><li>基本思路和类的适配器相同，只是将Adapter类做修改，不是继承<code>src</code>类，而是持有<code>src</code>的类型，以解决兼容问题。即：持有<code>src</code>类，实现<code>dst</code>类接口，完成<code>src</code>-&gt;<code>dst</code>的适配。</li><li>根据“合成复用原则”，在系统中尽量使用关联关系来代替继承关系。</li><li>对象适配器模式是适配器模式常用的一种</li></ol><pre><code class="java">/** * @description:被适配的类 **/public class Voltage220V &#123;    //提供220电压    public int output220V()&#123;        int src = 220;        System.out.println(&quot;电压=&quot; + src + &quot;V&quot;);        return src;    &#125;&#125;</code></pre><pre><code class="java">//适配接口public interface Voltage5V &#123;    public int output5V();&#125;</code></pre><pre><code class="java">/** * @description:适配器类 * 继承被适配的类 实现适配器类的接口 **/public class VoltageAdapter  implements Voltage5V &#123;    private Voltage220V voltage220;    //通过构造器 传入一个Voltage220V 实例    public VoltageAdapter(Voltage220V voltage220)&#123;        this.voltage220 = voltage220;    &#125;    @Override    public int output5V() &#123;        int destV = 0;        if (null != voltage220)&#123;            int src = voltage220.output220V();//获取220V电压            System.out.println(&quot;适配器适配&quot;);            destV = src /44;            System.out.println(&quot;适配完成，输出的电压为&quot; + destV);        &#125;        return destV;    &#125;&#125;</code></pre><pre><code class="java">/** * @description：手机 有充电方法 依赖了一个接口 **/public class Phone &#123;    //充电方法    public void charging (Voltage5V iVoltage)&#123;        if (iVoltage.output5V() == 5)&#123;            System.out.println(&quot;电压为5V，可冲&quot;);        &#125;else if (iVoltage.output5V() &gt; 5)&#123;            System.out.println(&quot;电压大于5V 无法充电&quot;);        &#125;    &#125;&#125;</code></pre><pre><code class="java">public class Client &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;====对象适配器模式&quot;);        Phone phone = new Phone();        phone.charging(new VoltageAdapter(new Voltage220V() ));    &#125;&#125;</code></pre><p>对象适配器模式注意事项和细节</p><ol><li>对象适配器和类适配器算是同一种思想，只不过是实现方式不同。根据合成服用原则，使用组合替代继承，所以他解决了适配器必须继承<code>src</code>的局限性问题，也不再要修<code>dst</code>必须是接口。</li><li>使用成本更低，更灵活</li></ol><h4 id="接口适配器模式"><a href="#接口适配器模式" class="headerlink" title="接口适配器模式"></a>接口适配器模式</h4><p>基本介绍</p><ol><li>一些书籍称为：适配器模式（Default Adapter Pattern）或缺省适配器模式。</li><li>当不需要全部实现接口提供的方法时，可以设计一个抽象类实现接口，并为该接口中每一个方法提供一个<strong>默认实现（空方法）</strong>，那么该抽象类的子类可有选择的覆盖父类的某些方法实现需求。</li><li>适用于一个接口不想使用其所有的方法的情况。</li></ol><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><ul><li><code>SpringMVC</code>中的<code>HandlerAdapter</code>就使用到了适配器模式 <strong>很牛逼，但是现在看不懂，记得回来看~</strong></li></ul><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ol><li>三种命名方式，是根据<code>src</code>以怎样的形式给到Adapter(在<code>Adapte</code>里的形式)来命名的。</li><li>三种适配器<ul><li>类适配器：以类给到，在Adapter里，就是将<code>src</code>当做类继承</li><li>对象适配器：以对象给到，在Adapter里，将<code>src</code>作为一个对象持有</li><li>接口适配器：以接口给到，在Adapter里，将<code>src</code>作为一个接口，实现</li></ul></li><li>Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。</li><li>实际开发中 实现不拘泥于这三种经典形式</li></ol><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>问题分析：类爆炸问题。</p><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>桥接模式(Bridge)：将实现与抽象类在两个不同的类层次中，使两个层次可以独立改变</li><li>Bridge基于类的最小设计原则，通过使用继承，聚合，封装等不同方式来让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)和实现(Implementation)分离开，从而可以保证各个部分的独立性以及对他们的功能扩展</li></ul><p>代码</p><pre><code class="java">//接口public interface Brand &#123;    void open();    void close();    void call();&#125;//Vivo实现类public class Vivo implements Brand &#123;    @Override    public void open() &#123;        System.out.println(&quot; Vivo手机开机 &quot;);    &#125;    @Override    public void close() &#123;        System.out.println(&quot; Vivo手机关机 &quot;);    &#125;    @Override    public void call() &#123;        System.out.println(&quot; Vivo手机打电话 &quot;);    &#125;&#125;//XiaoMi实现类public class XiaoMi implements Brand &#123;    @Override    public void open() &#123;        System.out.println(&quot; 小米手机开机 &quot;);    &#125;    @Override    public void close() &#123;        System.out.println(&quot; 小米手机关机 &quot;);    &#125;    @Override    public void call() &#123;        System.out.println(&quot; 小米手机打电话 &quot;);    &#125;&#125;</code></pre><pre><code class="java">//抽象成 桥public abstract class Phone &#123;    //组合品牌    private Brand brand;    //构造器    public Phone(Brand brand) &#123;this.brand = brand;&#125;    protected void open() &#123;        this.brand.open();    &#125;    protected void close() &#123;        brand.close();    &#125;    protected void call() &#123;        brand.call();    &#125;&#125;//两个抽象子类public class UpRightPhone extends Phone &#123;    //构造器    public UpRightPhone(Brand brand) &#123;        super(brand);    &#125;    public void open() &#123;        super.open();        System.out.println(&quot; 直立样式手机 &quot;);    &#125;    public void close() &#123;        super.close();        System.out.println(&quot; 直立样式手机 &quot;);    &#125;    public void call() &#123;        super.call();        System.out.println(&quot; 直立样式手机 &quot;);    &#125;&#125;//折叠式手机类，继承 抽象类 Phonepublic class FoldedPhone extends Phone &#123;    //构造器    public FoldedPhone(Brand brand) &#123;        super(brand);    &#125;    public void open() &#123;        super.open();        System.out.println(&quot; 折叠样式手机 &quot;);    &#125;    public void close() &#123;        super.close();        System.out.println(&quot; 折叠样式手机 &quot;);    &#125;    public void call() &#123;        super.call();        System.out.println(&quot; 折叠样式手机 &quot;);    &#125;&#125;</code></pre><pre><code class="java">//客户端实现方式public class Client &#123;    public static void main(String[] args) &#123;        //获取折叠式手机 (样式 + 品牌 )        Phone phone1 = new FoldedPhone(new XiaoMi());        phone1.open();        phone1.call();        phone1.close();        Phone phone2 = new FoldedPhone(new Vivo());        phone2.open();        phone2.call();        phone2.close();        UpRightPhone phone3 = new UpRightPhone(new XiaoMi());        phone3.open();        phone3.call();        phone3.close();        UpRightPhone phone4 = new UpRightPhone(new Vivo());        phone4.open();        phone4.call();        phone4.close();    &#125;&#125;</code></pre><h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><ol><li><code>JDBC</code>的Driver接口，从桥接模式来看，Driver就是一个接口，下面可以有<code>Mysql</code>的Driver，也可以有<code>Orical</code>的Driver，这些就可以当做实现接口类</li></ol><p><img src="http://www.slx.blue/2021/12/03/javaDesignMode/JDBCqiaojie.jpg" alt="java"></p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ol><li>实现了抽象和实现类的分离，极大地提升了系统的灵活性，让抽象类和实现类部分独立开，有助于系统实现分层设计，从而产生更好的结构化系统。</li><li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口即可，其他的部分有具体业务来完成。</li><li>桥接模式替代了多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。</li><li>桥接模式的引入增加了系统的理解和设计难度，由于聚和关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。</li><li>桥接模式要求正确识别出系统两个独立变化的维度，因此适用范围有一定的局限性。</li><li>常见的应用场景:<ul><li><code>JDBC</code>驱动系统</li><li>银行转账系统<ul><li>转账分类：网上转账，柜台转账，ATM转账</li><li>转账用户类型：普通用户，银卡用户，金卡用户…</li></ul></li><li>消息管理<ul><li>消息类型：即使消息，延时消息..</li><li>消息分类：短信，<code>QQ</code>，微信..</li></ul></li></ul></li></ol><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><blockquote><p><strong>定义</strong>：<strong>动态的将新功能附加到对象上</strong>，在对象功能扩展方面，比继承更有弹性，也体现了开闭原则(<code>OCP</code>)</p></blockquote><h4 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h4><ul><li>星巴克咖啡订单项目(咖啡馆)</li><li>咖啡种类/单品咖啡：咖啡种类/单品咖啡:Espresso(意大利浓咖啡)、<code>ShortBlack</code>、<code>LongBlack</code>(美式咖啡)、Decaf(无因咖啡)</li><li>调料:Milk、Soy(豆浆)、Chocolate</li><li>要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便</li><li>使用<code>OO</code>的来计算不同种类咖啡的费用:客户可以点单品咖啡，也可以单品咖啡+调料组合。</li></ul><p>分析，一份单品咖啡可能有多份调料，而且单品咖啡和调料应该易于扩展，符合开闭原则。所以不能把单品咖啡和调料融合在一起，应该把咖啡当做<strong>被装饰者</strong>，调料当成<strong>装饰者</strong>，实现调料的具体子类为修饰着。图解图下</p><p><img src="http://www.slx.blue/2021/12/03/javaDesignMode/decorator.jpg" alt="java"></p><pre><code class="java">//总抽象类Drink 被装饰者public abstract class Drink &#123;    public String des; // 描述    private float price = 0.0f;    //...实现get 和 set方法        //计算费用的抽象方法    //子类来实现    public abstract float cost();&#125;//咖啡类 作为缓存层  旗下是单体咖啡实类public class Coffee  extends Drink &#123;    @Override    public float cost() &#123;        return super.getPrice();    &#125;&#125;//两种咖啡种类public class DeCaf extends Coffee &#123;    public DeCaf() &#123;        setDes(&quot; 无因咖啡 &quot;); //介绍        setPrice(1.0f);        //咖啡价格    &#125;&#125;public class Espresso extends Coffee &#123;    public Espresso() &#123;        setDes(&quot; 意大利咖啡 &quot;);        setPrice(6.0f);    &#125;&#125;</code></pre><pre><code class="java">//Decorator装饰者public class Decorator extends Drink &#123;    private Drink obj; //被装饰者    public Decorator(Drink obj) &#123; //组合被装饰者        this.obj = obj;    &#125;    @Override    public float cost() &#123;        // getPrice 自己价格        return super.getPrice() + obj.cost();    &#125;    @Override    public String getDes() &#123;        // obj.getDes() 输出被装饰者的信息        return des + &quot; &quot; + getPrice() + &quot; &amp;&amp; &quot; + obj.getDes();    &#125;&#125;//具体的Decorator， 这里就是调味品public class Milk extends Decorator &#123;    public Milk(Drink obj) &#123;        super(obj);        setDes(&quot; 牛奶 &quot;);        setPrice(2.0f);     &#125;&#125;public class Soy extends Decorator&#123;    public Soy(Drink obj) &#123;        super(obj);        setDes(&quot; 豆浆  &quot;);        setPrice(1.5f);    &#125;&#125;public class Chocolate extends Decorator &#123;    public Chocolate(Drink obj) &#123;        super(obj);        setDes(&quot; 巧克力 &quot;);        setPrice(3.0f); // 调味品 的价格    &#125;&#125;</code></pre><pre><code class="java">//具体实现代码public class CoffeeBar &#123;    public static void main(String[] args) &#123;        // 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack        // 1. 点一份 LongBlack        Drink order = new LongBlack();        System.out.println(&quot;费用1=&quot; + order.cost());        System.out.println(&quot;描述=&quot; + order.getDes());        // 2. order 加入一份牛奶        order = new Milk(order);        System.out.println(&quot;order 加入一份牛奶 费用 =&quot; + order.cost());        System.out.println(&quot;order 加入一份牛奶 描述 = &quot; + order.getDes());        // 3. order 加入一份巧克力        order = new Chocolate(order);        System.out.println(&quot;order 加入一份牛奶 加入一份巧克力  费用 =&quot; + order.cost());        System.out.println(&quot;order 加入一份牛奶 加入一份巧克力 描述 = &quot; + order.getDes());        // 3. order 加入一份巧克力        order = new Chocolate(order);        System.out.println(&quot;order 加入一份牛奶 加入2份巧克力   费用 =&quot; + order.cost());        System.out.println(&quot;order 加入一份牛奶 加入2份巧克力 描述 = &quot; + order.getDes());        System.out.println(&quot;===========================&quot;);                Drink order2 = new DeCaf();                System.out.println(&quot;order2 无因咖啡  费用 =&quot; + order2.cost());        System.out.println(&quot;order2 无因咖啡 描述 = &quot; + order2.getDes());                order2 = new Milk(order2);                System.out.println(&quot;order2 无因咖啡 加入一份牛奶  费用 =&quot; + order2.cost());        System.out.println(&quot;order2 无因咖啡 加入一份牛奶 描述 = &quot; + order2.getDes());    &#125;&#125;</code></pre><h4 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h4><blockquote><p>Java的IO结构，<code>FilterInputStream</code>就是一个<strong>装饰者</strong></p></blockquote><p><img src="http://www.slx.blue/2021/12/03/javaDesignMode/InputStream.jpg" alt="java"></p><pre><code class="java">public class DecoratorToJDKIO &#123;    public static void main(String[] args) throws Exception &#123;        /*说明            1. InputStream是抽象类,类似我们前面讲的 Drink            2.FileInputStream是 InputStream子类，类似我们前面的 DeCaf, LongBlack            3.FilterInputStream是 InputStream子类:类似我们前面的Decorator修饰者            4. DatalnputStream是 FilterInputStream子类，具体的修饰者，类似前面的 Milk, Soy 等            5.FilterInputStream类有protected volatile InputStream in;即含被装饰者            6.分析得出在jdk 的io体系中，就是使用装饰者模式         */        DataInputStream dis = new DataInputStream(new FileInputStream(&quot;/&quot;));        System.out.println(dis.read());        dis.close();    &#125;&#125;</code></pre><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><h4 id="案例分析："><a href="#案例分析：" class="headerlink" title="案例分析："></a>案例分析：</h4><p><img src="http://www.slx.blue/2021/12/03/javaDesignMode/composition.png" alt="java"></p><p>传统方案解决问题分析</p><ul><li>将学院看做了学校的子类，将专业看做了学院的子类，相当于从组织大小进行分成</li><li>但是这样不能很好的实现管理操作，比如增删改查。</li><li>解决方案，把学校，学院，专业当做组织结构，她们之间没有继承关系，而是一个树形结构，可以更好的实现管理操作，=&gt; 组合模式</li></ul><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>组合模式(Composite Patterm）)，又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系。</li><li>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</li><li>组合模式使得用户对单个对象和组合对象的访问具有一致性，即:组合能让客户以一致的方式处理个别对象以及组合对象</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="java">public abstract class OrganizationComponent &#123;    private String name; // 名字    private String des; // 说明        protected  void add(OrganizationComponent organizationComponent) &#123;        //默认实现        throw new UnsupportedOperationException();//不支持操作异常    &#125;    protected  void remove(OrganizationComponent organizationComponent) &#123;        //默认实现        throw new UnsupportedOperationException();    &#125;    //构造器    public OrganizationComponent(String name, String des) &#123;        super();        this.name = name;        this.des = des;    &#125;    //实现getset方法。。。。        //方法print, 做成抽象的, 子类都需要实现    protected abstract void print();&#125;</code></pre><pre><code class="java">//Collegepublic class College extends OrganizationComponent &#123;    //List 中 存放的Department    List&lt;OrganizationComponent&gt; organizationComponents = new ArrayList&lt;OrganizationComponent&gt;();    // 构造器    public College(String name, String des) &#123;        super(name, des);    &#125;    // 重写add    @Override    protected void add(OrganizationComponent organizationComponent) &#123;        //  将来实际业务中，Colleage 的 add 和  University add 不一定完全一样        organizationComponents.add(organizationComponent);    &#125;    // 重写remove    @Override    protected void remove(OrganizationComponent organizationComponent) &#123;        organizationComponents.remove(organizationComponent);    &#125;    @Override    public String getName() &#123;        return super.getName();    &#125;    @Override    public String getDes() &#123;        return super.getDes();    &#125;    // print方法，就是输出University 包含的学院    @Override    protected void print() &#123;        System.out.println(&quot;--------------&quot; + getName() + &quot;--------------&quot;);        //遍历 organizationComponents         for (OrganizationComponent organizationComponent : organizationComponents) &#123;            organizationComponent.print();        &#125;    &#125;&#125;//University 就是 Composite , 可以管理Collegepublic class University extends OrganizationComponent &#123;    List&lt;OrganizationComponent&gt; organizationComponents = new ArrayList&lt;OrganizationComponent&gt;();    // 构造器    public University(String name, String des) &#123;        super(name, des);    &#125;    // 重写add    @Override    protected void add(OrganizationComponent organizationComponent) &#123;        organizationComponents.add(organizationComponent);    &#125;    // 重写remove    @Override    protected void remove(OrganizationComponent organizationComponent) &#123;        organizationComponents.remove(organizationComponent);    &#125;    @Override    public String getName() &#123;        return super.getName();    &#125;    @Override    public String getDes() &#123;        return super.getDes();    &#125;    // print方法，就是输出University 包含的学院    @Override    protected void print() &#123;        System.out.println(&quot;--------------&quot; + getName() + &quot;--------------&quot;);        //遍历 organizationComponents         for (OrganizationComponent organizationComponent : organizationComponents) &#123;            organizationComponent.print();        &#125;    &#125;&#125;//Departmentpublic class Department extends OrganizationComponent &#123;    //没有集合    public Department(String name, String des) &#123;        super(name, des);    &#125;    //add , remove 就不用写了，因为他是叶子节点        @Override    public String getName() &#123;        return super.getName();    &#125;        @Override    public String getDes() &#123;        return super.getDes();    &#125;        @Override    protected void print() &#123;        System.out.println(getName());    &#125;&#125;</code></pre><pre><code class="java">//Client实现public class Client &#123;    public static void main(String[] args) &#123;        //从大到小创建对象 学校        OrganizationComponent university = new University(&quot;清华大学&quot;, &quot; 中国顶级大学 &quot;);                //创建 学院        OrganizationComponent computerCollege = new College(&quot;计算机学院&quot;, &quot; 计算机学院 &quot;);        OrganizationComponent infoEngineercollege = new College(&quot;信息工程学院&quot;, &quot; 信息工程学院 &quot;);                //创建各个学院下面的系(专业)        computerCollege.add(new Department(&quot;软件工程&quot;, &quot; 软件工程不错 &quot;));        computerCollege.add(new Department(&quot;网络工程&quot;, &quot; 网络工程不错 &quot;));        computerCollege.add(new Department(&quot;计算机科学与技术&quot;, &quot; 计算机科学与技术是老牌的专业 &quot;));                //        infoEngineercollege.add(new Department(&quot;通信工程&quot;, &quot; 通信工程不好学 &quot;));        infoEngineercollege.add(new Department(&quot;信息工程&quot;, &quot; 信息工程好学 &quot;));                //将学院加入到 学校        university.add(computerCollege);        university.add(infoEngineercollege);                //university.print();        infoEngineercollege.print();    &#125;&#125;</code></pre><p>注意事项：</p><p>注意事项和细节</p><ol><li>简化客户端操作，客户端只需要面对一致的对象而不用考虑整体部分或者叶子结点的问题。</li><li>具有较强的扩展性，当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动。</li><li>方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加结点或者叶子从而创建出复杂的树形结构</li><li>需要便利组织结构，或者处理的对象具有树形结构时，非常适合使用组合模式</li><li>要求较高的抽象性， 如果结点和叶子具有很多差异性的话，比如很多方法和属性都不一样，不适合用组合模式</li></ol><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>外观模式(Facade)，也叫“过程模式” : 外观模式为子系统的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</li><li>外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关系这个子系统的内部细节</li></ul><p>原理类图说明(外观模式的角色)</p><ol><li>外观类(Facade):为调用端提供统一的调用接口，外观类知道哪些子类系统负责处理请求，从而将调用端的请求代理给适当的子系统对象</li><li>调用者(Client):外观接口的调用者</li><li>子系统的集合:指模块或者子系统，处理Facade对象指派的任务，他是功能的提供者</li></ol><p>外观模式就是解决多个复杂接口带来的使用困难，起到简化用户使用的作用。</p><h4 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h4><blockquote><p><code>Mybatis</code>中的configuration中使用了外观模式，</p><p>用户只需要传递一个Object，调用<code>metaObject</code>方法，而<code>getMetaObeject</code>方法中则组合了一系列<code>ObjectFactory</code>,一次判断返回的实例。相当于简化了用户的操作，在内部实现了一系列逻辑、</p><p>当我们调用子系统变得很困难的时候，以更高一层的接口来调用子系统，来提高系统使用和复用。</p></blockquote><p>外观模式的注意事项和细节</p><ol><li>外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性</li><li>外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展</li><li>通过合理使用外观模式，可以帮助我们更好的划分访问的层次</li><li>当系统需要进行分层设计时，可以考虑使用Facade模式</li><li>在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性</li><li>不能过多的或者不合理的使用外观模式，使用外观模式好还是直接调用模块好。要以让系统有层次，利于维护为目的。</li></ol><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><h4 id="案例分析-2"><a href="#案例分析-2" class="headerlink" title="案例分析"></a>案例分析</h4><p>小型的外包项目，给客户A做一个产品展示网站，客户A的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同:</p><ul><li>有客户要求以新闻的形式发布</li><li>有客户人要求以博客的形式发布</li><li>有客户希望以微信公众号的形式发布</li></ul><blockquote><p>1)需要的网站结构相似度很高，而且都不是高访问量网站，如果分成多个虚拟空间来处理,<br>相当于一个相同网站<br>的实例对象很多，造成服务器的资源浪费<br>2)解决思路:整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源<br>都可以达成共享，减少服务器资源<br>3)对于代码来说，由于是一份实例，维护和扩展都更加容易<br>4)上面的解决思路就可以使用享元模式来解决</p></blockquote><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li><p>享元模式(Flyweight Pattern)也叫蝇量模式:运用共享技术有效地支持大量细粒度的对象</p></li><li><p>常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个</p></li><li><p>享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率</p></li><li><p>享元模式经典的应用场景就是池技术了，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式</p></li></ol><p><img src="http://www.slx.blue/2021/12/03/javaDesignMode/xiangyuan.jpg" alt="java"></p><blockquote><p>对类图的说明<br>对原理图的说明-即(模式的角色及职责)</p><ol><li><code>FlyWeight</code>是抽象的享元角色，他是产品的抽象类,同时定义出对象的外部状态和内部状态(后面介绍)的接口或实现</li><li><code>ConcreteFlyWeight</code>是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务</li><li><code>UnSharedConcreteFlyWeight</code>是不可共享的角色，一般不会出现在享元工厂。</li><li><code>FlyWeightFactory</code>享元工厂类，用于构建一个池容器(集合)，同时提供从池中获取对象方法</li></ol></blockquote><p>类似线程池，享元共享的数据是不可变的，可以共享资源。如果没有就创建，有就直接拿来用</p><pre><code class="java">//用户public class User &#123;     private String name;    public User(String name) &#123;        super();        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;//网站的抽象类public abstract class WebSite &#123;    public abstract void use(User user);//抽象方法&#125;</code></pre><pre><code class="java">// 网站工厂类，根据需要返回压一个网站public class WebSiteFactory &#123;    //集合， 充当池的作用    private HashMap&lt;String, ConcreteWebSite&gt; pool = new HashMap&lt;&gt;();        //根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回    public WebSite getWebSiteCategory(String type) &#123;        if(!pool.containsKey(type)) &#123;            //就创建一个网站，并放入到池中            pool.put(type, new ConcreteWebSite(type));        &#125;                return (WebSite)pool.get(type);    &#125;        //获取网站分类的总数 (池中有多少个网站类型)    public int getWebSiteCount() &#123;        return pool.size();    &#125;&#125;//具体网站public class ConcreteWebSite extends WebSite &#123;    //共享的部分，内部状态    private String type = &quot;&quot;; //网站发布的形式(类型)    //构造器    public ConcreteWebSite(String type) &#123;                this.type = type;    &#125;    @Override    public void use(User user) &#123;        System.out.println(&quot;网站的发布形式为:&quot; + type + &quot; 在使用中 .. 使用者是&quot; + user.getName());    &#125;&#125;</code></pre><pre><code class="java">//Client 客户端public class Client &#123;    public static void main(String[] args) &#123;        // 创建一个工厂类        WebSiteFactory factory = new WebSiteFactory();        // 客户要一个以新闻形式发布的网站        WebSite webSite1 = factory.getWebSiteCategory(&quot;新闻&quot;);                webSite1.use(new User(&quot;tom&quot;));        // 客户要一个以博客形式发布的网站        WebSite webSite2 = factory.getWebSiteCategory(&quot;博客&quot;);        webSite2.use(new User(&quot;jack&quot;));        // 客户要一个以博客形式发布的网站        WebSite webSite3 = factory.getWebSiteCategory(&quot;博客&quot;);        webSite3.use(new User(&quot;smith&quot;));        // 客户要一个以博客形式发布的网站        WebSite webSite4 = factory.getWebSiteCategory(&quot;博客&quot;);        webSite4.use(new User(&quot;king&quot;));        System.out.println(&quot;网站的分类共=&quot; + factory.getWebSiteCount());    &#125;&#125;</code></pre><h4 id="源码分析-4"><a href="#源码分析-4" class="headerlink" title="源码分析"></a>源码分析</h4><pre><code class="java">public class FlyWeight &#123;    public static void main(String[] args) &#123;        //如果 Integer.valueOf(x) x 在  -128 --- 127 直接，就是使用享元模式返回,如果不在        //范围类，则仍然 new         //小结:        //1. 在valueOf 方法中，先判断值是否在 IntegerCache 中，         //如果不在，就创建新的Integer(new), 否则，就直接从 缓存池返回        //2. valueOf 方法，就使用到享元模式        //3. 如果使用valueOf 方法得到一个Integer 实例，范围在 -128 - 127 ，执行速度比 new 快        Integer x = Integer.valueOf(127); // 得到 x实例，类型 Integer        Integer y = new Integer(127); // 得到 y 实例，类型 Integer        Integer z = Integer.valueOf(127);//..        Integer w = new Integer(127);                System.out.println(x.equals(y)); // 大小，true        System.out.println(x == y ); //  false        System.out.println(x == z ); // true        System.out.println(w == x ); // false        System.out.println(w == y ); // false                Integer x1 = Integer.valueOf(200);        Integer x2 = Integer.valueOf(200);        System.out.println(&quot;x1==x2&quot; + (x1 == x2)); // false    &#125;&#125;</code></pre><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ol><li>享元模式中的享可以理解为共享，元理解为对象，就是共享对象模式。比如共享连接池</li><li>系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式</li><li>用唯一标识码判断，如果内存中有，则返回这个唯一标识码所标识的对象，用<code>HashMap/HashTable</code>存储</li><li>享元模式大大的减少了对象的创建，降低了程序内存的占用，提高效率。</li><li>享元模式提高了系统的复杂度，因为需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这点在使用享元模式需要注意。</li><li>使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制，</li><li>享元模式经典的应用场景是需要缓冲池，比如String常量池，数据库连接池，以及围棋观赛黑白子对象。</li></ol><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><h4 id="案例分析-3"><a href="#案例分析-3" class="headerlink" title="案例分析"></a>案例分析</h4><p>制作豆浆</p><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>模板方法模式(Template  Method Pattern) ,在一个抽象类公开了执行它的方法的模板。它的子类可以按需重写方法实现，但调用将以抽象类中定义的方法执行。</li><li>简单说模板方法模式定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构就可以重定义该算法的某些步骤。</li></ol><p>原理类图说明</p><ul><li><code>AbstractClass</code> 抽象类，类中实现了模板方法，定义了算法的骨架，具体子类需要去实现 其他的抽象方法</li><li><code>ConcreateClass</code> 实现抽象方法，已完成算法中特点子类的步骤</li></ul><pre><code class="java">//抽象类，表示豆浆public abstract class SoyaMilk &#123;    //模板方法, make , 模板方法可以做成final , 不让子类去覆盖.    final void make() &#123;        select();         if(customerWantCondiments()) &#123; //判断是实现默认方法还是子类重写的方法            addCondiments();        &#125;        soak();        beat();    &#125;        //选材料    void select() &#123;        System.out.println(&quot;第一步：选择好的新鲜黄豆  &quot;);    &#125;        //添加不同的配料， 抽象方法, 子类具体实现    abstract void addCondiments();        //浸泡    void soak() &#123;        System.out.println(&quot;第三步， 黄豆和配料开始浸泡， 需要3小时 &quot;);    &#125;         void beat() &#123;        System.out.println(&quot;第四步：黄豆和配料放到豆浆机去打碎  &quot;);    &#125;        //钩子方法，决定是否需要添加配料    boolean customerWantCondiments() &#123;        return true;    &#125;&#125;</code></pre><pre><code class="java">public class RedBeanSoyaMilk extends SoyaMilk &#123;    @Override    void addCondiments() &#123;        System.out.println(&quot; 加入上好的红豆 &quot;);    &#125;&#125;public class PureSoyaMilk extends SoyaMilk &#123;    @Override    void addCondiments() &#123;        //空实现    &#125;    @Override    boolean customerWantCondiments() &#123;        return false;    &#125;&#125;public class PeanutSoyaMilk extends SoyaMilk &#123;    @Override    void addCondiments() &#123;        System.out.println(&quot; 加入上好的花生 &quot;);    &#125;&#125;</code></pre><pre><code class="java">public class Client &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;----制作红豆豆浆----&quot;);        SoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk();        redBeanSoyaMilk.make();                System.out.println(&quot;----制作花生豆浆----&quot;);        SoyaMilk peanutSoyaMilk = new PeanutSoyaMilk();        peanutSoyaMilk.make();                System.out.println(&quot;----制作纯豆浆----&quot;);        SoyaMilk pureSoyaMilk = new PureSoyaMilk();        pureSoyaMilk.make();    &#125;&#125;</code></pre><p>在模板方法中添加一个钩子方法默认不做事，子类就可以根据狗子方法来决定是否覆盖这个方法。</p><p>这样就可以默认实现了</p><h4 id="源码分析-5"><a href="#源码分析-5" class="headerlink" title="源码分析"></a>源码分析</h4><blockquote><p>Spring中 <code>IOC</code>容器初始化的时候 使用了模板模式</p></blockquote><h4 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h4><ol><li>基本思想是，算法只存在于一个地方，也就是在父类中，容易修改。修改算法时，只需要修改父类方法或者已经实现的某些步骤，子类就会继承这些修改。</li><li>实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接使用。</li><li>即统一了算法，也提供了很大的灵活性，父类的模板方法确保了算法结构保持不变，同时由子类提供部分步骤的实现。</li><li>该模式不足之处是 每一个不同的实现都需要一个子类实现，容易导致类的个数增加导致系统庞大</li><li>一般方法都加上关键字final，防止子类重写模板方法</li><li>模板方法使用场景：当要完成在某个过程，该过程要执行一系列步骤，这一系列的步骤基本相同，单个别步骤在实现的时候可能不同，通常考虑用模板方法来处理。</li></ol><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h4 id="案例需求"><a href="#案例需求" class="headerlink" title="案例需求"></a>案例需求</h4><p>1)我们买了一套智能家电，有照明灯、风扇、冰箱、洗衣机，我们只要在手机上安装 <code>app</code>就可以控制对这些家电<br>工作。<br>2)这些智能家电来自不同的厂家，我们不想针对每一种家电都安装一个<code>App</code>，分别控制，我们希望只要一个<code>app</code><br>就可以控制全部智能家电。<br>3)要实现一个<code>app</code>控制所有智能家电的需要，则每个智能家电厂家都要提供一个统一的接口给app调用，这时就<br>可以考虑使用命令模式。<br>4)命令模式可将“动作的请求者”从“动作的执行者”对象中解耦出来.<br>5)在我们的例子中，动作的请求者是手机 <code>app</code>，动作的执行者是每个厂商的一个家电产品</p><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>命令模式(Command Pattern):在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收<br>者是谁，也不知道被请求的操作是哪个，<br>我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计</li><li>命名模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。</li><li>在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求(即命名)，同时命令模式<br>也支持可撤销的操作。</li><li>通俗易懂的理解:将军发布命令，士兵去执行。其中有几个角色:将军(命令发布者)、士兵(命令的具体执<br>行者)、命令(连接将军和士兵)。<br><code>lInvoker</code>是调用者（将军)，Receiver是被调用者（士兵)，<code>MyCommand</code>是命令，实现了Command接口，持有接收对象</li></ul><h4 id="原理类图分析"><a href="#原理类图分析" class="headerlink" title="原理类图分析"></a>原理类图分析</h4><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>类图分析：</p><p><img src="http://www.slx.blue/2021/12/03/javaDesignMode/command.png" alt="java"></p><pre><code class="java">//创建命令接口public interface Command &#123;    //执行动作(操作)    public void execute();    //撤销动作(操作)    public void undo();&#125;//关灯命令public class LightOffCommand implements Command &#123;    // 聚合LightReceiver    LightReceiver light;    // 构造器    public LightOffCommand(LightReceiver light) &#123;            this.light = light;        &#125;    @Override    public void execute() &#123;        // 调用接收者的方法        light.off();    &#125;    @Override    public void undo() &#123;        // 调用接收者的方法        light.on();    &#125;&#125;//开灯命令public class LightOnCommand implements Command &#123;    //聚合LightReceiver    LightReceiver light;        //构造器    public LightOnCommand(LightReceiver light) &#123;        this.light = light;    &#125;    @Override    public void execute() &#123;        //调用接收者的方法        light.on();    &#125;    @Override    public void undo() &#123;        //调用接收者的方法        light.off();    &#125;&#125;/** * 没有任何命令，即空执行: 用于初始化每个按钮, 当调用空命令时，对象什么都不做 * 其实，这样是一种设计模式, 可以省掉对空判断 * @author Administrator * */public class NoCommand implements Command &#123;    //只需要实现两个空方法 钩子    @Override    public void execute() &#123;    &#125;    @Override    public void undo() &#123;    &#125;&#125;//任务接收者 执行者public class LightReceiver &#123;    public void on() &#123;        System.out.println(&quot; 电灯打开了.. &quot;);    &#125;    public void off() &#123;        System.out.println(&quot; 电灯关闭了.. &quot;);    &#125;&#125;</code></pre><pre><code class="java">//控制器 遥控器 Invoker 任务发布者public class RemoteController &#123;    // 开 按钮的命令数组    Command[] onCommands;    Command[] offCommands;    // 执行撤销的命令    Command undoCommand;    // 构造器，完成对按钮初始化    public RemoteController() &#123;        onCommands = new Command[5];        offCommands = new Command[5];        for (int i = 0; i &lt; 5; i++) &#123;            onCommands[i] = new NoCommand();            offCommands[i] = new NoCommand();        &#125;    &#125;    // 给我们的按钮设置你需要的命令    public void setCommand(int no, Command onCommand, Command offCommand) &#123;        onCommands[no] = onCommand;        offCommands[no] = offCommand;    &#125;    // 按下开按钮    public void onButtonWasPushed(int no) &#123; // no 0        // 找到你按下的开的按钮， 并调用对应方法        onCommands[no].execute();        // 记录这次的操作，用于撤销        undoCommand = onCommands[no];    &#125;    // 按下开按钮    public void offButtonWasPushed(int no) &#123; // no 0        // 找到你按下的关的按钮， 并调用对应方法        offCommands[no].execute();        // 记录这次的操作，用于撤销        undoCommand = offCommands[no];    &#125;        // 按下撤销按钮    public void undoButtonWasPushed() &#123;        undoCommand.undo();    &#125;&#125;</code></pre><pre><code class="java">//Client客户端public class Client &#123;    public static void main(String[] args) &#123;        //使用命令设计模式，完成通过遥控器，对电灯的操作        //创建电灯的对象(接受者)        LightReceiver lightReceiver = new LightReceiver();                //创建电灯相关的开关命令        LightOnCommand lightOnCommand = new LightOnCommand(lightReceiver);        LightOffCommand lightOffCommand = new LightOffCommand(lightReceiver);                //需要一个遥控器        RemoteController remoteController = new RemoteController();                //给我们的遥控器设置命令, 比如 no = 0 是电灯的开和关的操作        remoteController.setCommand(0, lightOnCommand, lightOffCommand);                System.out.println(&quot;--------按下灯的开按钮-----------&quot;);        remoteController.onButtonWasPushed(0);        System.out.println(&quot;--------按下灯的关按钮-----------&quot;);        remoteController.offButtonWasPushed(0);        System.out.println(&quot;--------按下撤销按钮-----------&quot;);        remoteController.undoButtonWasPushed();                //如果后期需要扩展新的命令 就非常容易扩展 不需要修改Controller的内容 符合开闭原则        /*        System.out.println(&quot;=========使用遥控器操作电视机==========&quot;);        TVReceiver tvReceiver = new TVReceiver();        TVOffCommand tvOffCommand = new TVOffCommand(tvReceiver);        TVOnCommand tvOnCommand = new TVOnCommand(tvReceiver);        //给我们的遥控器设置命令, 比如 no = 1 是电视机的开和关的操作        remoteController.setCommand(1, tvOnCommand, tvOffCommand);                System.out.println(&quot;--------按下电视机的开按钮-----------&quot;);        remoteController.onButtonWasPushed(1);        System.out.println(&quot;--------按下电视机的关按钮-----------&quot;);        remoteController.offButtonWasPushed(1);        System.out.println(&quot;--------按下撤销按钮-----------&quot;);        remoteController.undoButtonWasPushed();        */    &#125;&#125;</code></pre><h4 id="源码分析-6"><a href="#源码分析-6" class="headerlink" title="源码分析"></a>源码分析</h4><blockquote><p>Spring中的JDBCTemplate中使用了模板模式</p></blockquote><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><blockquote><p>注意事项和细节</p></blockquote><ol><li>将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的execute()方法就可以让接收着工作，而不必知道记得接收着对象谁，如何实现的，命令对象会负责让接受者执行请求的动作，也就是“请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了扭到桥梁的作用。</li><li>容易设计一个命令队列，只要把命令对象放到队列，就可以实现多线程的命令</li><li>容易实现对请求的撤销和重做</li><li>命令模式的不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在使用的时候要注意</li><li>空命令也是一种设计模式，它为我们省去了判空的操作，在上面的案例，如果没有用空命令，那么每一个按键我们都要做判空操作，对编码带来了一定的麻烦。</li><li>命令模式经典的应用场景：界面的一个按钮都是一条命令，模拟CMD（DOS）命令，订单的撤销/恢复、触发反馈机制</li></ol>]]></content>
      
      
      <categories>
          
          <category> designMode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
