

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Blue~u~u~u">
  <meta name="author" content="Blue~u~u~u">
  <meta name="keywords" content="">
  <meta name="description" content="JVM学习笔记第一章第一节 JDK、JRE、JVM关系回顾 JVM：Java Virtual Machine，翻译过来是Java虚拟机 JRE：Java Runtime Environment，翻译过来是Java运行时环境 JRE&#x3D;JVM+Java程序运行时所需要的类库   JDK：Java Development Kits，翻译过来是Java开发工具包 JDK&#x3D;JRE+Java开发辅助工具">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM学习笔记整理">
<meta property="og:url" content="http://www.slx.blue/2022/03/06/JVM/index.html">
<meta property="og:site_name" content="Blue~u~u~u~u">
<meta property="og:description" content="JVM学习笔记第一章第一节 JDK、JRE、JVM关系回顾 JVM：Java Virtual Machine，翻译过来是Java虚拟机 JRE：Java Runtime Environment，翻译过来是Java运行时环境 JRE&#x3D;JVM+Java程序运行时所需要的类库   JDK：Java Development Kits，翻译过来是Java开发工具包 JDK&#x3D;JRE+Java开发辅助工具">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM01.jpg?versionId=CAEQKRiBgMDHwJ77.hciIDVjYTEwZDJmMjM0MTQ2YTM4NDljZjgxMzk4MGM3YjI4">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM02.png?versionId=CAEQKRiBgIDJwJ77.hciIDg0YmZmZjZlNmMzYjQ2MzJiNmIxNzRhMTNjZDFmMTYz">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM03.png?versionId=CAEQKRiBgICdwJ77.hciIDgwOTM5ZGQyZDYwYjQwYTY5ZTFjOTM3MDVkMzIyODI2">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM04.jpg?versionId=CAEQKRiBgMCswJ77.hciIDNmMjllNGU5MWU4NjQxYzNhNzQyYTViNmQ0ZTJjN2U3">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM05.jpg?versionId=CAEQKRiBgMC7vp77.hciIDI2ZTJjZGMzNjJiNDRjYTQ5YzY0YjI3OWJiNDUzYTFh">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM06.jpg?versionId=CAEQKRiBgIDfvp77.hciIDMzZTk4NjM0YTMxNTRlYmY5M2ZhMThkNWY2N2I2YmMy">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM07.jpg?versionId=CAEQKRiBgMC.vp77.hciIDU2ZTRiNmI1ZWUzZjRmMzFhYjg5MTkzZmFhMDA1ZDFm">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM08.jpg?versionId=CAEQKRiBgMCcvp77.hciIDdkNGYzYTJmY2I2YjQwNTM4Zjk2MDkxYTUzZmRmNTlk">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM09.png?versionId=CAEQKRiBgID7vp77.hciIDJmNWE1M2Q4MzYzYTQxYjM5OGM4M2VkNjdjM2MzZjZl">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM10.jpg?versionId=CAEQKRiBgMDwvZ77.hciIDEzODVjZmUzYmQ0YzQzZmRhMTRlYjhmYzFiYzkyYWU5">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM11.jpg?versionId=CAEQKRiBgMDuvZ77.hciIDYxNDdkYzY2NDA4ZDRmNDhhNjRmMTE1NGM2NzNlMDM2">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM12.jpg?versionId=CAEQKRiBgMDovZ77.hciIDk0ZWY4Yjg3NmFkYTRmMmJhZDM2OTUwYzA4NzYxOTJh">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM13.jpg?versionId=CAEQKRiBgMDnvZ77.hciIGZkN2Y1OGY5NGFkMDRkYTE5YWQxOWM3M2EzMDEzOTQx">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM14.jpg?versionId=CAEQKRiBgMDhvZ77.hciIGIzYjc1MjRjZGQ5NjRhNTU5Mzc1NTk3Y2EyNjRhMGU4">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM15.jpg?versionId=CAEQKRiBgMCcvJ77.hciIDlhOTRkMmVlN2ZhMDQ2NWY4MmE1YTBjZDI5YWUxMWYy">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM16.jpg?versionId=CAEQKRiBgMCavJ77.hciIDEwMWViOTQzODE3NzQ3YWFiNTk2ODE4ODQwMDY2NmMw">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM17.jpg?versionId=CAEQKRiBgMCNvJ77.hciIDg5OGViNmNiYjgyNDQyMTFiNTljMTNhMzViYjRhNzNm">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM52.jpg?versionId=CAEQKRiBgID.tp77.hciIGM4NDllOGIyYmNlNzQ5ZjVhOGVkYmQ2ZTI4OGJlNTUw">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM53.jpg?versionId=CAEQKRiBgID8t577.hciIDExM2UyNWVjM2FjNzRmMzE4OWY4ZTVkMTRjZDcxYjM1">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM18.jpg?versionId=CAEQKRiBgMCbvJ77.hciIDhlNjJkOThjZDUxNTQ2YWY4MjFjYTljMjUwNGM3NTZl">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM19.jpg?versionId=CAEQKRiBgICGvJ77.hciIDJlYTQ4MGJkMzc4ODRmNDA5YTk1NGY0OGExNGZjZTcy">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM20.jpg?versionId=CAEQKRiBgID_u577.hciIDEyMDJmYTU4NTBmOTQ4MWQ4OGVkYmFiYWE0M2YwNWE1">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM21.jpg?versionId=CAEQKRiBgMD4u577.hciIDg4ZTJkNjMxM2FhOTQ0YWZiZTdmZTczYTI4ZGVjY2Jm">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM22.jpg?versionId=CAEQKRiBgIDxu577.hciIGM1NmE3NTgzY2IzOTRkMDU4ZjVkMGQ5MTlhYjdjNDAz">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM23.jpg?versionId=CAEQKRiBgIDru577.hciIDhhNjU1OTc2OWE0MjQxZTU5MTY5YjU0YWE0MTA3YjI0">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM24.jpg?versionId=CAEQKRiBgMDlu577.hciIDZlM2IzZGVhZmRkNjRiN2Y4MzE4ZWFmNzI1OGM4YmYx">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM25.jpg?versionId=CAEQKRiBgICcup77.hciIDkyMTAwNjZhZDRmYTQ1NTlhNDE2OGIyNzI5NWE2NDc1">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM26.jpg?versionId=CAEQKRiBgMCaup77.hciIDRlNzE1MzNhYzUwZjQyN2RiNjRjNmJhNTJmNGNlYmVj">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM27.jpg?versionId=CAEQKRiBgICYup77.hciIDcwMGVhNzRhYmQzNjRiMGJiYWYwM2QyYTc1N2U0NGEy">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM28.jpg?versionId=CAEQKRiBgMCWup77.hciIGMxMGJkMjRlYTBmMTQ3NmRiOGMyNmMzOTM1ZmE3ZDlh">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM29.jpg?versionId=CAEQKRiBgID1uZ77.hciIDQ5MzY1MDhlZGM4YTRjNWU5ODIxYmUxM2I0YjBiZTJl">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM30.jpg?versionId=CAEQKRiBgIDzuZ77.hciIDJkMmVjOTI2Y2FhMzRjMGY4YTdhNzYwMDFhMDA5ODRj">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM31.jpg?versionId=CAEQKRiBgIDyuZ77.hciIGRjZDEzOGFiZWIzOTQxZWE4YjU5ZmExYjE2Y2Y4NmY0">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM32.jpg?versionId=CAEQKRiBgMDvuZ77.hciIDNkNzAyNDhhMjU3OTQ5ZDc5MmMxNTkyYzcwNzE1NDE2">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM33.jpg?versionId=CAEQKRiBgMDxuZ77.hciIGRkODliYzZlNDIyNTQ0YmQ4MWY2MWY4MjQ0OGQ2YWRh">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM34.jpg?versionId=CAEQKRiBgIDpuZ77.hciIGMzODM1ODAzZDA1NzQxZDk4YTczNjVlY2E3YjM0MDY2">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM35.jpg?versionId=CAEQKRiBgMCwuJ77.hciIDNjNWM2MmQyMjEwZTQ2OWQ4MDZmOGMwNzg0YWM5OTM2">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM36.jpg?versionId=CAEQKRiBgMCxuJ77.hciIDRlOTQwNGU1YzYyMDRjOTU4NDg0YWI0ZjI5NmI1ODk2">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM37.jpg?versionId=CAEQKRiBgMCouJ77.hciIDQzYTU0ZjRhY2VhNzRiMGRhYTdlNGJkYWI2NDcyMWIx">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM38.jpg?versionId=CAEQKRiBgICmuJ77.hciIDE3ZjM3YWJlMWY1NzRlNGFiYzc4Y2RiZGJhNGZhZDJk">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM39.jpg?versionId=CAEQKRiBgMCKuJ77.hciIDM3ZjM5YzU3NTQ3YzRlYzA4NzA4MDQ0YmRhZTNhMTI4">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM40.jpg?versionId=CAEQKRiBgICSuJ77.hciIDM4MGQyZTM5NzQwZjQzMDk5MzNkN2ZhNjJkMzI3ZjBj">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM41.jpg?versionId=CAEQKRiBgICIuJ77.hciIDIyMzdjYTY2Zjc0YzQzMGM4MmI4ZjczZTIxZjNjOGUx">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM42.jpg?versionId=CAEQKRiBgMCEuJ77.hciIDk2NzczNTg3YmJlZjQ5YTc4ZTM5ZWNmYmNiMzYxYzUz">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM43.jpg?versionId=CAEQKRiBgICBuJ77.hciIDI3ZWU5ODU3YmJhMTQxOTc5M2RhNDFhYzkwYmEyOTgx">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM44.jpg?versionId=CAEQKRiBgMDmtp77.hciIGEzYzEwYzgwOWUzZDQ0M2JiYTk5MTAzNjc1ZjU2YWY0">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM45.jpg?versionId=CAEQKRiBgMDptp77.hciIDk1YjAzMjFkYTAwZjQ0NjRhNTEzYTRiNWY3ZmRjNTMz">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM46.jpg?versionId=CAEQKRiBgIDatp77.hciIGUxZjVhNTVjMzMyODRkOTU5MTZiM2ViNjk4YzUxM2Ji">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM47.jpg?versionId=CAEQKRiBgIDltp77.hciIDJhYTZkNjA1MDFkYjQ4MGE5MTY2NTBmOGU4MjAwMWU2">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM48.jpg?versionId=CAEQKRiCgICetp77.hciIGE1ODBlZDBkOGE3NTQ5YWRhYmFkZjRmZGEzNWUxYmI4">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM49.jpg?versionId=CAEQKRiBgICGtp77.hciIDdhMTJmMmZkMDZkYjRiYjVhNTg1NjZjMGIxODk2ODcz">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM50.jpg?versionId=CAEQKRiBgICetp77.hciIGYxOTYwMmUyYzM4MjRiZGJiODgwZjA5MmYwMDM4NjI2">
<meta property="og:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM51.jpg?versionId=CAEQKRiBgMCqtZ77.hciIGYyZGI1ODYwM2VjMjQ2OTBhZjI5NDBlMzBiMTEzOGU5">
<meta property="article:published_time" content="2022-03-06T11:34:21.000Z">
<meta property="article:modified_time" content="2022-03-06T11:35:41.070Z">
<meta property="article:author" content="Blue~u~u~u">
<meta property="article:tag" content="jvm">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM01.jpg?versionId=CAEQKRiBgMDHwJ77.hciIDVjYTEwZDJmMjM0MTQ2YTM4NDljZjgxMzk4MGM3YjI4">
  
  <title>JVM学习笔记整理 - Blue~u~u~u~u</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"www.slx.blue","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":180,"cursorChar":"_","loop":true},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/>
<script src="/live2d-widget/autoload.js"></script>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blue~u~u</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/images/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JVM学习笔记整理">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-06 19:34" pubdate>
        2022年3月6日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      28k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      88 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JVM学习笔记整理</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：13 天前
                
              </p>
            
            <div class="markdown-body">
              <h1 id="JVM学习笔记"><a href="#JVM学习笔记" class="headerlink" title="JVM学习笔记"></a>JVM学习笔记</h1><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="第一节-JDK、JRE、JVM关系回顾"><a href="#第一节-JDK、JRE、JVM关系回顾" class="headerlink" title="第一节 JDK、JRE、JVM关系回顾"></a>第一节 JDK、JRE、JVM关系回顾</h2><ul>
<li>JVM：Java Virtual Machine，翻译过来是Java虚拟机<ul>
<li>JRE：Java Runtime Environment，翻译过来是Java运行时环境</li>
<li>JRE=JVM+Java程序运行时所需要的类库</li>
</ul>
</li>
<li>JDK：Java Development Kits，翻译过来是Java开发工具包<ul>
<li>JDK=JRE+Java开发辅助工具</li>
</ul>
</li>
</ul>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM01.jpg?versionId=CAEQKRiBgMDHwJ77.hciIDVjYTEwZDJmMjM0MTQ2YTM4NDljZjgxMzk4MGM3YjI4" srcset="/img/loading.gif" lazyload alt="images"></p>
<h2 id="第二节-JVM工作的总体机制"><a href="#第二节-JVM工作的总体机制" class="headerlink" title="第二节 JVM工作的总体机制"></a>第二节 JVM工作的总体机制</h2><h3 id="1、Java源程序编译运行过程"><a href="#1、Java源程序编译运行过程" class="headerlink" title="1、Java源程序编译运行过程"></a>1、Java源程序编译运行过程</h3><p>Java源程序→编译→字节码文件→放到JVM上运行</p>
<h3 id="2、JVM工作的总体机制"><a href="#2、JVM工作的总体机制" class="headerlink" title="2、JVM工作的总体机制"></a>2、JVM工作的总体机制</h3><p>总体机制的粗略描述：</p>
<ul>
<li>第一步：使用类加载器子系统将 *.class 字节码文件加载到 JVM 的内存</li>
<li>第二步：在 JVM 的内存空间存储相关数据</li>
<li>第三步：在执行引擎中将 *.class 字节码文件翻译成 CPU 能够执行的指令</li>
<li>第四步：将指令发送给CPU执行</li>
</ul>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM02.png?versionId=CAEQKRiBgIDJwJ77.hciIDg0YmZmZjZlNmMzYjQ2MzJiNmIxNzRhMTNjZDFmMTYz" srcset="/img/loading.gif" lazyload alt="images"></p>
<h3 id="3、JVM落地产品"><a href="#3、JVM落地产品" class="headerlink" title="3、JVM落地产品"></a>3、JVM落地产品</h3><ul>
<li>Sun公司的HotSpot</li>
<li>BEA公司的JRockit</li>
<li>IBM公司的J9 VM</li>
</ul>
<h1 id="第二章-类加载机制-重要"><a href="#第二章-类加载机制-重要" class="headerlink" title="第二章 类加载机制[重要]"></a>第二章 类加载机制[重要]</h1><h2 id="第一节-类加载器分类"><a href="#第一节-类加载器分类" class="headerlink" title="第一节 类加载器分类"></a>第一节 类加载器分类</h2><h3 id="1、类加载器"><a href="#1、类加载器" class="headerlink" title="1、类加载器"></a>1、类加载器</h3><p>类加载器（英文：ClassLoader）负责加载 <em>.class 字节码文件，</em>.class 字节码文件在文件开头有特定的文件标识。ClassLoader 只负责 *.class 字节码文件的加载，至于它是否可以运行，则由 Execution Engine 决定。</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM03.png?versionId=CAEQKRiBgICdwJ77.hciIDgwOTM5ZGQyZDYwYjQwYTY5ZTFjOTM3MDVkMzIyODI2" srcset="/img/loading.gif" lazyload alt="images"></p>
<h3 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h3><p>JVM 中类加载器分为四种：前三种为虚拟机自带的加载器。</p>
<table>
<thead>
<tr>
<th>中文名称</th>
<th>英文名称</th>
<th align="left">说明</th>
<th>加载范围</th>
</tr>
</thead>
<tbody><tr>
<td>启动类加载器</td>
<td>Bootstrap</td>
<td align="left">C++ 语言编写，不是 ClassLoader 子类，Java 中为 null</td>
<td>$JAVA_HOME/jre/lib/rt.jar</td>
</tr>
<tr>
<td>扩展类加载器</td>
<td>Extension</td>
<td align="left">sun.misc.Launcher.ExtClassLoader</td>
<td>JAVA_HOME/jre/lib/*.jar      <br> -Djava.ext.dirs 参数指定目录下的 jar 包 JAVA_HOME/jre/lib/ext/classes 目录下的 class</td>
</tr>
<tr>
<td>应用类加载器</td>
<td>AppClassLoader</td>
<td align="left">sun.misc.Launcher.AppClassLoader</td>
<td>classpath中指定的 jar 包及目录中的 class</td>
</tr>
<tr>
<td>自定义类加载器</td>
<td></td>
<td align="left">程序员自己开发一个类继承 java.lang.ClassLoader，<br>定制类加载方式</td>
<td></td>
</tr>
</tbody></table>
<h3 id="3、父子关系"><a href="#3、父子关系" class="headerlink" title="3、父子关系"></a>3、父子关系</h3><ul>
<li>父子关系1：启动类加载器是扩展类加载器的父加载器</li>
<li>父子关系2：扩展类加载器是应用类加载器的父加载器</li>
</ul>
<h3 id="4、通过代码查看类加载器"><a href="#4、通过代码查看类加载器" class="headerlink" title="4、通过代码查看类加载器"></a>4、通过代码查看类加载器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.获取Person类的Class对象</span><br><span class="hljs-comment">// 2.通过Class对象进一步获取它的类加载器对象</span><br>ClassLoader appClassLoader = Person.class.getClassLoader();<br><br><span class="hljs-comment">// 3.获取appClassLoader的全类名</span><br>String appClassLoaderName = appClassLoader.getClass().getName();<br><br><span class="hljs-comment">// 4.打印appClassLoader的全类名</span><br><span class="hljs-comment">// sun.misc.Launcher$AppClassLoader</span><br>System.out.println(<span class="hljs-string">&quot;appClassLoaderName = &quot;</span> + appClassLoaderName);<br><br><span class="hljs-comment">// 5.通过appClassLoader获取扩展类加载器（父加载器）</span><br>ClassLoader extClassLoader = appClassLoader.getParent();<br><br><span class="hljs-comment">// 6.获取extClassLoader的全类名</span><br>String extClassLoaderName = extClassLoader.getClass().getName();<br><br><span class="hljs-comment">// 7.打印extClassLoader的全类名</span><br><span class="hljs-comment">// sun.misc.Launcher$ExtClassLoader</span><br>System.out.println(<span class="hljs-string">&quot;extClassLoaderName = &quot;</span> + extClassLoaderName);<br><br><span class="hljs-comment">// 8.通过extClassLoader获取启动类加载器（父加载器）</span><br>ClassLoader bootClassLoader = extClassLoader.getParent();<br><br><span class="hljs-comment">// 9.由于启动类加载器是C语言开发的，在Java代码中无法实例化对象，所以只能返回null值</span><br>System.out.println(<span class="hljs-string">&quot;bootClassLoader = &quot;</span> + bootClassLoader);<br></code></pre></td></tr></table></figure>

<h2 id="第二节-双亲委派机制"><a href="#第二节-双亲委派机制" class="headerlink" title="第二节 双亲委派机制"></a>第二节 双亲委派机制</h2><p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM04.jpg?versionId=CAEQKRiBgMCswJ77.hciIDNmMjllNGU5MWU4NjQxYzNhNzQyYTViNmQ0ZTJjN2U3" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>当我们需要加载任何一个范围内的类时，首先找到这个范围对应的类加载器</li>
<li>但是当前这个类加载器不是马上开始查找</li>
<li>当前类加载器会将任务交给上一级类加载器</li>
<li>上一级类加载器继续上交任务，一直到最顶级的启动类加载器</li>
<li>启动类加载器开始在自己负责的范围内查找</li>
<li>如果能找到，则直接开始加载</li>
<li>如果找不到，则交给下一级的类加载器继续查找</li>
<li>一直到应用程序类加载器</li>
<li>如果应用程序类加载器同样找不到要加载的类，那么会抛出ClassNotFoundException</li>
</ul>
<h2 id="第三节-验证双亲委派机制"><a href="#第三节-验证双亲委派机制" class="headerlink" title="第三节 验证双亲委派机制"></a>第三节 验证双亲委派机制</h2><h3 id="1、实验1"><a href="#1、实验1" class="headerlink" title="1、实验1"></a>1、实验1</h3><ul>
<li>第一步：在与JDK无关的目录下创建Hello.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;AAA&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>第二步：编译Hello.java</li>
<li>第三步：将Hello.class文件移动到$JAVA_HOME/jre/classes目录下</li>
<li>第四步：修改Hello.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;BBB&quot;</span>);<br>	&#125;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>第五步：编译Hello.java</li>
<li>第六步：将Hello.class文件移动到$JAVA_HOME/jre/lib/ext/classes目录下</li>
<li>第七步：修改Hello.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;CCC&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>第八步：编译Hello.java</li>
<li>第九步：使用java命令运行Hello类，发现打印结果是：AAA<ul>
<li>说明Hello这个类是被启动类加载器找到的，找到以后就不查找其他位置了</li>
</ul>
</li>
<li>第十步：删除$JAVA_HOME/jre/classes目录</li>
<li>第十一步：使用java命令运行Hello类，发现打印结果是：BBB<ul>
<li>说明Hello这个类是被扩展类加载器找到的，找到以后就不查找其他位置了</li>
</ul>
</li>
<li>第十二步：删除$JAVA_HOME/jre/lib/ext/classes目录</li>
<li>第十三步：使用java命令运行Hello类，发现打印结果是：CCC<ul>
<li>说明Hello这个类是被应用程序类加载器找到的</li>
</ul>
</li>
</ul>
<h3 id="2、实验2"><a href="#2、实验2" class="headerlink" title="2、实验2"></a>2、实验2</h3><ul>
<li>第一步：创建假的String类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;嘿嘿，其实我是假的！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>第二步：编写测试程序类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLoadString</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 目标：测试不同范围内全类名相同的两个类JVM如何加装</span><br>    <span class="hljs-comment">// 1.创建String对象</span><br>    java.lang.String testInstance = <span class="hljs-keyword">new</span> java.lang.String();<br><br>    <span class="hljs-comment">// 2.获取String对象的类加载器</span><br>    ClassLoader classLoader = testInstance.getClass().getClassLoader();<br>    System.out.println(classLoader);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>第三步：查看运行结果是null<ul>
<li>假的String类并没有被创建对象，由于双亲委派机制，启动类加载器加载了真正的String类</li>
</ul>
</li>
</ul>
<h2 id="第四节-双亲委派机制的好处"><a href="#第四节-双亲委派机制的好处" class="headerlink" title="第四节 双亲委派机制的好处"></a>第四节 双亲委派机制的好处</h2><ul>
<li>避免类的重复加载：父加载器加载了一个类，就不必让子加载器再去查找了。同时也保证了在整个 JVM 范围内全类名是类的唯一标识。</li>
<li>安全机制：避免恶意替换 JRE 定义的核心 API</li>
</ul>
<h2 id="第五节-双亲委派机制的弊端"><a href="#第五节-双亲委派机制的弊端" class="headerlink" title="第五节 双亲委派机制的弊端"></a>第五节 双亲委派机制的弊端</h2><ul>
<li>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个 问题，即顶层的ClassLoader无法访 问底层的ClassLoader所加载的类。</li>
<li>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。<strong>比如</strong>在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>由于Java虚拟机规范并没有明确要求类加载器的加载制一定要使用双亲委派模型，只是建议采用这种方式而已。</li>
<li>比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到-个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。</li>
</ul>
<h1 id="第三章-总体机制中不重要的部分"><a href="#第三章-总体机制中不重要的部分" class="headerlink" title="第三章 总体机制中不重要的部分"></a>第三章 总体机制中不重要的部分</h1><h2 id="1、本地接口-Native-Interface"><a href="#1、本地接口-Native-Interface" class="headerlink" title="1、本地接口 Native Interface"></a>1、本地接口 Native Interface</h2><p>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序。因为 Java 诞生的时候是 C/C++ 横行的时候，要想立足，必须有能力调用 C/C++。于是就在内存中专门开辟了一块区域处理标记为 native 的代码，它的具体做法是 Native Method Stack 中登记 native 方法，在Execution Engine 执行时加载 native libraies。</p>
<p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过 Java 程序驱动打印机或者 Java 系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket 通信，也可以使用 Web Service 等等，不多做介绍。</p>
<h2 id="2、本地方法栈-Native-Method-Stack"><a href="#2、本地方法栈-Native-Method-Stack" class="headerlink" title="2、本地方法栈 Native Method Stack"></a>2、本地方法栈 Native Method Stack</h2><p>专门负责在本地方法运行时，提供栈空间，存放本地方法每一次执行时创建的栈帧。它的具体做法是在 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。</p>
<p>native 方法举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">yield</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>

<h2 id="2、程序计数器"><a href="#2、程序计数器" class="headerlink" title="2、程序计数器"></a>2、程序计数器</h2><p>也叫PC寄存器（<strong>P</strong>rogram <strong>C</strong>ounter Register）。用于保存程序执行过程中，下一条即将执行的指令的地址。也就是说能够保存程序当前已经执行到的位置。这个位置由执行引擎读取下一条指令，是一个非常小的内存空间，从内存空间使用优化这个角度来看：几乎可以忽略不记。</p>
<h2 id="3、执行引擎-Execution-Engine"><a href="#3、执行引擎-Execution-Engine" class="headerlink" title="3、执行引擎 Execution Engine"></a>3、执行引擎 Execution Engine</h2><p>作用：用于执行字节码文件中的指令。</p>
<p>执行指令的具体技术：</p>
<ul>
<li>解释执行：第一代JVM。</li>
<li>即时编译：JIT，第二代JVM。</li>
<li>自适应优化：目前Sun的Hotspot JVM采用这种技术。吸取了第一代JVM和第二代JVM的经验，在一开始的时候对代码进行解释执行， 同时使用一个后台线程监控代码的执行。如果一段代码经常被调用，那么就对这段代码进行编译，编译为本地代码，并进行执行优化。若方法不再频繁使用，则取消编译过的代码，仍对其进行解释执行。</li>
<li>芯片级直接执行：内嵌在芯片上，用本地方法执行Java字节码。</li>
</ul>
<h2 id="4、直接内存"><a href="#4、直接内存" class="headerlink" title="4、直接内存"></a>4、直接内存</h2><p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM05.jpg?versionId=CAEQKRiBgMC7vp77.hciIDI2ZTJjZGMzNjJiNDRjYTQ5YzY0YjI3OWJiNDUzYTFh" srcset="/img/loading.gif" lazyload alt="images"></p>
<h3 id="①作用"><a href="#①作用" class="headerlink" title="①作用"></a>①作用</h3><p>提高特定场景下性能。</p>
<h3 id="②应用场景"><a href="#②应用场景" class="headerlink" title="②应用场景"></a>②应用场景</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 本机直接内存的分配不会受到 Java 堆大小的限制，受到本机总内存大小限制。 配置虚拟机参数时，不要忽略直接内存防止出现 OutOfMemoryError 异常。</p>
<h3 id="③直接内存（堆外内存）与堆内存比较"><a href="#③直接内存（堆外内存）与堆内存比较" class="headerlink" title="③直接内存（堆外内存）与堆内存比较"></a>③直接内存（堆外内存）与堆内存比较</h3><p>直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显。直接内存 I/O 读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显。</p>
<h1 id="第四章-方法区"><a href="#第四章-方法区" class="headerlink" title="第四章 方法区"></a>第四章 方法区</h1><h2 id="1、不同版本具体实现"><a href="#1、不同版本具体实现" class="headerlink" title="1、不同版本具体实现"></a>1、不同版本具体实现</h2><ul>
<li>标准层面：方法区（Method Area）</li>
<li>具体实现层面：<ul>
<li>≤1.6 永久代</li>
<li>=1.7 永久代仍然存在，但是已经开始提出：去永久代</li>
<li>≥1.8元空间（Meta Space）</li>
</ul>
</li>
</ul>
<p>TIP</p>
<p><strong>永久代</strong>概念辨析：</p>
<ul>
<li>从堆空间角度来说<ul>
<li>新生代：从标准和实现层面都确定属于堆</li>
<li>老年代：从标准和实现层面都确定属于堆</li>
<li>永久代<ul>
<li>名义上属于堆</li>
<li>实现上不属于堆</li>
</ul>
</li>
</ul>
</li>
<li>从方法区角度来说<ul>
<li>方法区的具体实现：JDK 版本 ≤ 1.7 时，使用永久代作为方法区。</li>
<li>方法区的具体实现：JDK 版本 ≥ 1.8 时，使用元空间作为方法区。</li>
</ul>
</li>
</ul>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM06.jpg?versionId=CAEQKRiBgIDfvp77.hciIDMzZTk4NjM0YTMxNTRlYmY5M2ZhMThkNWY2N2I2YmMy" srcset="/img/loading.gif" lazyload alt="images"></p>
<h2 id="2、元"><a href="#2、元" class="headerlink" title="2、元"></a>2、元</h2><p>本身含义：万物初始，一件事情的源头或基本组成部分。</p>
<p>举例：元素、元始天尊、每年1月称为元月、1月1日称为元旦、元认知、元无知、元知识</p>
<p>对比类和对象，类相当于是对象的元信息。</p>
<h2 id="3、元空间存储数据说明"><a href="#3、元空间存储数据说明" class="headerlink" title="3、元空间存储数据说明"></a>3、元空间存储数据说明</h2><ul>
<li>类信息：类中定义的构造器、接口定义</li>
<li>静态变量（类变量）</li>
<li>常量</li>
<li>运行时常量池</li>
<li>类中方法的代码</li>
</ul>
<h1 id="第五章-Java栈-重要"><a href="#第五章-Java栈-重要" class="headerlink" title="第五章 Java栈 [重要]"></a>第五章 Java栈 [重要]</h1><h2 id="第一节-方法栈"><a href="#第一节-方法栈" class="headerlink" title="第一节 方法栈"></a>第一节 方法栈</h2><p>方法栈并不是某一个 JVM 的内存空间，而是我们描述方法被调用过程的一个逻辑概念。</p>
<p>在同一个线程内，method01()调用method02()：</p>
<ul>
<li>method01()先开始，method02()后开始；</li>
<li>method02()先结束，method01()后结束。</li>
</ul>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM07.jpg?versionId=CAEQKRiBgMC.vp77.hciIDU2ZTRiNmI1ZWUzZjRmMzFhYjg5MTkzZmFhMDA1ZDFm" srcset="/img/loading.gif" lazyload alt="images"></p>
<p>TIP</p>
<p>『栈』和『堆』这两个字辨析：</p>
<p>1、从英文单词角度来说</p>
<ul>
<li>栈：stack</li>
<li>堆：heap</li>
</ul>
<p>2、从数据结构角度来说</p>
<ul>
<li>栈和堆一样：都是先进后出，后进先出的数据结构</li>
</ul>
<p>3、从 JVM 内存空间结构角度来说</p>
<ul>
<li>栈：通常指 Java 方法栈，存放方法每一次执行时生成的栈帧。</li>
<li>堆：JVM 中存放对象的内存空间。包括新生代、老年代、永久代等组成部分。</li>
</ul>
<h2 id="第二节-栈帧"><a href="#第二节-栈帧" class="headerlink" title="第二节 栈帧"></a>第二节 栈帧</h2><h3 id="1、栈帧存储的数据"><a href="#1、栈帧存储的数据" class="headerlink" title="1、栈帧存储的数据"></a>1、栈帧存储的数据</h3><p>方法在本次执行过程中所用到的局部变量、动态链接、方法出口等信息。栈帧中主要保存3 类数据：</p>
<ul>
<li>本地变量（Local Variables）：输入参数和输出参数以及方法内的变量。</li>
<li>栈操作（Operand Stack）：记录出栈、入栈的操作。</li>
<li>栈帧数据（Frame Data）：包括类文件、方法等等。</li>
</ul>
<h3 id="2、栈帧的结构"><a href="#2、栈帧的结构" class="headerlink" title="2、栈帧的结构"></a>2、栈帧的结构</h3><ul>
<li>局部变量表：方法执行时的参数、方法体内声明的局部变量</li>
<li>操作数栈：存储中间运算结果，是一个临时存储空间</li>
<li>帧数据区：保存访问常量池指针，异常处理表</li>
</ul>
<h3 id="3、栈帧工作机制"><a href="#3、栈帧工作机制" class="headerlink" title="3、栈帧工作机制"></a>3、栈帧工作机制</h3><p>当一个方法 A 被调用时就产生了一个栈帧 F1，并被压入到栈中，</p>
<p>A 方法又调用了 B 方法，于是产生栈帧 F2 也被压入栈，</p>
<p>B 方法又调用了 C 方法，于是产生栈帧 F3 也被压入栈，</p>
<p>……</p>
<p>C 方法执行完毕后，弹出 F3 栈帧；</p>
<p>B 方法执行完毕后，弹出 F2 栈帧；</p>
<p>A 方法执行完毕后，弹出 F1栈帧；</p>
<p>……</p>
<p>遵循“先进后出”或者“后进先出”原则。</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM08.jpg?versionId=CAEQKRiBgMCcvp77.hciIDdkNGYzYTJmY2I2YjQwNTM4Zjk2MDkxYTUzZmRmNTlk" srcset="/img/loading.gif" lazyload alt="images"></p>
<p>图示在一个栈中有两个栈帧：</p>
<p>栈帧 2 是最先被调用的方法，先入栈，</p>
<p>然后方法 2 又调用了方法 1，栈帧 1 处于栈顶的位置，</p>
<p>栈帧 2 处于栈底，执行完毕后，依次弹出栈帧 1 和栈帧 2，</p>
<p>线程结束，栈释放。</p>
<p>每执行一个方法都会产生一个栈帧，保存到栈的<strong>顶部</strong>，顶部栈就是<strong>当前方法</strong>，该方法执行完毕后会自动将此栈帧出栈。</p>
<h3 id="4、典型案例"><a href="#4、典型案例" class="headerlink" title="4、典型案例"></a>4、典型案例</h3><p>请预测下面代码打印的结果：34</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = <span class="hljs-number">10</span>;<br>n += (n++) + (++n);<br>System.out.println(n);<br></code></pre></td></tr></table></figure>

<p>实际执行结果：32</p>
<p>使用 javap 命令查看字节码文件内容：</p>
<blockquote>
<p>D:\record-video-original\day03\code&gt;<strong>javap -c Demo03JavaStackExample.class</strong><br>Compiled from “Demo03JavaStackExample.java”<br>public class Demo03JavaStackExample{<br>public Demo03JavaStackExample();<br>Code:<br>0: aload_0<br>1: invokespecial #1 // Method java/lang/Object.”<init>: ()V<br>4: return</init></p>
<p>public static void main(java.lang.String[]);<br>Code:<br>0: bipush 10<br>2: istore_1<br>3: iload_1<br>4: iload_1<br>5: iinc 1, 1<br>8: iinc 1, 1<br>11: iload_1<br>12: iadd<br>13: iadd<br>14: istore_1<br>15: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream;<br>18: iload_1<br>19: invokevirtual #3 // Method java/io/PrintStream.println:(I)V<br>22: return<br>}</p>
</blockquote>
<p>内存执行过程分析：</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM09.png?versionId=CAEQKRiBgID7vp77.hciIDJmNWE1M2Q4MzYzYTQxYjM5OGM4M2VkNjdjM2MzZjZl" srcset="/img/loading.gif" lazyload alt="images"></p>
<h2 id="第三节-栈溢出异常"><a href="#第三节-栈溢出异常" class="headerlink" title="第三节 栈溢出异常"></a>第三节 栈溢出异常</h2><h3 id="1、异常名称"><a href="#1、异常名称" class="headerlink" title="1、异常名称"></a>1、异常名称</h3><p>java.lang.StackOverflowError</p>
<h3 id="2、异常产生的原因"><a href="#2、异常产生的原因" class="headerlink" title="2、异常产生的原因"></a>2、异常产生的原因</h3><p>下面的例子是一个没有退出机制的递归：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackOverFlowTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        methodInvokeToDie();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodInvokeToDie</span><span class="hljs-params">()</span> </span>&#123;<br>        methodInvokeToDie();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>抛出的异常信息：</p>
<blockquote>
<p>Exception in thread “main” java.lang.StackOverflowError at com.atguigu.jvm.test.StackOverFlowTest.methodInvokeToDie(StackOverFlowTest.java:10) at com.atguigu.jvm.test.StackOverFlowTest.methodInvokeToDie(StackOverFlowTest.java:10) at com.atguigu.jvm.test.StackOverFlowTest.methodInvokeToDie(StackOverFlowTest.java:10) at com.atguigu.jvm.test.StackOverFlowTest.methodInvokeToDie(StackOverFlowTest.java:10) at com.atguigu.jvm.test.StackOverFlowTest.methodInvokeToDie(StackOverFlowTest.java:10)</p>
</blockquote>
<p>原因总结：方法每一次调用都会在栈空间中申请一个栈帧，来保存本次方法执行时所需要用到的数据。但是一个没有退出机制的递归调用，会不断申请新的空间，而又不释放空间，这样迟早会把当前线程在栈内存中自己的空间耗尽。</p>
<h2 id="第四节-栈空间的线程私有验证"><a href="#第四节-栈空间的线程私有验证" class="headerlink" title="第四节 栈空间的线程私有验证"></a>第四节 栈空间的线程私有验证</h2><h3 id="1、提出问题"><a href="#1、提出问题" class="headerlink" title="1、提出问题"></a>1、提出问题</h3><p>某一个线程抛出『栈溢出异常』，会导致其他线程也崩溃吗？从以往的经验中我们判断应该是不会，下面通过代码来实际验证一下。</p>
<h3 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; working&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;thread-01&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br><br>            <span class="hljs-comment">// 递归调用一个没有退出机制的递归方法</span><br>            methodInvokeToDie();<br><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; working&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;thread-02&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; working&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;thread-03&quot;</span>).start();<br></code></pre></td></tr></table></figure>



<h3 id="3、结论"><a href="#3、结论" class="headerlink" title="3、结论"></a>3、结论</h3><p>02 线程抛异常终止后，01 和 03 线程仍然能够继续正常运行，说明 02 抛异常并没有影响到 01 和 03，说明线程对栈内存空间的使用方式是彼此隔离的。每个线程都是在自己独享的空间内运行，反过来也可以说，这个空间是当前线程私有的。</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM10.jpg?versionId=CAEQKRiBgMDwvZ77.hciIDEzODVjZmUzYmQ0YzQzZmRhMTRlYjhmYzFiYzkyYWU5" srcset="/img/loading.gif" lazyload alt="images"></p>
<h1 id="第六章-堆-重要"><a href="#第六章-堆-重要" class="headerlink" title="第六章 堆 [重要]"></a>第六章 堆 [重要]</h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a>第一节 概述</h2><h3 id="1、堆空间组成部分"><a href="#1、堆空间组成部分" class="headerlink" title="1、堆空间组成部分"></a>1、堆空间组成部分</h3><p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM11.jpg?versionId=CAEQKRiBgMDuvZ77.hciIDYxNDdkYzY2NDA4ZDRmNDhhNjRmMTE1NGM2NzNlMDM2" srcset="/img/loading.gif" lazyload alt="images"></p>
<h3 id="2、堆空间工作机制"><a href="#2、堆空间工作机制" class="headerlink" title="2、堆空间工作机制"></a>2、堆空间工作机制</h3><ul>
<li>新创建的对象会被放在Eden区</li>
<li>当Eden区中已使用的空间达到一定比例，会触发Minor GC</li>
<li>每一次在Minor GC中没有被清理掉的对象就成了幸存者</li>
<li>幸存者对象会被转移到幸存者区</li>
<li>幸存者区分成from区和to区</li>
<li>from区快满的时候，会将仍然在使用的对象转移到to区</li>
<li>然后from和to这两个指针彼此交换位置</li>
</ul>
<blockquote>
<p>口诀：<strong>复制必交换，谁空谁为to</strong></p>
</blockquote>
<ul>
<li>如果一个对象，经历15次GC仍然幸存，那么它将会被转移到老年代</li>
<li>如果幸存者区已经满了，即使某个对象尚不到15岁，仍然会被移动到老年代</li>
<li>最终效果：<ul>
<li>Eden区主要是生命周期很短的对象来来往往</li>
<li>老年代主要是生命周期很长的对象，例如：IOC容器对象、线程池对象、数据库连接池对象等等</li>
<li>幸存者区作为二者之间的过渡地带</li>
</ul>
</li>
<li>关于永久代：<ul>
<li>从理论上来说属于堆</li>
<li>从具体实现上来说不属于堆</li>
</ul>
</li>
</ul>
<h3 id="3、永久代在各个JDK版本之间的演变"><a href="#3、永久代在各个JDK版本之间的演变" class="headerlink" title="3、永久代在各个JDK版本之间的演变"></a>3、永久代在各个JDK版本之间的演变</h3><table>
<thead>
<tr>
<th></th>
<th>永久代</th>
<th>常量池</th>
</tr>
</thead>
<tbody><tr>
<td>≤JDK1.6</td>
<td>有</td>
<td>在方法区</td>
</tr>
<tr>
<td>=JDK1.7</td>
<td>有，但开始逐步“去永久代”</td>
<td>在堆</td>
</tr>
<tr>
<td>≥JDK1.8</td>
<td>无</td>
<td>在元空间</td>
</tr>
</tbody></table>
<h3 id="4、方法区、元空间、永久代之间关系"><a href="#4、方法区、元空间、永久代之间关系" class="headerlink" title="4、方法区、元空间、永久代之间关系"></a>4、方法区、元空间、永久代之间关系</h3><p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM12.jpg?versionId=CAEQKRiBgMDovZ77.hciIDk0ZWY4Yjg3NmFkYTRmMmJhZDM2OTUwYzA4NzYxOTJh" srcset="/img/loading.gif" lazyload alt="images"></p>
<h3 id="5、堆、栈、方法区之间关系"><a href="#5、堆、栈、方法区之间关系" class="headerlink" title="5、堆、栈、方法区之间关系"></a>5、堆、栈、方法区之间关系</h3><p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM13.jpg?versionId=CAEQKRiBgMDnvZ77.hciIGZkN2Y1OGY5NGFkMDRkYTE5YWQxOWM3M2EzMDEzOTQx" srcset="/img/loading.gif" lazyload alt="images"></p>
<h2 id="第二节-实验"><a href="#第二节-实验" class="headerlink" title="第二节 实验"></a>第二节 实验</h2><p>Java代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>    list.add(<span class="hljs-keyword">new</span> Object());<br>&#125;<br></code></pre></td></tr></table></figure>



<p>附加 JVM 运行参数：</p>
<ul>
<li>新创建参数设置：</li>
</ul>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM14.jpg?versionId=CAEQKRiBgMDhvZ77.hciIGIzYjc1MjRjZGQ5NjRhNTU5Mzc1NTk3Y2EyNjRhMGU4" srcset="/img/loading.gif" lazyload alt="images"></p>
<ul>
<li>修改参数设置：</li>
</ul>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM15.jpg?versionId=CAEQKRiBgMCcvJ77.hciIDlhOTRkMmVlN2ZhMDQ2NWY4MmE1YTBjZDI5YWUxMWYy" srcset="/img/loading.gif" lazyload alt="images"></p>
<ul>
<li>设置参数：</li>
</ul>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM16.jpg?versionId=CAEQKRiBgMCavJ77.hciIDEwMWViOTQzODE3NzQ3YWFiNTk2ODE4ODQwMDY2NmMw" srcset="/img/loading.gif" lazyload alt="images"></p>
<ul>
<li>运行程序的操作还是和以前一样：</li>
</ul>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM17.jpg?versionId=CAEQKRiBgMCNvJ77.hciIDg5OGViNmNiYjgyNDQyMTFiNTljMTNhMzViYjRhNzNm" srcset="/img/loading.gif" lazyload alt="images"></p>
<h2 id="2、Runtime类使用案例"><a href="#2、Runtime类使用案例" class="headerlink" title="2、Runtime类使用案例"></a>2、Runtime类使用案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java">System.out.print(<span class="hljs-string">&quot;最大堆大小：&quot;</span>);<br>System.out.println(Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br>System.out.print(<span class="hljs-string">&quot;当前堆大小：&quot;</span>);<br>System.out.println(Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;==================================================&quot;</span>);<br><br><span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行前配置参数：-Xmx50m -Xms30m -XX:+PrintGCDetails</p>
<p>执行看到如下信息：</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM52.jpg?versionId=CAEQKRiBgID.tp77.hciIGM4NDllOGIyYmNlNzQ5ZjVhOGVkYmQ2ZTI4OGJlNTUw" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="3、GC演示"><a href="#3、GC演示" class="headerlink" title="3、GC演示"></a>3、GC演示</h2><p>JVM参数设置成最大堆内存100M，当前堆内存10M：-Xmx100m -Xms10m -XX:+PrintGCDetails</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Java">System.out.println(<span class="hljs-string">&quot;=====================Begin=========================&quot;</span>);<br>System.out.print(<span class="hljs-string">&quot;最大堆大小：Xmx=&quot;</span>);<br>System.out.println(Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br><br>System.out.print(<span class="hljs-string">&quot;剩余堆大小：free mem=&quot;</span>);<br>System.out.println(Runtime.getRuntime().freeMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br><br>System.out.print(<span class="hljs-string">&quot;当前堆大小：total mem=&quot;</span>);<br>System.out.println(Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br><br>System.out.println(<span class="hljs-string">&quot;==================First Allocated===================&quot;</span>);<br><span class="hljs-keyword">byte</span>[] b1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">5</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>System.out.println(<span class="hljs-string">&quot;5MB array allocated&quot;</span>);<br><br>System.out.print(<span class="hljs-string">&quot;剩余堆大小：free mem=&quot;</span>);<br>System.out.println(Runtime.getRuntime().freeMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br><br>System.out.print(<span class="hljs-string">&quot;当前堆大小：total mem=&quot;</span>);<br>System.out.println(Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br><br>System.out.println(<span class="hljs-string">&quot;=================Second Allocated===================&quot;</span>);<br><span class="hljs-keyword">byte</span>[] b2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>System.out.println(<span class="hljs-string">&quot;10MB array allocated&quot;</span>);<br><br>System.out.print(<span class="hljs-string">&quot;剩余堆大小：free mem=&quot;</span>);<br>System.out.println(Runtime.getRuntime().freeMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br><br>System.out.print(<span class="hljs-string">&quot;当前堆大小：total mem=&quot;</span>);<br>System.out.println(Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br><br>System.out.println(<span class="hljs-string">&quot;=====================OOM=========================&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;OOM!!!&quot;</span>);<br>System.gc();<br><br>System.out.println(<span class="hljs-string">&quot;第一个 40M 数组&quot;</span>);<br><span class="hljs-keyword">byte</span>[] b3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">40</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br><br>System.out.println(<span class="hljs-string">&quot;第二个 40M 数组&quot;</span>);<br><span class="hljs-keyword">byte</span>[] b4 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">40</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br><br>System.out.println(<span class="hljs-string">&quot;第三个 40M 数组&quot;</span>);<br><span class="hljs-keyword">byte</span>[] b5 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">40</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br></code></pre></td></tr></table></figure>

<p>运行这个程序，可以看到minor GC和full GC日志：</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM53.jpg?versionId=CAEQKRiBgID8t577.hciIDExM2UyNWVjM2FjNzRmMzE4OWY4ZTVkMTRjZDcxYjM1" srcset="/img/loading.gif" lazyload alt="image-20220306140702751"></p>
<p>本例打印名词说明：</p>
<ul>
<li>GC : 也成为minor GC ，尽在新生代执行的小范围GC。</li>
<li>Full GC ： 也成为major GC ，在整个堆执行的GC</li>
</ul>
<h2 id="第三节-堆溢出异常"><a href="#第三节-堆溢出异常" class="headerlink" title="第三节 堆溢出异常"></a>第三节 堆溢出异常</h2><h3 id="1、异常名称-1"><a href="#1、异常名称-1" class="headerlink" title="1、异常名称"></a>1、异常名称</h3><p>java.lang.OutOfMemoryError，也往往简称为 OOM。</p>
<h3 id="2、异常信息"><a href="#2、异常信息" class="headerlink" title="2、异常信息"></a>2、异常信息</h3><ul>
<li>Java heap space：针对新生代、老年代整体进行Full GC后，内存空间还是放不下新产生的对象，且无法申请更多的空间</li>
<li>PermGen space：方法区中加载的类太多了（典型情况是框架创建的动态类太多，导致方法区溢出）</li>
</ul>
<p>我们可以参考下面的控制台日志打印：</p>
<blockquote>
<p>[GC (Allocation Failure) 4478364K-&gt;4479044K(5161984K), 4.3454766 secs] [Full GC (Ergonomics) 4479044K-&gt;3862071K(5416448K), 39.3706285 secs] [Full GC (Ergonomics) 4410423K-&gt;4410422K(5416448K), 27.7039534 secs] [Full GC (Ergonomics) 4629575K-&gt;4621239K(5416448K), 24.9298221 secs] [Full GC (Allocation Failure) 4621239K-&gt;4621186K(5416448K), 29.0616791 secs] Exception in thread “main” java.lang.OutOfMemoryError: <strong>Java heap space</strong> at java.util.Arrays.copyOf(Arrays.java:3210) at java.util.Arrays.copyOf(Arrays.java:3181) at java.util.ArrayList.grow(ArrayList.java:261) at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235) at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227) at java.util.ArrayList.add(ArrayList.java:458) at com.atguigu.jvm.test.JavaHeapTest.main(JavaHeapTest.java:16)</p>
</blockquote>
<h2 id="第四节-小练习"><a href="#第四节-小练习" class="headerlink" title="第四节 小练习"></a>第四节 小练习</h2><h3 id="1、测试代码"><a href="#1、测试代码" class="headerlink" title="1、测试代码"></a>1、测试代码</h3><p>查看下面程序在每个步骤中内存的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Review</span> </span>&#123;<br><br>    <span class="hljs-comment">// 静态变量，类变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Review review = <span class="hljs-keyword">new</span> Review();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-comment">// 局部变量</span><br>        Review reviewLocal = <span class="hljs-keyword">new</span> Review();<br><br>    &#125;<br><br>    <span class="hljs-comment">// 程序入口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 局部变量</span><br>        Review reviewMain = <span class="hljs-keyword">new</span> Review();<br><br>        <span class="hljs-comment">// 通过局部变量调用对象的方法</span><br>        reviewMain.showMessage();<br><br>        <span class="hljs-comment">// 手动 GC</span><br>        System.gc();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>




<h3 id="2、各状态分析"><a href="#2、各状态分析" class="headerlink" title="2、各状态分析"></a>2、各状态分析</h3><h4 id="①状态1：执行到-showMessage-方法中"><a href="#①状态1：执行到-showMessage-方法中" class="headerlink" title="①状态1：执行到 showMessage() 方法中"></a>①状态1：执行到 showMessage() 方法中</h4><p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM18.jpg?versionId=CAEQKRiBgMCbvJ77.hciIDhlNjJkOThjZDUxNTQ2YWY4MjFjYTljMjUwNGM3NTZl" srcset="/img/loading.gif" lazyload alt="images"></p>
<h4 id="②状态2：showMessage-方法结束"><a href="#②状态2：showMessage-方法结束" class="headerlink" title="②状态2：showMessage() 方法结束"></a>②状态2：showMessage() 方法结束</h4><p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM19.jpg?versionId=CAEQKRiBgICGvJ77.hciIDJlYTQ4MGJkMzc4ODRmNDA5YTk1NGY0OGExNGZjZTcy" srcset="/img/loading.gif" lazyload alt="images"></p>
<h4 id="③状态3：执行一次-GC"><a href="#③状态3：执行一次-GC" class="headerlink" title="③状态3：执行一次 GC"></a>③状态3：执行一次 GC</h4><p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM20.jpg?versionId=CAEQKRiBgID_u577.hciIDEyMDJmYTU4NTBmOTQ4MWQ4OGVkYmFiYWE0M2YwNWE1" srcset="/img/loading.gif" lazyload alt="images"></p>
<h4 id="④状态4：main-方法结束"><a href="#④状态4：main-方法结束" class="headerlink" title="④状态4：main() 方法结束"></a>④状态4：main() 方法结束</h4><p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM21.jpg?versionId=CAEQKRiBgMD4u577.hciIDg4ZTJkNjMxM2FhOTQ0YWZiZTdmZTczYTI4ZGVjY2Jm" srcset="/img/loading.gif" lazyload alt="images"></p>
<h4 id="⑤状态5：执行一次-GC"><a href="#⑤状态5：执行一次-GC" class="headerlink" title="⑤状态5：执行一次 GC"></a>⑤状态5：执行一次 GC</h4><p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM22.jpg?versionId=CAEQKRiBgIDxu577.hciIGM1NmE3NTgzY2IzOTRkMDU4ZjVkMGQ5MTlhYjdjNDAz" srcset="/img/loading.gif" lazyload alt="images"></p>
<h4 id="⑥状态6：执行过第-15-次-GC-后"><a href="#⑥状态6：执行过第-15-次-GC-后" class="headerlink" title="⑥状态6：执行过第 15 次 GC 后"></a>⑥状态6：执行过第 15 次 GC 后</h4><p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM23.jpg?versionId=CAEQKRiBgIDru577.hciIDhhNjU1OTc2OWE0MjQxZTU5MTY5YjU0YWE0MTA3YjI0" srcset="/img/loading.gif" lazyload alt="images"></p>
<h1 id="第七章-可视化工具"><a href="#第七章-可视化工具" class="headerlink" title="第七章 可视化工具"></a>第七章 可视化工具</h1><h2 id="第一节-jconsole"><a href="#第一节-jconsole" class="headerlink" title="第一节 jconsole"></a>第一节 jconsole</h2><h3 id="1、所在路径"><a href="#1、所在路径" class="headerlink" title="1、所在路径"></a>1、所在路径</h3><p>%JAVA_HOME%/bin/jconsole.exe</p>
<h3 id="2、使用方法"><a href="#2、使用方法" class="headerlink" title="2、使用方法"></a>2、使用方法</h3><p>双击打开，选择要监控的进程：</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM24.jpg?versionId=CAEQKRiBgMDlu577.hciIDZlM2IzZGVhZmRkNjRiN2Y4MzE4ZWFmNzI1OGM4YmYx" srcset="/img/loading.gif" lazyload alt="images"></p>
<p>如果想要重新打开新建连接窗口可以点击菜单项：</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM25.jpg?versionId=CAEQKRiBgICcup77.hciIDkyMTAwNjZhZDRmYTQ1NTlhNDE2OGIyNzI5NWE2NDc1" srcset="/img/loading.gif" lazyload alt="images"></p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM26.jpg?versionId=CAEQKRiBgMCaup77.hciIDRlNzE1MzNhYzUwZjQyN2RiNjRjNmJhNTJmNGNlYmVj" srcset="/img/loading.gif" lazyload alt="images"></p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM27.jpg?versionId=CAEQKRiBgICYup77.hciIDcwMGVhNzRhYmQzNjRiMGJiYWYwM2QyYTc1N2U0NGEy" srcset="/img/loading.gif" lazyload alt="images"></p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM28.jpg?versionId=CAEQKRiBgMCWup77.hciIGMxMGJkMjRlYTBmMTQ3NmRiOGMyNmMzOTM1ZmE3ZDlh" srcset="/img/loading.gif" lazyload alt="images"></p>
<p>可以选择内存选项卡，在图表下拉列表中选择想要查看的具体的内存区域：</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM29.jpg?versionId=CAEQKRiBgID1uZ77.hciIDQ5MzY1MDhlZGM4YTRjNWU5ODIxYmUxM2I0YjBiZTJl" srcset="/img/loading.gif" lazyload alt="images"></p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM30.jpg?versionId=CAEQKRiBgIDzuZ77.hciIDJkMmVjOTI2Y2FhMzRjMGY4YTdhNzYwMDFhMDA5ODRj" srcset="/img/loading.gif" lazyload alt="images"></p>
<h2 id="第二节-jvisualvm"><a href="#第二节-jvisualvm" class="headerlink" title="第二节 jvisualvm"></a>第二节 jvisualvm</h2><h3 id="1、所在路径-1"><a href="#1、所在路径-1" class="headerlink" title="1、所在路径"></a>1、所在路径</h3><p>%JAVA_HOME%/bin/jvisualvm.exe</p>
<h3 id="2、使用方法-1"><a href="#2、使用方法-1" class="headerlink" title="2、使用方法"></a>2、使用方法</h3><p>双击打开，从本地进程列表中选择要监控的进程：</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM31.jpg?versionId=CAEQKRiBgIDyuZ77.hciIGRjZDEzOGFiZWIzOTQxZWE4YjU5ZmExYjE2Y2Y4NmY0" srcset="/img/loading.gif" lazyload alt="images"></p>
<p>选中的进程要双击打开：</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM32.jpg?versionId=CAEQKRiBgMDvuZ77.hciIDNkNzAyNDhhMjU3OTQ5ZDc5MmMxNTkyYzcwNzE1NDE2" srcset="/img/loading.gif" lazyload alt="images"></p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM33.jpg?versionId=CAEQKRiBgMDxuZ77.hciIGRkODliYzZlNDIyNTQ0YmQ4MWY2MWY4MjQ0OGQ2YWRh" srcset="/img/loading.gif" lazyload alt="images"></p>
<h1 id="第八章-垃圾回收-重要"><a href="#第八章-垃圾回收-重要" class="headerlink" title="第八章 垃圾回收 [重要]"></a>第八章 垃圾回收 [重要]</h1><h2 id="第一节-GC的基本问题"><a href="#第一节-GC的基本问题" class="headerlink" title="第一节 GC的基本问题"></a>第一节 GC的基本问题</h2><ul>
<li><p>什么是GC？</p>
<p>GC 是 garbage collection 的缩写，意思是垃圾回收——把内存（特别是堆内存）中不再使用的空间释放掉；清理不再使用的对象。</p>
</li>
<li><p>为什么要GC？</p>
<p>堆内存是各个<strong>线程共享</strong>的空间，不能无节制的使用。服务器运行的时间通常都很长。累积的对象也会非常多。这些对象如果不做任何清理，任由它们数量不断累加，内存很快就会耗尽。所以GC就是要把不使用的对象都清理掉，把内存空间空出来，让项目可以持续运行下去。</p>
</li>
<li><p>什么样的对象是垃圾对象？</p>
<p>不再使用或获取不到的对象是垃圾对象。</p>
</li>
<li><p>如何把垃圾对象找出来？</p>
<p>办法1：引用计数法（不采用，不能解决循环引用问题）[了解]</p>
<p>办法2：可达性分析（从GC Roots对象出发，不可达的对象就是要清理的对象）[理解]</p>
</li>
<li><p>找到垃圾对象如何执行清理？</p>
<p>具体的GC算法</p>
</li>
</ul>
<h2 id="第二节-标记垃圾对象"><a href="#第二节-标记垃圾对象" class="headerlink" title="第二节 标记垃圾对象"></a>第二节 标记垃圾对象</h2><h3 id="1、引用计数法（不采用）"><a href="#1、引用计数法（不采用）" class="headerlink" title="1、引用计数法（不采用）"></a>1、引用计数法（不采用）</h3><h4 id="①工作机制"><a href="#①工作机制" class="headerlink" title="①工作机制"></a>①工作机制</h4><p>引用计数法是在对象每一次被引用时，都给这个对象专属的『引用计数器』+1。</p>
<p>当前引用被取消时，就给这个『引用计数器』-1。</p>
<p>当前『引用计数器』为零时，表示这个对象不再被引用了，需要让GC回收。</p>
<p>可是当对象之间存在交叉引用的时候，对象即使处于应该被回收的状态，也没法让『引用计数器』归零。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Member member01 = <span class="hljs-keyword">new</span> Member();<br>Member member02 = <span class="hljs-keyword">new</span> Member();<br></code></pre></td></tr></table></figure>



<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM34.jpg?versionId=CAEQKRiBgIDpuZ77.hciIGMzODM1ODAzZDA1NzQxZDk4YTczNjVlY2E3YjM0MDY2" srcset="/img/loading.gif" lazyload alt="images"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">member01.setFriend(member02);<br>member02.setFriend(member01);<br></code></pre></td></tr></table></figure>



<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM35.jpg?versionId=CAEQKRiBgMCwuJ77.hciIDNjNWM2MmQyMjEwZTQ2OWQ4MDZmOGMwNzg0YWM5OTM2" srcset="/img/loading.gif" lazyload alt="images"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">member01 = <span class="hljs-keyword">null</span>;<br>member02 = <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure>



<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM36.jpg?versionId=CAEQKRiBgMCxuJ77.hciIDRlOTQwNGU1YzYyMDRjOTU4NDg0YWI0ZjI5NmI1ODk2" srcset="/img/loading.gif" lazyload alt="images"></p>
<p>引用计数法的关键问题：<strong>该清理的对象清理不掉</strong>。</p>
<h4 id="②循环引用举例"><a href="#②循环引用举例" class="headerlink" title="②循环引用举例"></a>②循环引用举例</h4><h5 id="1-一对多关联关系"><a href="#1-一对多关联关系" class="headerlink" title="[1]一对多关联关系"></a>[1]一对多关联关系</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;Order&gt; orderList;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Order&gt; <span class="hljs-title">getOrderList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> orderList;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOrderList</span><span class="hljs-params">(List&lt;Order&gt; orderList)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.orderList = orderList;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Customer customer;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Customer <span class="hljs-title">getCustomer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> customer;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCustomer</span><span class="hljs-params">(Customer customer)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.customer = customer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="2-SpringMVC-组件"><a href="#2-SpringMVC-组件" class="headerlink" title="[2]SpringMVC 组件"></a>[2]SpringMVC 组件</h5><ul>
<li>IOC 容器对象的接口类型：WebApplicationContext<ul>
<li>WebApplicationContext 对象初始化过程中：将它自己存入 ServletContext 域</li>
<li>WebApplicationContext 对象也会把 ServletContext 存入 IOC 容器</li>
</ul>
</li>
<li>Servlet 上下文对象：ServletContext</li>
</ul>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM37.jpg?versionId=CAEQKRiBgMCouJ77.hciIDQzYTU0ZjRhY2VhNzRiMGRhYTdlNGJkYWI2NDcyMWIx" srcset="/img/loading.gif" lazyload alt="images"></p>
<h3 id="2、GC-Roots可达性分析"><a href="#2、GC-Roots可达性分析" class="headerlink" title="2、GC Roots可达性分析"></a>2、GC Roots可达性分析</h3><p>核心原理：判断一个对象，是否存在从<strong>『堆外』</strong>到<strong>『堆内』</strong>的引用。</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM38.jpg?versionId=CAEQKRiBgICmuJ77.hciIDE3ZjM3YWJlMWY1NzRlNGFiYzc4Y2RiZGJhNGZhZDJk" srcset="/img/loading.gif" lazyload alt="images"></p>
<p>请看下面的例子：</p>
<h4 id="①加载Employee类"><a href="#①加载Employee类" class="headerlink" title="①加载Employee类"></a>①加载Employee类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SUBJECT = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Java&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM39.jpg?versionId=CAEQKRiBgMCKuJ77.hciIDM3ZjM5YzU3NTQ3YzRlYzA4NzA4MDQ0YmRhZTNhMTI4" srcset="/img/loading.gif" lazyload alt="images"></p>
<h4 id="②创建Employee对象并赋值给变量"><a href="#②创建Employee对象并赋值给变量" class="headerlink" title="②创建Employee对象并赋值给变量"></a>②创建Employee对象并赋值给变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 1.创建Employee对象，并赋值给employee变量</span><br>    Employee employee = <span class="hljs-keyword">new</span> Employee();<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM40.jpg?versionId=CAEQKRiBgICSuJ77.hciIDM4MGQyZTM5NzQwZjQzMDk5MzNkN2ZhNjJkMzI3ZjBj" srcset="/img/loading.gif" lazyload alt="images"></p>
<h3 id="3、GC-Root-对象"><a href="#3、GC-Root-对象" class="headerlink" title="3、GC Root 对象"></a>3、GC Root 对象</h3><p>GC Root 对象：就是作为根节点出发，顺着引用路径一直查找到堆空间内，找到堆空间中的对象。</p>
<ul>
<li>Java 栈中的局部变量</li>
<li>本地方法栈中的局部变量</li>
<li>方法区中的类变量、常量</li>
</ul>
<h2 id="第三节-垃圾回收算法"><a href="#第三节-垃圾回收算法" class="headerlink" title="第三节 垃圾回收算法"></a>第三节 垃圾回收算法</h2><p>基本垃圾回收算法有四种：引用计数法、标记清除法、标记压缩法、复制算法。现代流行的垃圾收集算法一般是由这四种中的其中几种算法相互组合而成。例如：分代算法、分区算法。</p>
<blockquote>
<p>这里又看到一个『引用计数法』，但是和前面提到的不一样：</p>
<p>前面『引用计数法』：是标记垃圾对象的一种方法</p>
<p>这里『引用计数法』：是执行垃圾回收的一种方法</p>
</blockquote>
<h3 id="1、基本算法：引用计数法（不采用）"><a href="#1、基本算法：引用计数法（不采用）" class="headerlink" title="1、基本算法：引用计数法（不采用）"></a>1、基本算法：引用计数法（不采用）</h3><p>引用计数算法很简单，它实际上是通过在对象头中分配一个空间来保存该对象被引用的次数。如果该对象被其它对象引用，则它的引用计数加一，如果删除对该对象的引用，那么它的引用计数就减一，当该对象的引用计数为0时，那么该对象就会被回收。</p>
<p>引用计数垃圾收集机制，它只是在引用计数变化为0时即刻发生，而且只针对某一个对象以及它所依赖的其它对象。所以，我们一般也称呼引用计数垃圾收集为直接的垃圾收集机制。垃圾收集的开销被分摊到整个应用程序的运行当中了，而不是在进行垃圾收集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束。因此，采用引用计数的垃圾收集不属于严格意义上的”Stop-The-World”的垃圾收集机制。</p>
<p>优点：</p>
<ul>
<li>实时性较高，不需要等到内存不够时才回收</li>
<li>垃圾回收时不用挂起整个程序，不影响程序正常运行</li>
</ul>
<p>缺点：</p>
<ul>
<li>回收时不移动对象, 所以会造成内存碎片问题</li>
<li>不能解决对象间的<strong>循环引用问题</strong></li>
</ul>
<p>小结：</p>
<p>正是由于引用计数法不能解决对象间的循环引用问题，所以事实上并<strong>没有</strong>哪一款 JVM 产品<strong>采用</strong>这个机制。</p>
<p>TIP</p>
<p>Stop-The-World：字面意思让整个世界停止。在 GC 机制中，Stop-The-World 表示挂起整个 JVM 程序，等执行完垃圾回收之后，再继续执行 JVM 程序。Stop-The-World 通常也会简称为 STW。</p>
<h3 id="2、基本算法：标记清除法"><a href="#2、基本算法：标记清除法" class="headerlink" title="2、基本算法：标记清除法"></a>2、基本算法：标记清除法</h3><p>它的做法是当堆中的有效内存空间被耗尽的时候，就会暂停、挂起整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。</p>
<ul>
<li>标记：标记的过程其实就是，从根对象开始遍历所有的对象，然后将所有存活的对象标记为可达的对象。</li>
<li>清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。</li>
</ul>
<p>小结：</p>
<ul>
<li>优点：实现简单</li>
<li>缺点：<ul>
<li>效率低，因为标记和清除两个动作都要遍历所有的对象</li>
<li>垃圾收集后有可能会造成大量的内存碎片</li>
<li>垃圾回收时会造成应用程序暂停</li>
</ul>
</li>
</ul>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM41.jpg?versionId=CAEQKRiBgICIuJ77.hciIDIyMzdjYTY2Zjc0YzQzMGM4MmI4ZjczZTIxZjNjOGUx" srcset="/img/loading.gif" lazyload alt="images"></p>
<h3 id="3、基本算法：标记压缩法"><a href="#3、基本算法：标记压缩法" class="headerlink" title="3、基本算法：标记压缩法"></a>3、基本算法：标记压缩法</h3><p>既然叫标记压缩算法，那么它也分为两个阶段，一个是标记(mark)，一个是压缩(compact)。所谓压缩就是把存在碎片的空间连起来。</p>
<p>标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的清理未标记的对象，而是将存活的对象移动到内存的一端，然后清理边界以外的垃圾，从而解决了碎片化的问题。</p>
<p>标记 : 标记的过程其实就是，从根对象开始遍历所有的对象，然后将所有存活的对象标记为可达的对象。</p>
<p>压缩 : 移动所有的可达对象到堆内存的同一个区域中，使他们紧凑的排列在一起，从而将所有非可达对象释放出来的空闲内存都集中在一起，通过这样的方式来达到减少内存碎片的目的。</p>
<p>小结</p>
<p>优点：标记压缩算法是对标记清除算法的优化，解决了碎片化的问题</p>
<p>缺点：还是效率问题，在标记清除算法上又多加了一步，效率可想而知了</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM42.jpg?versionId=CAEQKRiBgMCEuJ77.hciIDk2NzczNTg3YmJlZjQ5YTc4ZTM5ZWNmYmNiMzYxYzUz" srcset="/img/loading.gif" lazyload alt="images"></p>
<h3 id="4、基本算法：复制算法"><a href="#4、基本算法：复制算法" class="headerlink" title="4、基本算法：复制算法"></a>4、基本算法：复制算法</h3><p>复制算法的核心就是，将原有的内存空间一分为二，每次只用其中的一块，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，并依次排列，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。</p>
<p>小结</p>
<ul>
<li>优点1：在垃圾多的情况下(新生代)，效率较高</li>
<li>优点2：清理后，内存无碎片</li>
<li>缺点：浪费了一半的内存空间，在存活对象较多的情况下(老年代)，效率较差</li>
</ul>
<p>执行GC前：</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM43.jpg?versionId=CAEQKRiBgICBuJ77.hciIDI3ZWU5ODU3YmJhMTQxOTc5M2RhNDFhYzkwYmEyOTgx" srcset="/img/loading.gif" lazyload alt="images"></p>
<p>执行标记：</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM44.jpg?versionId=CAEQKRiBgMDmtp77.hciIGEzYzEwYzgwOWUzZDQ0M2JiYTk5MTAzNjc1ZjU2YWY0" srcset="/img/loading.gif" lazyload alt="images"></p>
<p>执行复制：</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM45.jpg?versionId=CAEQKRiBgMDptp77.hciIDk1YjAzMjFkYTAwZjQ0NjRhNTEzYTRiNWY3ZmRjNTMz" srcset="/img/loading.gif" lazyload alt="images"></p>
<p>交换指针：</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM46.jpg?versionId=CAEQKRiBgIDatp77.hciIGUxZjVhNTVjMzMyODRkOTU5MTZiM2ViNjk4YzUxM2Ji" srcset="/img/loading.gif" lazyload alt="images"></p>
<h3 id="5、综合算法：分代算法"><a href="#5、综合算法：分代算法" class="headerlink" title="5、综合算法：分代算法"></a>5、综合算法：分代算法</h3><p>前面介绍了多种回收算法，每一种算法都有自己的优点也有缺点，谁都不能替代谁，所以根据垃圾回收对象的特点进行选择，才是明智的。</p>
<p>分代算法其实就是这样的，根据回收对象的特点进行选择。</p>
<ul>
<li>新生代适合使用复制算法</li>
<li>老年代适合使用标记清除或标记压缩算法</li>
</ul>
<h3 id="6、综合算法：分区算法"><a href="#6、综合算法：分区算法" class="headerlink" title="#6、综合算法：分区算法"></a><a target="_blank" rel="noopener" href="http://heavy_code_industry.gitee.io/code_heavy_industry/pro016-JVM/lecture/chapter08/verse03.html#_6%E3%80%81%E7%BB%BC%E5%90%88%E7%AE%97%E6%B3%95-%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95">#</a>6、综合算法：分区算法</h3><p>上面介绍的分代收集算法是将对象的生命周期按长短划分为两个部分，而分区算法则将整个堆空间划分为连续的不同小区间，每个小区间独立使用，独立回收。这样做的好处是可以控制一次回收多少个小区间。在相同条件下，堆空间越大。一次GC耗时就越长，从而产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割为多个小块，根据目标停顿时间每次合理地回收若干个小区间(而不是整个堆)，从而减少一次GC所产生的停顿。</p>
<h2 id="第四节-垃圾回收器-了解"><a href="#第四节-垃圾回收器-了解" class="headerlink" title="第四节 垃圾回收器 [了解]"></a>第四节 垃圾回收器 [了解]</h2><h3 id="1、串行垃圾回收器"><a href="#1、串行垃圾回收器" class="headerlink" title="1、串行垃圾回收器"></a>1、串行垃圾回收器</h3><p>串行：在一个线程内执行垃圾回收操作。</p>
<p>新生代串行回收器 SerialGC：采用复制算法实现，单线程垃圾回收，独占式垃圾回收器</p>
<p>老年代串行回收器 SerialOldGC：采用标记压缩算法，单线程独占式垃圾回收器</p>
<h3 id="2、并行垃圾回收器"><a href="#2、并行垃圾回收器" class="headerlink" title="#2、并行垃圾回收器"></a><a target="_blank" rel="noopener" href="http://heavy_code_industry.gitee.io/code_heavy_industry/pro016-JVM/lecture/chapter08/verse04.html#_2%E3%80%81%E5%B9%B6%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8">#</a>2、并行垃圾回收器</h3><p>并行：在多个线程中执行垃圾回收操作。</p>
<p>新生代 ParNew 回收器：采用复制算法实现，多线程回收器，独占式垃圾回收器。</p>
<p>新生代 ParallelScavengeGC 回收器：采用复制算法多线程独占式回收器</p>
<p>老年代 ParallelOldGC 回收器: 采用标记压缩算法，多线程独占式回收器</p>
<ul>
<li><p>CMS回收器</p>
<p>CMS全称 (Concurrent Mark Sweep)，是一款并发的、使用标记-清除算法的垃圾回收器。对CPU资源非常敏感。</p>
<p>启用CMS回收器参数 ：-XX:+UseConcMarkSweepGC。</p>
<p>使用场景：GC过程短暂停顿，适合对时延要求较高的服务，用户线程不允许长时间的停顿。</p>
<p>优点：最短回收停顿时间为目标的收集器。并发收集，低停顿。</p>
<p>缺点：服务长时间运行，造成严重的内存碎片化。算法实现比较复杂。</p>
</li>
<li><p>G1回收器</p>
<p>G1(Garbage-First)是一款面向服务端应用的并发垃圾回收器, 主要目标用于配备多颗CPU的服务器，治理大内存。是JDK1.7提供的一个新收集器，是当今收集器技术发展的最前沿成果之一。</p>
<p>G1计划是并发标记-清除收集器的长期替代品。</p>
<p>启用G1收集器参数：-XX:+UseG1GC启用G1收集器。</p>
<p>G1将整个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了, 它们都是一部分Region(不需要连续)的集合。</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM47.jpg?versionId=CAEQKRiBgIDltp77.hciIDJhYTZkNjA1MDFkYjQ4MGE5MTY2NTBmOGU4MjAwMWU2" srcset="/img/loading.gif" lazyload alt="images"></p>
<p>每块区域既有可能属于Old区、也有可能是Young区，因此不需要一次就对整个老年代/新生代回收。而是当线程并发寻找可回收的对象时，有些区块包含可回收的对象要比其他区块多很多。虽然在清理这些区块时G1仍然需要暂停应用线程，但可以用相对较少的时间优先回收垃圾较多的Region(这也是G1命名的来源)。这种方式保证了G1可以在有限的时间内获取尽可能高的收集效率。</p>
<p>特点：</p>
<ul>
<li>一整块堆内存被分成多个独立的区域Regions</li>
<li>存活对象被拷贝到新的Survivor区</li>
<li>新生代内存由一组不连续的堆heap区组成，使得可以动态调整各个区域</li>
<li>多线程并发GC</li>
<li>young GC会有STW（Stop the world）事件</li>
</ul>
</li>
</ul>
<h3 id="3、垃圾回收器对比"><a href="#3、垃圾回收器对比" class="headerlink" title="3、垃圾回收器对比"></a>3、垃圾回收器对比</h3><h4 id="①新生代回收器"><a href="#①新生代回收器" class="headerlink" title="①新生代回收器"></a>①新生代回收器</h4><table>
<thead>
<tr>
<th>名称</th>
<th>串行/并行/并发</th>
<th>回收算法</th>
<th>适用场景</th>
<th>可以与CMS配合</th>
</tr>
</thead>
<tbody><tr>
<td>SerialGC</td>
<td>串行</td>
<td>复制</td>
<td>单CPU</td>
<td>是</td>
</tr>
<tr>
<td>ParNewGC</td>
<td>并行</td>
<td>复制</td>
<td>多CPU</td>
<td>是</td>
</tr>
<tr>
<td>ParallelScavengeGC</td>
<td>并行</td>
<td>复制</td>
<td>多CPU且关注吞吐量</td>
<td>否</td>
</tr>
</tbody></table>
<h4 id="②老年代回收器"><a href="#②老年代回收器" class="headerlink" title="②老年代回收器"></a>②老年代回收器</h4><table>
<thead>
<tr>
<th>名称</th>
<th>串行/并行/并发</th>
<th>回收算法</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>SerialOldGC</td>
<td>串行</td>
<td>标记压缩</td>
<td>单CPU</td>
</tr>
<tr>
<td>ParNewOldGC</td>
<td>并行</td>
<td>标记压缩</td>
<td>多CPU</td>
</tr>
<tr>
<td>CMS</td>
<td>并发，几乎不会暂停用户线程</td>
<td>标记清除</td>
<td>多CPU且与用户线程共存</td>
</tr>
</tbody></table>
<h2 id="第五节-finalize-机制"><a href="#第五节-finalize-机制" class="headerlink" title="第五节 finalize 机制"></a>第五节 finalize 机制</h2><h3 id="1、总体机制介绍"><a href="#1、总体机制介绍" class="headerlink" title="#1、总体机制介绍"></a><a target="_blank" rel="noopener" href="http://heavy_code_industry.gitee.io/code_heavy_industry/pro016-JVM/lecture/chapter08/verse05.html#_1%E3%80%81%E6%80%BB%E4%BD%93%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D">#</a>1、总体机制介绍</h3><p>java.lang.Object 类中有一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123; &#125;<br></code></pre></td></tr></table></figure>



<p>方法体内是空的，说明如果子类不重写这个方法，那么不执行任何逻辑。</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM48.jpg?versionId=CAEQKRiCgICetp77.hciIGE1ODBlZDBkOGE3NTQ5YWRhYmFkZjRmZGEzNWUxYmI4" srcset="/img/loading.gif" lazyload alt="images"></p>
<ul>
<li>在执行 GC 操作前，调用 finalize() 方法的是 Finalizer 线程，这个线程优先级很低。</li>
<li>在对象的整个生命周期过程中，finalize() 方法只会被调用一次。</li>
</ul>
<h3 id="2、代码验证"><a href="#2、代码验证" class="headerlink" title="2、代码验证"></a>2、代码验证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinalizeTest</span> </span>&#123;<br><br>    <span class="hljs-comment">// 静态变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FinalizeTest testObj;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-comment">// 重写 finalize() 方法</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; is working&quot;</span>);<br><br>        <span class="hljs-comment">// 给待回收的对象（this）重新建立引用</span><br>        testObj = <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 1、创建 FinalizeTest 对象</span><br>        FinalizeTest testObj = <span class="hljs-keyword">new</span> FinalizeTest();<br><br>        <span class="hljs-comment">// 2、取消引用</span><br>        testObj = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 3、执行 GC 操作</span><br>        System.gc();<br><br>        <span class="hljs-comment">// ※ 让主线程等待一会儿，以便调用 finalize() 的线程能够执行</span><br>        <span class="hljs-keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br><br>        <span class="hljs-comment">// 4、判断待回收的对象是否存在</span><br>        <span class="hljs-keyword">if</span> (FinalizeTest.testObj == <span class="hljs-keyword">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;待回收的对象没有获救，还是要被 GC 清理&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;待回收的对象被成功解救&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 5、再次取消引用</span><br>        FinalizeTest.testObj = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 6、再次执行 GC 操作</span><br>        System.gc();<br><br>        <span class="hljs-comment">// 7、判断待回收的对象是否存在</span><br>        <span class="hljs-keyword">if</span> (FinalizeTest.testObj == <span class="hljs-keyword">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;待回收的对象没有获救，还是要被 GC 清理&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;待回收的对象被成功解救&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<p>执行效果：</p>
<blockquote>
<p>Finalizer is working<br>待回收的对象被成功解救<br>待回收的对象没有获救，还是要被 GC 清理</p>
</blockquote>
<h1 id="第九章-JVM参数设置入门"><a href="#第九章-JVM参数设置入门" class="headerlink" title="第九章 JVM参数设置入门"></a>第九章 JVM参数设置入门</h1><h2 id="1、Runtime类使用案例"><a href="#1、Runtime类使用案例" class="headerlink" title="1、Runtime类使用案例"></a>1、Runtime类使用案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.print(<span class="hljs-string">&quot;最大堆大小：&quot;</span>);<br>System.out.println(Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br>System.out.print(<span class="hljs-string">&quot;当前堆大小：&quot;</span>);<br>System.out.println(Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;==================================================&quot;</span>);<br><br><span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>&#125;<br></code></pre></td></tr></table></figure>



<p>执行前配置参数：-Xmx50m -Xms30m -XX:+PrintGCDetails</p>
<p>执行看到如下信息：</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM49.jpg?versionId=CAEQKRiBgICGtp77.hciIDdhMTJmMmZkMDZkYjRiYjVhNTg1NjZjMGIxODk2ODcz" srcset="/img/loading.gif" lazyload alt="images"></p>
<p>新生代和老年代的堆大小之和是Runtime.getRuntime().totalMemory()</p>
<h2 id="2、GC演示"><a href="#2、GC演示" class="headerlink" title="2、GC演示"></a>2、GC演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;=====================Begin=========================&quot;</span>);<br>System.out.print(<span class="hljs-string">&quot;最大堆大小：Xmx=&quot;</span>);<br>System.out.println(Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br><br>System.out.print(<span class="hljs-string">&quot;剩余堆大小：free mem=&quot;</span>);<br>System.out.println(Runtime.getRuntime().freeMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br><br>System.out.print(<span class="hljs-string">&quot;当前堆大小：total mem=&quot;</span>);<br>System.out.println(Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br><br>System.out.println(<span class="hljs-string">&quot;==================First Allocated===================&quot;</span>);<br><span class="hljs-keyword">byte</span>[] b1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">5</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>System.out.println(<span class="hljs-string">&quot;5MB array allocated&quot;</span>);<br><br>System.out.print(<span class="hljs-string">&quot;剩余堆大小：free mem=&quot;</span>);<br>System.out.println(Runtime.getRuntime().freeMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br><br>System.out.print(<span class="hljs-string">&quot;当前堆大小：total mem=&quot;</span>);<br>System.out.println(Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br><br>System.out.println(<span class="hljs-string">&quot;=================Second Allocated===================&quot;</span>);<br><span class="hljs-keyword">byte</span>[] b2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>System.out.println(<span class="hljs-string">&quot;10MB array allocated&quot;</span>);<br><br>System.out.print(<span class="hljs-string">&quot;剩余堆大小：free mem=&quot;</span>);<br>System.out.println(Runtime.getRuntime().freeMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br> <br>System.out.print(<span class="hljs-string">&quot;当前堆大小：total mem=&quot;</span>);<br>System.out.println(Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;M&quot;</span>);<br> <br>System.out.println(<span class="hljs-string">&quot;=====================OOM=========================&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;OOM!!!&quot;</span>);<br>System.gc();<br> <br>System.out.println(<span class="hljs-string">&quot;第一个 40M 数组&quot;</span>);<br><span class="hljs-keyword">byte</span>[] b3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">40</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br> <br>System.out.println(<span class="hljs-string">&quot;第二个 40M 数组&quot;</span>);<br><span class="hljs-keyword">byte</span>[] b4 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">40</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br> <br>System.out.println(<span class="hljs-string">&quot;第三个 40M 数组&quot;</span>);<br><span class="hljs-keyword">byte</span>[] b5 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">40</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br></code></pre></td></tr></table></figure>

<p>JVM参数设置成最大堆内存100M，当前堆内存10M：-Xmx100m -Xms10m -XX:+PrintGCDetails</p>
<p>再次运行，可以看到minor GC和full GC日志：</p>
<p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM50.jpg?versionId=CAEQKRiBgICetp77.hciIGYxOTYwMmUyYzM4MjRiZGJiODgwZjA5MmYwMDM4NjI2" srcset="/img/loading.gif" lazyload alt="images"></p>
<h1 id="第十章-相关面试题"><a href="#第十章-相关面试题" class="headerlink" title="第十章 相关面试题"></a>第十章 相关面试题</h1><h2 id="1、面试回答问题过程"><a href="#1、面试回答问题过程" class="headerlink" title="1、面试回答问题过程"></a>1、面试回答问题过程</h2><p><img src="https://lllong.oss-cn-shenzhen.aliyuncs.com/JVM/JVM51.jpg?versionId=CAEQKRiBgMCqtZ77.hciIGYyZGI1ODYwM2VjMjQ2OTBhZjI5NDBlMzBiMTEzOGU5" srcset="/img/loading.gif" lazyload alt="iamges"></p>
<h2 id="2、各个问题思路"><a href="#2、各个问题思路" class="headerlink" title="2、各个问题思路"></a>2、各个问题思路</h2><h3 id="①请谈谈你对-JVM-的理解？"><a href="#①请谈谈你对-JVM-的理解？" class="headerlink" title="①请谈谈你对 JVM 的理解？"></a>①请谈谈你对 JVM 的理解？</h3><ul>
<li>JVM 技术的作用：提升、优化项目性能</li>
<li>JVM 结构<ul>
<li>类加载机制</li>
<li>Java栈</li>
<li>堆<ul>
<li>新生代<ul>
<li>Eden 区</li>
<li>幸存者区：S0+S1</li>
</ul>
</li>
<li>老年代</li>
</ul>
</li>
<li>元空间</li>
</ul>
</li>
<li>GC<ul>
<li>垃圾对象的标记<ul>
<li>引用技术法</li>
<li>GC Roots：概念→原理（堆外指向堆内）→GC Root 对象</li>
</ul>
</li>
<li>垃圾回收算法</li>
</ul>
</li>
<li>JVM 常用参数</li>
</ul>
<h3 id="②Java-8-的虚拟机有什么更新？"><a href="#②Java-8-的虚拟机有什么更新？" class="headerlink" title="②Java 8 的虚拟机有什么更新？"></a>②Java 8 的虚拟机有什么更新？</h3><ul>
<li>永久代取消，变成元空间；</li>
<li>常量池放入到元空间，但是一直都是在方法区中。</li>
</ul>
<h3 id="③什么是OOM？"><a href="#③什么是OOM？" class="headerlink" title="③什么是OOM？"></a>③什么是OOM？</h3><ul>
<li>概念：堆内存溢出错误</li>
<li>全类名：java.lang.OutofMemoryError</li>
<li>产生原因：<ul>
<li>Java heap space：针对新生代、老年代整体进行Full GC后，内存空间还是放不下新产生的对象，且无法申请更多的空间</li>
<li>PermGen space：方法区中加载的类太多了（典型情况是框架创建的动态类太多，导致方法区溢出）</li>
</ul>
</li>
<li>详细过程：堆空间对象存储、GC 流程。</li>
<li>相关拓展：StackOverFlowError</li>
</ul>
<h3 id="④什么是StackOverflowError"><a href="#④什么是StackOverflowError" class="headerlink" title="④什么是StackOverflowError?"></a>④什么是StackOverflowError?</h3><ul>
<li>概念：栈内存溢出错误</li>
<li>产生原因：在一个线程中，栈内存分配给它的空间被不断新增的栈帧填满，没有及时释放栈帧。</li>
<li>详细过程：栈帧概念，栈帧中存储的数据，典型情况（无法退出的递归）</li>
<li>相关拓展：OOM</li>
</ul>
<h3 id="⑤-JVM-的常用参数调优你知道哪些？"><a href="#⑤-JVM-的常用参数调优你知道哪些？" class="headerlink" title="⑤ JVM 的常用参数调优你知道哪些？"></a>⑤ JVM 的常用参数调优你知道哪些？</h3><table>
<thead>
<tr>
<th>参数名</th>
<th>参数作用</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>★堆内存的初始大小</td>
</tr>
<tr>
<td>-Xmx</td>
<td>★堆内存的最大值（最多能够向操作系统申请多少）</td>
</tr>
<tr>
<td>-Xmn</td>
<td>新生代大小</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>设置永久代(perm gen)初始值</td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>设置持久代最大值</td>
</tr>
<tr>
<td>-Xss</td>
<td>每个线程的堆栈大小</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>Eden区与Survivor区的大小比值</td>
</tr>
</tbody></table>
<p>TIP</p>
<p>-Xss 设置每个线程在Java 栈中占用空间的大小。</p>
<p>线程数量 = Java 栈空间 / 每个线程空间(-Xss 参数设置的值)</p>
<p>线程深度 = 每个线程空间 / 每个栈帧空间</p>
<p>如果项目希望线程深度更大，那么应该给每个线程设置较大空间；</p>
<p>如果项目线程深度不大，线程数量很多，那么应该给每个线程设置较小空间。</p>
<p>线程深度：在一个线程中能够连续调用的方法的数量。</p>
<h3 id="⑥谈谈-JVM-中，对类加载器你的认识？"><a href="#⑥谈谈-JVM-中，对类加载器你的认识？" class="headerlink" title="⑥谈谈 JVM 中，对类加载器你的认识？"></a>⑥谈谈 JVM 中，对类加载器你的认识？</h3><p>双亲委派机制</p>
<ul>
<li>类加载器分类<ul>
<li>启动类加载器</li>
<li>扩展类加载器</li>
<li>应用类加载器</li>
<li>自定义加载器</li>
</ul>
</li>
<li>父子关系<ul>
<li>关系一：启动类加载器是扩展类加载器的父亲</li>
<li>关系二：扩展类加载器是应用类加载器的父亲</li>
</ul>
</li>
<li>查找机制：先让父加载器查找，如果找不到再让子加载器加载</li>
<li>好处<ul>
<li>好处1：避免重复操作</li>
<li>好处2：避免恶意替换核心 API</li>
</ul>
</li>
</ul>
<h3 id="⑦堆内存空间大小设置的建议。"><a href="#⑦堆内存空间大小设置的建议。" class="headerlink" title="⑦堆内存空间大小设置的建议。"></a>⑦堆内存空间大小设置的建议。</h3><ul>
<li>最大堆内存和初始化堆内存设置为一致：直接一步到位设置为能够使用的最大值，免除频繁申请空间的操作。<ul>
<li>空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制</li>
<li>空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</li>
</ul>
</li>
<li>新生代大小：Sun官方推荐配置为整个堆的 3/8</li>
</ul>
<p>TIP</p>
<p>如果咱妈给咱们设置的每个月零花钱的额度是 1000 元，那么为了少去烦她老人家，咱们一开始就是申请 1000 元全部。</p>
<h3 id="⑧Java-栈每个线程占用空间大小如何设置。"><a href="#⑧Java-栈每个线程占用空间大小如何设置。" class="headerlink" title="⑧Java 栈每个线程占用空间大小如何设置。"></a>⑧Java 栈每个线程占用空间大小如何设置。</h3><p>JDK5.0 以后每个线程所占用的栈内存大小为 1M，以前是 256K。根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右。一般小的应用， 如果栈不是很深， 应该是128k够用的。大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。</p>
<h3 id="⑨关于-finalize-机制，下面两种说法正确的是："><a href="#⑨关于-finalize-机制，下面两种说法正确的是：" class="headerlink" title="⑨关于 finalize 机制，下面两种说法正确的是："></a>⑨关于 finalize 机制，下面两种说法正确的是：</h3><p>A 调用 finalize() 方法的效果是把一个已经被 GC 销毁的对象恢复过来。</p>
<p> B 调用 finalize() 方法的效果是针对一个即将被 GC 销毁的对象，在销毁之前调用 finalize() 方法。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>、类加载器有哪些分类？<br><span class="hljs-number">2</span>、双亲委派机制的工作流程？<br><span class="hljs-number">3</span>、永久代和方法区的关系？和堆空间的关系？（选做）<br><span class="hljs-number">4</span>、栈溢出异常产生的原因。<br><span class="hljs-number">5</span>、堆溢出异常产生的原因。<br>	新生代、老年代空间不够导致的 OOM<br>	方法区空间不够导致的 OOM<br><span class="hljs-number">6</span>、堆空间中新生代（Eden区、幸存者区）、老年代的工作机制。<br><span class="hljs-number">7</span>、请说说 GC Roots 可达性分析的判断依据是什么？<br><span class="hljs-number">8</span>、<span class="hljs-keyword">JVM </span>的常用参数调优你知道哪些？<br><span class="hljs-number">9</span>、堆内存空间大小设置的建议。<br><span class="hljs-number">10</span>、<span class="hljs-keyword">Java </span>栈每个线程占用空间大小如何设置。<br></code></pre></td></tr></table></figure>



<h1 id="第十一章-附录：JVM-相关参数汇总"><a href="#第十一章-附录：JVM-相关参数汇总" class="headerlink" title="第十一章 附录：JVM 相关参数汇总"></a>第十一章 附录：JVM 相关参数汇总</h1><h1 id="第一节-生产时JVM参数设置参考"><a href="#第一节-生产时JVM参数设置参考" class="headerlink" title="第一节 生产时JVM参数设置参考"></a>第一节 生产时JVM参数设置参考</h1><ul>
<li>最大堆内存和初始化堆内存设置为一致：直接一步到位设置为能够使用的最大值，免除频繁申请空间的操作。</li>
<li>新生代大小：Sun官方推荐配置为整个堆的3/8</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">-Xmx3000M<br>-Xms3000M<br>-Xmn600M<br>-XX:PermSize=500M<br>-XX:MaxPermSize=500M<br>-Xss256K<br>-XX:+DisableExplicitGC<br>-XX:SurvivorRatio=1<br>-XX:+UseConcMarkSweepGC<br>-XX:+UseParNewGC<br>-XX:+CMSParallelRemarkEnabled<br>-XX:+UseCMSCompactAtFullCollection<br>-XX:CMSFullGCsBeforeCompaction=0<br>-XX:+CMSClassUnloadingEnabled<br>-XX:LargePageSizeInBytes=128M<br>-XX:+UseFastAccessorMethods<br>-XX:+UseCMSInitiatingOccupancyOnly<br>-XX:CMSInitiatingOccupancyFraction=70<br>-XX:SoftRefLRUPolicyMSPerMB=0<br>-XX:+PrintClassHistogram<br>-XX:+PrintGCDetails<br>-XX:+PrintGCTimeStamps<br>-XX:+PrintHeapAtGC<br>-Xloggc:log/gc.log<br></code></pre></td></tr></table></figure>

<h1 id="第二节-JVM常规参数"><a href="#第二节-JVM常规参数" class="headerlink" title="第二节 JVM常规参数"></a>第二节 JVM常规参数</h1><table>
<thead>
<tr>
<th>参数名称</th>
<th>含义</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>初始堆大小</td>
<td>物理内存的1/64(&lt;1GB)</td>
<td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制</td>
</tr>
<tr>
<td>-Xmx</td>
<td>最大堆大小</td>
<td>物理内存的1/4(&lt;1GB)</td>
<td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td>
</tr>
<tr>
<td>-Xmn</td>
<td>年轻代大小(1.4or lator)</td>
<td></td>
<td>注意：此处的大小是（eden+ 2 survivor space)。与jmap -heap中显示的New gen是不同的。 整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。 增大年轻代后,将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8</td>
</tr>
<tr>
<td>-XX:NewSize</td>
<td>设置年轻代大小(for 1.3/1.4)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:MaxNewSize</td>
<td>年轻代最大值(for 1.3/1.4)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>设置永久代(perm gen)初始值</td>
<td>物理内存的1/64</td>
<td></td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>设置持久代最大值</td>
<td>物理内存的1/4</td>
<td></td>
</tr>
<tr>
<td>-Xss</td>
<td>每个线程的堆栈大小</td>
<td></td>
<td>JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右 一般小的应用， 如果栈不是很深， 应该是128k够用的。大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。 和threadstacksize选项解释很类似，官方文档似乎没有解释，在论坛中有这样一句话：“-Xss is translated in a VM flag named ThreadStackSize” 一般设置这个值就可以了。</td>
</tr>
<tr>
<td>-XX:ThreadStackSize</td>
<td>Thread Stack Size</td>
<td></td>
<td>(0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and earlier); all others 0.]</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td>
<td></td>
<td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4，年轻代占整个堆栈的1/5 Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>Eden区与Survivor区的大小比值</td>
<td></td>
<td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td>
</tr>
<tr>
<td>-XX:LargePageSizeInBytes</td>
<td>内存页的大小不可设置过大， 会影响Perm的大小</td>
<td></td>
<td>=128m</td>
</tr>
<tr>
<td>-XX:+UseFastAccessorMethods</td>
<td>原始类型的快速优化</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:+DisableExplicitGC</td>
<td>关闭System.gc()</td>
<td></td>
<td>这个参数需要严格的测试</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>垃圾最大年龄</td>
<td></td>
<td>如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代即被回收的概率。 该参数只有在串行GC时才有效。</td>
</tr>
<tr>
<td>-XX:+AggressiveOpts</td>
<td>加快编译</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:+UseBiasedLocking</td>
<td>锁机制的性能改善</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-Xnoclassgc</td>
<td>禁用垃圾回收</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:SoftRefLRUPolicyMSPerMB</td>
<td>每兆堆空闲空间中SoftReference的存活时间</td>
<td>1s</td>
<td>softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap</td>
</tr>
<tr>
<td>-XX:PretenureSizeThreshold</td>
<td>对象超过多大是直接在老年代分配</td>
<td>0</td>
<td>单位字节 新生代采用Parallel Scavenge GC时无效 另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象</td>
</tr>
<tr>
<td>-XX:TLABWasteTargetPercent</td>
<td>TLAB占eden区的百分比</td>
<td>1%</td>
<td></td>
</tr>
<tr>
<td>-XX:+CollectGen0First</td>
<td>FullGC时是否先YGC</td>
<td>false</td>
<td></td>
</tr>
</tbody></table>
<h1 id="第三节-并行收集器相关参数"><a href="#第三节-并行收集器相关参数" class="headerlink" title="第三节 并行收集器相关参数"></a>第三节 并行收集器相关参数</h1><table>
<thead>
<tr>
<th>参数名称</th>
<th>含义</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+UseParallelGC</td>
<td>Full GC采用parallel MSC (此项待验证)</td>
<td></td>
<td>选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。(此项待验证)</td>
</tr>
<tr>
<td>-XX:+UseParNewGC</td>
<td>设置年轻代为并行收集</td>
<td></td>
<td>可与CMS收集同时使用 JDK5.0以上JVM会根据系统配置自行设置，所以无需再设置此值</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads</td>
<td>并行收集器的线程数</td>
<td></td>
<td>此值最好配置与处理器数目相等同样适用于CMS</td>
</tr>
<tr>
<td>-XX:+UseParallelOldGC</td>
<td>年老代垃圾收集方式为并行收集(Parallel Compacting)</td>
<td></td>
<td>这个是JAVA 6出现的参数选项</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis</td>
<td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td>
<td></td>
<td>如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</td>
</tr>
<tr>
<td>-XX:+UseAdaptiveSizePolicy</td>
<td>自动选择年轻代区大小和相应的Survivor区比例</td>
<td></td>
<td>设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</td>
</tr>
<tr>
<td>-XX:GCTimeRatio</td>
<td>设置垃圾回收时间占程序运行时间的百分比</td>
<td></td>
<td>公式为1/(1+n)</td>
</tr>
<tr>
<td>-XX:+ScavengeBeforeFullGC</td>
<td>Full GC前调用YGC</td>
<td>true</td>
<td>Do young generation GC prior to a full GC. (Introduced in 1.4.1.)</td>
</tr>
</tbody></table>
<h1 id="第四节-辅助信息"><a href="#第四节-辅助信息" class="headerlink" title="第四节 辅助信息"></a>第四节 辅助信息</h1><table>
<thead>
<tr>
<th>参数名称</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+PrintGC</td>
<td></td>
<td>输出形式：[GC 118250K-&gt;113543K(130112K), 0.0094143 secs] [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td></td>
<td>输出形式:[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]</td>
</tr>
<tr>
<td>-XX:+PrintGCTimeStamps</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-XX:+PrintGC:PrintGCTimeStamps</td>
<td></td>
<td>可与-XX:+PrintGC -XX:+PrintGCDetails混合使用 输出形式:11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]</td>
</tr>
<tr>
<td>-XX:+PrintGCApplicationStoppedTime</td>
<td>打印垃圾回收期间程序暂停的时间.可与上面混合使用</td>
<td>输出形式：Total time for which application threads were stopped: 0.0468229 seconds</td>
</tr>
<tr>
<td>-XX:+PrintGCApplicationConcurrentTime</td>
<td>打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用</td>
<td>输出形式：Application time: 0.5291524 seconds</td>
</tr>
<tr>
<td>-XX:+PrintHeapAtGC</td>
<td>打印GC前后的详细堆栈信息</td>
<td></td>
</tr>
<tr>
<td>-Xloggc:filename</td>
<td>把相关日志信息记录到文件以便分析。 与上面几个配合使用</td>
<td></td>
</tr>
<tr>
<td>-XX:+PrintClassHistogram</td>
<td>garbage collects before printing the histogram</td>
<td></td>
</tr>
<tr>
<td>-XX:+PrintTLAB</td>
<td>查看TLAB空间的使用情况</td>
<td></td>
</tr>
<tr>
<td>XX:+PrintTenuringDistribution</td>
<td>查看每次minor GC后新的存活周期的阈值</td>
<td>Desired survivor size 1048576 bytes, new threshold 7 (max 15) new threshold 7即标识新的存活周期的阈值为7。</td>
</tr>
<tr>
<td>-XX:+HeapDumpOnOutOfMemoryError</td>
<td>OOM时导出堆到文件。</td>
<td></td>
</tr>
</tbody></table>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/jvm/">jvm</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/jvm/">jvm</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客目前大部分文章都是参考尚硅谷或者马士兵教育的学习资料！<a href="http://www.atguigu.com/" rel="nofollow noopener"官网地址！</a> 
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/07/JUC01-Thread/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JUC学习笔记（一）多线程基本知识</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/02/28/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <span class="hidden-mobile">RabbitMQ学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">

  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
	<!--《添加网站运行时间 -->
<br/>

<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
var now = new Date(); 

function createtime() {
    //此处修改你的建站时间或者网站上线时间
    var grt = new Date('11/02/2021 21:39:00');
    now.setTime(now.getTime() + 250);
    days = (now - grt) / 1000 / 60 / 60 / 24;

    dnum = Math.floor(days);
    hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
        hnum = "0" + hnum;
    }
    minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
        mnum = "0" + mnum;
    }
    seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
        snum = "0" + snum;
    }
    document.getElementById("timeDate").innerHTML = " 本站已各种夹缝中安全运行 " + dnum + " 天 ";
    document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
}
setInterval("createtime()", 250);
</script>

<!-- 添加网站运行时间》-->
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
